<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flash.css">
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"gerrit1999.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac","show_result":true},"fold":{"enable":true,"height":300},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="随着 JDK 25 在 2025 年 9 月的 GA 发布，Java 平台再次在语言表达力、运行时性能与可维护性方面进行了系统性演进。对于正在构建大规模系统、微服务架构、云原生部署与 AI&#x2F;ML 集成的团队而言，这次升级不仅仅是“新语法”，而是“新范式 + 新成本 + 新机会”的组合拳。架构师与资深工程师必须重新评估启动时间、内存占用、并发模型、库依赖与安全能力，以确定哪些特性应即刻采纳，哪些需谨">
<meta property="og:type" content="article">
<meta property="og:title" content="JDK 25 新特性深度解析与代码示例">
<meta property="og:url" content="https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/index.html">
<meta property="og:site_name" content="星轨时光机">
<meta property="og:description" content="随着 JDK 25 在 2025 年 9 月的 GA 发布，Java 平台再次在语言表达力、运行时性能与可维护性方面进行了系统性演进。对于正在构建大规模系统、微服务架构、云原生部署与 AI&#x2F;ML 集成的团队而言，这次升级不仅仅是“新语法”，而是“新范式 + 新成本 + 新机会”的组合拳。架构师与资深工程师必须重新评估启动时间、内存占用、并发模型、库依赖与安全能力，以确定哪些特性应即刻采纳，哪些需谨">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-17T03:46:29.000Z">
<meta property="article:modified_time" content="2025-09-17T03:46:29.000Z">
<meta property="article:author" content="Gerrit1999">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JDK25">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/","path":"2025/jdk-25-新特性深度解析与代码示例/","title":"JDK 25 新特性深度解析与代码示例"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JDK 25 新特性深度解析与代码示例 | 星轨时光机</title>
  







<link rel="dns-prefetch" href="waline.gerrit2025.xyz"><link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星轨时光机</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Gerrit1999的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#jdk-25-%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88-overview-of-jdk-25-main-features"><span class="nav-text"> JDK 25 主要特性概览 (Overview of JDK 25 Main Features)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%BA%AE%E7%82%B9"><span class="nav-text"> 核心亮点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E8%AF%AD%E8%A8%80%E5%B1%82%E9%9D%A2%E4%BB%A3%E7%A0%81%E8%A1%A8%E8%BE%BE%E5%8A%9B%E7%9A%84%E5%86%8D%E5%BA%A6%E9%A3%9E%E8%B7%83"><span class="nav-text"> 一、语言层面：代码表达力的再度飞跃</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBprimitive-types-in-patterns-instanceof-and-switch-jep-507"><span class="nav-text"> 深入解读：Primitive Types in Patterns, instanceof, and switch (JEP 507)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBflexible-constructor-bodies-jep-513"><span class="nav-text"> 深入解读：Flexible Constructor Bodies (JEP 513)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBcompact-source-files-and-instance-main-methods-jep-512"><span class="nav-text"> 深入解读：Compact Source Files and Instance Main Methods (JEP 512)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBmodule-import-declarations-jep-511-delivered"><span class="nav-text"> 深入解读：Module Import Declarations (JEP 511, Delivered)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-jvm-%E5%A2%9E%E5%BC%BA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%97%A0%E5%A3%B0%E9%9D%A9%E5%91%BD"><span class="nav-text"> 二、JVM 增强：性能优化的无声革命</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBcompact-object-headers-jep-519"><span class="nav-text"> 深入解读：Compact Object Headers (JEP 519)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBahead-of-time-command-line-ergonomics-method-profiling-jep-514-jep-515"><span class="nav-text"> 深入解读：Ahead-of-Time Command-Line Ergonomics &amp; Method Profiling (JEP 514 &amp; JEP 515)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBgenerational-shenandoah-jep-521"><span class="nav-text"> 深入解读：Generational Shenandoah (JEP 521)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvector-api-jep-508-tenth-incubator"><span class="nav-text"> 深入解读：Vector API (JEP 508, Tenth Incubator)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E6%A0%B8%E5%BF%83%E5%BA%93-api-%E6%9B%B4%E6%96%B0%E7%BC%96%E7%A8%8B%E4%BD%93%E9%AA%8C%E7%9A%84%E6%8C%81%E7%BB%AD%E8%BF%9B%E5%8C%96"><span class="nav-text"> 三、核心库 API 更新：编程体验的持续进化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBstable-values-jep-502"><span class="nav-text"> 深入解读：Stable Values (JEP 502)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBkey-derivation-function-api-jep-510"><span class="nav-text"> 深入解读：Key Derivation Function API (JEP 510)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBpem-encodings-of-cryptographic-objects-jep-470-preview"><span class="nav-text"> 深入解读：PEM Encodings of Cryptographic Objects (JEP 470, Preview)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBstructured-concurrency-jep-505-fifth-preview"><span class="nav-text"> 深入解读：Structured Concurrency (JEP 505, Fifth Preview)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E5%8F%AF%E8%A7%82%E5%AF%9F%E6%80%A7%E5%A2%9E%E5%BC%BAjfr-%E7%9A%84%E5%85%A8%E9%9D%A2%E8%BF%9B%E5%8C%96"><span class="nav-text"> 四、可观察性增强：JFR 的全面进化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBjfr-cooperative-sampling-jep-518-%E4%B8%8E-cpu-time-profiling-jep-509-experimental"><span class="nav-text"> 深入解读：JFR Cooperative Sampling (JEP 518) 与 CPU-Time Profiling (JEP 509, Experimental)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBjfr-method-timing-tracing-jep-520"><span class="nav-text"> 深入解读：JFR Method Timing &amp; Tracing (JEP 520)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E5%B9%B3%E5%8F%B0%E6%94%AF%E6%8C%81%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%80%A7%E6%88%98%E7%95%A5%E6%80%A7%E8%B0%83%E6%95%B4"><span class="nav-text"> 五、平台支持与兼容性：战略性调整</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBremove-the-32-bit-x86-port-jep-503-delivered"><span class="nav-text"> 深入解读：Remove the 32-bit x86 Port (JEP 503, Delivered)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B%E9%9D%A2%E5%90%91%E6%9C%AA%E6%9D%A5%E7%9A%84-java-%E5%B9%B3%E5%8F%B0"><span class="nav-text"> 总结与展望：面向未来的 Java 平台</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AA%E6%9D%A5%E9%A2%84%E6%B5%8B%E4%B8%8E%E8%AE%A8%E8%AE%BA"><span class="nav-text"> 未来预测与讨论</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gerrit1999"
      src="https://avatars.githubusercontent.com/u/71630591">
  <p class="site-author-name" itemprop="name">Gerrit1999</p>
  <div class="site-description" itemprop="description">今人不见古时月，今月曾经照古人</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlcnJpdDE5OTk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gerrit1999"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmdlcnJpdDE5OTlAcXEuY29t" title="E-Mail → mailto:gerrit1999@qq.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnpoaGVvLmNvbS8=" title="https:&#x2F;&#x2F;blog.zhheo.com&#x2F;">张洪Heo - 分享设计与科技生活</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly95dXJpay5jYWZlLw==" title="https:&#x2F;&#x2F;yurik.cafe&#x2F;">景蓝的小屋</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV1YW5xaW4udG9wLw==" title="https:&#x2F;&#x2F;blog.uuanqin.top&#x2F;">半方池水半方田 - Qin's blog</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/71630591">
      <meta itemprop="name" content="Gerrit1999">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星轨时光机">
      <meta itemprop="description" content="今人不见古时月，今月曾经照古人">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JDK 25 新特性深度解析与代码示例 | 星轨时光机">
      <meta itemprop="description" content="随着 JDK 25 在 2025 年 9 月的 GA 发布，Java 平台再次在语言表达力、运行时性能与可维护性方面进行了系统性演进。对于正在构建大规模系统、微服务架构、云原生部署与 AI/ML 集成的团队而言，这次升级不仅仅是“新语法”，而是“新范式 + 新成本 + 新机会”的组合拳。架构师与资深工程师必须重新评估启动时间、内存占用、并发模型、库依赖与安全能力，以确定哪些特性应即刻采纳，哪些需谨慎引入。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JDK 25 新特性深度解析与代码示例
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-17 11:46:29" itemprop="dateCreated datePublished" datetime="2025-09-17T11:46:29+08:00">2025-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

            <div class="post-description">随着 JDK 25 在 2025 年 9 月的 GA 发布，Java 平台再次在语言表达力、运行时性能与可维护性方面进行了系统性演进。对于正在构建大规模系统、微服务架构、云原生部署与 AI/ML 集成的团队而言，这次升级不仅仅是“新语法”，而是“新范式 + 新成本 + 新机会”的组合拳。架构师与资深工程师必须重新评估启动时间、内存占用、并发模型、库依赖与安全能力，以确定哪些特性应即刻采纳，哪些需谨慎引入。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="jdk-25-主要特性概览-overview-of-jdk-25-main-features"><a class="markdownIt-Anchor" href="#jdk-25-主要特性概览-overview-of-jdk-25-main-features"></a> JDK 25 主要特性概览 (Overview of JDK 25 Main Features)</h1>
<table>
<thead>
<tr>
<th>JEP 编号</th>
<th>标题</th>
<th>类型与状态</th>
<th>核心领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>JEP 470</td>
<td>PEM Encodings of Cryptographic Objects</td>
<td>预览（Preview）</td>
<td>安全 / 密钥 /库支持 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 502</td>
<td>Stable Values</td>
<td>预览（Preview）</td>
<td>核心库 / 并发 /状态管理 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 503</td>
<td>Remove the 32-bit x86 Port</td>
<td>正式（Removal / Platform）</td>
<td>平台支持 /兼容性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 505</td>
<td>Structured Concurrency (第五次预览)</td>
<td>预览（Preview）</td>
<td>并发 /结构化任务管理 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 506</td>
<td>Scoped Values</td>
<td>正式（Closed / Delivered）</td>
<td>并发 /状态共享 /替代 ThreadLocal (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 507</td>
<td>Primitive Types in Patterns, instanceof, and switch (第三次预览)</td>
<td>预览（Preview）</td>
<td>语言 /模式匹配 /语法表达力 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 508</td>
<td>Vector API (第十次孵化)</td>
<td>孵化（Incubator）</td>
<td>性能 /数值 /向量计算 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 509</td>
<td>JFR CPU-Time Profiling</td>
<td>实验性（Experimental）</td>
<td>可观察性 /性能剖析工具 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 510</td>
<td>Key Derivation Function API</td>
<td>正式（Feature）</td>
<td>安全 /密钥派生 /协议支持 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 511</td>
<td>Module Import Declarations</td>
<td>正式（Feature）</td>
<td>语言 /模块化 /源码导入便利性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 512</td>
<td>Compact Source Files and Instance Main Methods</td>
<td>正式（Feature / Delivered）</td>
<td>语言 /脚本 /样板简化 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzUxMj91dG1fc291cmNlPWNoYXRncHQuY29t" title="JEP 512: Compact Source Files and Instance Main Methods">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 513</td>
<td>Flexible Constructor Bodies</td>
<td>正式（Feature / Delivered）</td>
<td>语言 /构造器特性 /可读性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 514</td>
<td>Ahead-of-Time Command-Line Ergonomics</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /启动 /AOT 性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 515</td>
<td>Ahead-of-Time Method Profiling</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /AOT /热路径 /预热性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 518</td>
<td>JFR Cooperative Sampling</td>
<td>正式（Feature / Delivered）</td>
<td>可观察性 /剖面采样稳定性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 519</td>
<td>Compact Object Headers</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /内存布局 /GC /性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzUxOT91dG1fc291cmNlPWNoYXRncHQuY29t" title="JEP 519: Compact Object Headers">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 520</td>
<td>JFR Method Timing &amp; Tracing</td>
<td>正式（Feature / Delivered）</td>
<td>可观察性 /方法级 trace /性能诊断 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 521</td>
<td>Generational Shenandoah</td>
<td>正式（Feature / Delivered）</td>
<td>GC /性能 /低停顿 /大对象堆 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
</tbody>
</table>
<p>数据来源：<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUv">openjdk.org<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="核心亮点"><a class="markdownIt-Anchor" href="#核心亮点"></a> 核心亮点</h2>
<ol>
<li><strong>性能与启动时间的质变</strong> —— AOT 命令行流程（JEP 514）、方法剖面写入 AOT（JEP 515）与 Compact Object Headers（JEP 519）的成熟，使冷启动/预热 &amp; 内存密集场景中的性能提升成为可度量的改进。</li>
<li><strong>并发与状态共享模型的现代化</strong> —— Structured Concurrency（JEP 505）、Scoped Values（JEP 506）与 Stable Values（JEP 502）引入更安全、更可推理、低样板的线程上下文与状态管理方式，减少传统 ThreadLocal + try/finally + cancel/timeout 模式的风险与复杂性。</li>
<li><strong>安全性与生态库支持的提升</strong> —— Key Derivation Function API（JEP 510）、PEM 编码/解码 API（JEP 470）等特性使密码学库更加标准化，也让安全工具集成与第三方协议支持更加平滑；同时 Vector API 的进步表明数值/AI/ML 场景下 Java 在本地硬件能力利用上的野心。</li>
</ol>
<h1 id="一-语言层面代码表达力的再度飞跃"><a class="markdownIt-Anchor" href="#一-语言层面代码表达力的再度飞跃"></a> 一、语言层面：代码表达力的再度飞跃</h1>
<p>接下来从几个修改语法与类型模型的新特性入手，分析它们如何影响架构设计与代码质量。</p>
<h2 id="深入解读primitive-types-in-patterns-instanceof-and-switch-jep-507"><a class="markdownIt-Anchor" href="#深入解读primitive-types-in-patterns-instanceof-and-switch-jep-507"></a> 深入解读：Primitive Types in Patterns, instanceof, and switch (JEP 507)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
在以往版本中，pattern matching / <code>instanceof</code> / <code>switch</code> 针对引用类型已经越来越强，但原始类型依然不能被直接模式匹配或用做 <code>instanceof</code> 检查的一部分。通常的做法是用 wrapper 类型或手动转换/拆箱，这带来：装箱/拆箱的性能开销、代码样板冗余、可空性带来的空指针风险，以及类型检查与转换杂乱无章，尤其在解析层、DSL 层、配置/反序列化过程中尤为明显。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 507 在第三次预览中允许原始类型（如 <code>int</code>, <code>long</code> 等）在所有模式匹配语境中使用，包括 <code>instanceof</code> 和 <code>switch</code> 分支。这意味着：</p>
<ul>
<li><code>if (obj instanceof int i) &#123; ... &#125;</code> 成为合法语法，减少显式 cast 与拆箱。</li>
<li>在 <code>switch (expr)</code> 中可以有 <code>case int i -&gt; ...</code> 或匹配原始类型模式，与引用类型模式共存。</li>
<li>编译期会检查类型主导性（dominance），防止原始类型分支被更一般的类型分支屏蔽。</li>
</ul>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimitivePatternOld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ((Integer) v).intValue();  <span class="comment">// 显式拆箱</span></span><br><span class="line">            System.out.println(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> Integer ii -&gt; System.out.println(<span class="string">&quot;int: &quot;</span> + ii);</span><br><span class="line">            <span class="keyword">case</span> Long ll    -&gt; System.out.println(<span class="string">&quot;long: &quot;</span> + ll);</span><br><span class="line">            <span class="keyword">default</span>         -&gt; System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimitivePatternNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="type">int</span> i) &#123;  <span class="comment">// 原始类型模式</span></span><br><span class="line">            System.out.println(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span> i -&gt; System.out.println(<span class="string">&quot;primitive int: &quot;</span> + i);</span><br><span class="line">            <span class="keyword">case</span> <span class="type">long</span> l -&gt; System.out.println(<span class="string">&quot;primitive long: &quot;</span> + l);</span><br><span class="line">            <span class="keyword">case</span> Integer ii -&gt; System.out.println(<span class="string">&quot;boxed Integer: &quot;</span> + ii);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
这种变革使得那些基于反射 /模式匹配 /消息调度 /命令处理的框架可以简化 matcher/visitor 的实现，不再为了处理原始类型与引用类型分别写不同路径。可能削弱以前&quot;包装类型 + 工具辅助&quot;的设计，鼓励更加统一的模式表达。对于 DSL 或者混合类型系统（如 JSON + 强类型对象 +原始类型）项目尤为有利。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
装箱/拆箱减少、对象产生减少，对 GC 压力有积极意义；但编译器 /字节码生成中引入 pattern 匹配的复杂性与判断分支可能带来微小的开销。特别在高度性能敏感的 inner-loop 或者需要极端优化（如数百万次匹配）场景，需要做基准测试。还有：分支预测可能因为多种类型混合而变差。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
在大型项目中，可先将此特性限定在边缘层（解析器、配置加载、API boundary等），让团队熟悉其语义与行为。CI 中启用 preview 特性 (<code>--enable-preview</code>) 进行静态分析与编译检查，确保代码风格一致。注意回退兼容性：旧版本 JDK 的构建/部署环境若不支持，会导致编译错误。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读flexible-constructor-bodies-jep-513"><a class="markdownIt-Anchor" href="#深入解读flexible-constructor-bodies-jep-513"></a> 深入解读：Flexible Constructor Bodies (JEP 513)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
构造器语义中，&quot;super(…) 或 this(…) 必须是首语句&quot;这一传统规则在直观可读性与错误处理方面造成很多样板：在参数校验、辅助计算或格式规范化之前，必须写静态 helper 或先调用 super 然后再做校验，这在继承链复杂或类层次深的架构中易导致错误抛出的时机不直观，也会使得对象字段在父构造器调用中可见但未被期望初始化。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 513 允许在调用父构造器或本类其他构造器之前执行一些&quot;安全语句&quot;（不能使用未初始化状态的 <code>this</code>），例如校验参数、准备计算值、校正、甚至日志。这样可以让构造逻辑更自然、错误报错更早、更精确；同时让对象的字段在调用父构造器时更有保障。该特性在 JDK 25 中成为正式特性。</p>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent ctor called with x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sanitize</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;y must be &gt;= 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(<span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">super</span>(sanitize(y));  <span class="comment">// 校验必须在静态 helper 中做</span></span><br><span class="line">        <span class="comment">// 字段初始化或其他逻辑只能在 super 后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent ctor called with x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    Child(<span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;y must be &gt;= 0&quot;</span>);  <span class="comment">// 校验提前</span></span><br><span class="line">        <span class="built_in">this</span>.y = y;  <span class="comment">// 可以初始化字段</span></span><br><span class="line">        <span class="built_in">super</span>(y);    <span class="comment">// 调用父构造器</span></span><br><span class="line">        <span class="comment">// 更多逻辑……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
在工厂模式 /继承 /子类与超类强耦合的设计中，以往为了在父构造器中调用某些方法或记录日志，很多设计都会用静态辅助类或构造器链，这些会被重新审视。现在能把校验、状态标准化逻辑移回构造器开头，使构造流程语义更清晰。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
本质上对运行期几乎无影响；仅是微调语法顺序；但可能影响字节码生成顺序与初始化顺序，某些框架（例如序列化库、反射代理、依赖注入框架）假设父类构造器中某些字段未设定或某些行为可能会因子类字段在调用 super 前完成赋值而改变行为。在这种情况下，需要审查是否依赖旧语义。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
在重大变更部件（父类/子类关系复杂的库）中做代码审查与行为测试（尤其父构造器调用期间调用 overridden 方法或调用子类方法的情境）。构造器逻辑建议保持轻量，避免提前做 I/O /网络 /长耗时操作。制定规范：只允许做&quot;校验 / 框架友好准备 /字段赋值&quot;，不允许做重工作。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读compact-source-files-and-instance-main-methods-jep-512"><a class="markdownIt-Anchor" href="#深入解读compact-source-files-and-instance-main-methods-jep-512"></a> 深入解读：Compact Source Files and Instance Main Methods (JEP 512)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
快速脚本、工具类、示例、教学代码等场景中，一套繁重的包 + 类 + <code>public static void main(String[])</code> boilerplate 降低了开发速度与可读性。尤其团队中常见的小工具、命令行启动脚本需要快速编辑、测试、部署，这些样板成为&quot;摩擦点&quot;。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 512 在 JDK 25 中成为正式特性，允许：</p>
<ul>
<li>单文件程序可以省略顶层 <code>class</code> 声明；</li>
<li>用非静态实例 <code>main</code> 方法作为入口；</li>
<li>代码直接包含顶层语句与表达式，支持 <code>java Hello.java</code> 直接运行；</li>
<li>向后兼容性保留原有模式。</li>
</ul>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloOld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, verbose Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, compact source Java 25.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
此特性不会影响核心架构，但在工具库、CLI 工具、脚本式任务 &amp;开发者体验上大有裨益；能促进内部工具 /开发脚手架统一而减少样板，使微工具更易于维护。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
与语法样板本身无关性能；但开发效率提升可减少代码出错率，也可能缩短迭代周期。工具链（IDE,构建系统,静态分析器）可能需要更新以正确支持这些语法并处理 source-level 分析。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
推荐将此特性用于 <code>tools/</code>, <code>scripts/</code>, <code>examples/</code> 目录；生产核心业务模块可保持传统（class + public static main）以保持一致性。确保代码审查 /格式化工具支持；文档与团队共享规范。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读module-import-declarations-jep-511-delivered"><a class="markdownIt-Anchor" href="#深入解读module-import-declarations-jep-511-delivered"></a> 深入解读：Module Import Declarations (JEP 511, Delivered)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
随着模块化，使用某个模块时往往需要手动写很多包级 <code>import</code> 语句或维护 <code>module-info.java</code>。这对原型、教学或小工具带来样板负担。JEP 511 旨在在源文件层面引入 <code>import module M;</code> 声明 —— 类似顶层的包 import，但按模块一次性导入该模块导出的所有 public 顶层类/接口（以及模块所读模块导出的类型，按规则递归/传递）。</p>
</li>
<li>
<p><strong>核心解决方案与机制</strong><br />
<code>import module M;</code> 出现在文件顶部，相当于按模块内导出包对每个包做 on-demand import（如 <code>java.base</code> 的所有导出包会像 <code>import java.io.*; import java.util.*; ...</code> 那样可见）。该特性降低了学习/原型/脚本的摩擦，同时仍可与现有模块系统共存（它并不替代 <code>module-info.java</code> 的 <code>requires</code>）。</p>
</li>
<li>
<p><strong>代码示例</strong></p>
</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> <span class="keyword">module</span> java.logging;  <span class="comment">// 将 java.logging 模块导出的 public 顶级类型按需导入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleImportDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处可以直接使用 Logger（来自 java.util.logging）而无需显式 package import</span></span><br><span class="line">            java.util.logging.<span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> java.util.logging.Logger.getLogger(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 也可直接 Logger，如果无冲突</span></span><br><span class="line">            logger.info(<span class="string">&quot;Module import demo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：模块导入会带来命名冲突风险（若多个导入模块中存在同名顶级类型），此时仍可使用显式包名或普通 <code>import</code> 来消歧。对大型代码库，建议谨慎在核心业务代码中使用模块导入，更多用于脚本、示例与快速原型。</p>
<ul>
<li><strong>架构师的思考：</strong>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
此特性主要简化开发体验，不会对核心架构设计产生重大影响。但在快速原型开发、脚本编写、教学示例中能显著减少样板代码，提升开发效率。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
编译时解析，运行时无额外开销。主要权衡是可能带来的命名空间污染和潜在的命名冲突风险，需要团队建立清晰的使用规范。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
建议先在工具脚本、示例代码中试用；制定团队规范明确何时使用模块导入；在大型项目中谨慎使用，避免在核心业务代码中引入不必要的复杂性。</p>
</li>
</ul>
</li>
</ul>
<h1 id="二-jvm-增强性能优化的无声革命"><a class="markdownIt-Anchor" href="#二-jvm-增强性能优化的无声革命"></a> 二、JVM 增强：性能优化的无声革命</h1>
<p>探讨那些在启动 /内存布局 /GC /可观察性上带来实质性、可能被忽略但重要的改进。</p>
<h2 id="深入解读compact-object-headers-jep-519"><a class="markdownIt-Anchor" href="#深入解读compact-object-headers-jep-519"></a> 深入解读：Compact Object Headers (JEP 519)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
在大对象数的系统（每秒大量 POJO、消息对象、JSON/Protobuf 解码器输出等），对象头部（mark word + class pointer +对齐填充等）在 64 位 JVM 上一直是一个不可忽视的开销。对象头过大不仅浪费内存，也降低缓存局部性和 GC 期间的扫描效率。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong><br />
JEP 519 把对象头从实验状态提升为产品特性，将其压缩到 64 位（8 bytes），去掉冗余 bits，同时保留所有 GC 状态、类指针及必要标记。HotSpot 在对象创建、对齐以及标记阶段会考虑这种压缩头的布局与填充方式。该特性在 JDK 25 中默认可用（不再依赖实验标志），但需通过 <code>-XX:+UseCompactObjectHeaders</code> 显式启用。(<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcw==">JDK 25 Features &amp; Release Notes<i class="fa fa-external-link-alt"></i></span>) (<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcz91dG1fc291cmNlPWNoYXRncHQuY29t" title="JDK 25 Release Notes - Java Net">jdk.java.net<i class="fa fa-external-link-alt"></i></span>)</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseCompactObjectHeaders -jar yourapp.jar</span><br></pre></td></tr></table></figure>
<p>使用 JFR / VisualVM / JMX 查看堆的对象 histogram，对比对象大小与 total heap 使用；在 Linux 环境用 <code>smaps</code> 或 OS 工具查看 RSS；观察 GC pause 时间是否减少。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
大量短生命周期对象的小服务；流处理 /JSON/XML/Protobuf解析密集；容器化部署中内存成为限制因素的应用。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
内存使用下降，缓存miss 率下降，有助于 GC 压力减轻。可能在某些 native 工具或本机代码中，假设对象头布局固定的代码或工具会失效，需验证兼容性。对象头压缩可能对调试工具 / heap dump 分析器等影响其假设。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
在 Stage 环境中开启 A/B 测试；监控 p50/p95 延迟，GC pause 分布；用于 small object allocation rate、promotion rate、serialization/deserialization 性能；确保识别出因 header 压缩导致的工具链故障。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读ahead-of-time-command-line-ergonomics-method-profiling-jep-514-jep-515"><a class="markdownIt-Anchor" href="#深入解读ahead-of-time-command-line-ergonomics-method-profiling-jep-514-jep-515"></a> 深入解读：Ahead-of-Time Command-Line Ergonomics &amp; Method Profiling (JEP 514 &amp; JEP 515)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
冷启动延迟、预热期的性能过渡不平滑是微服务 /serverless /短寿命容器的常见瓶颈。以往工程会采用缓存类加载、预热 JIT，或手工 profile 并加载类。流程繁琐、不一致；AOT cache 虽然在 JDK 24 已初具形态，但生成与应用流程仍显得笨重。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong></p>
<ul>
<li>JEP 514 简化命令行接口：合并 record 与 create 步骤，让开发者更便捷地生成 AOT 缓存。</li>
<li>JEP 515 在训练 run（训练过程）中收集方法执行的 profile 信息（哪些方法被调用、频率等），将这些信息存入 AOT cache；下次启动时，JIT / AOT 可立即利用这些 profile 来决定哪些方法应提前编译／优化。减少热路径的启动 /预热成本。</li>
</ul>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练并生成 AOT cache</span></span><br><span class="line">java -XX:AOTCacheOutput=app.aot -jar myapp.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用并使用 AOT cache</span></span><br><span class="line">java -XX:AOTCache=app.aot -jar myapp.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JFR 或 hotspot 的 compilation log 观察编译事件；监控应用启动 latency（first request / first API 响应），以及预热期间的 CPU 使用率与 JIT 编译次数。</li>
</ul>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
短生命周期服务（如 Lambda /微函数 /container startup），CLI 程序，web 前端组件启动；也适合部署到边缘环境 /启动成本高 /资源受限的环境。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
AOT cache 训练需要一段代表性负载；若训练与生产不一致，反而可能产生误导性 profile，导致非最优的热路径；AOT cache 文件大小与平台兼容性问题（CPU arch /OS版本）需考虑。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
制定&quot;训练任务&quot;模板，这些任务应覆盖典型流量与边缘情况；将 AOT cache 与应用版本联合 version-control；在多个环境 /节点上对比启动 &amp;预热指标；为回滚设定阈值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读generational-shenandoah-jep-521"><a class="markdownIt-Anchor" href="#深入解读generational-shenandoah-jep-521"></a> 深入解读：Generational Shenandoah (JEP 521)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
原先的 Shenandoah GC 优秀在低暂停延迟环境，但在处理短生命周期对象（年轻代）时与传统 generational GC（如 G1）相比有一定缺陷：即便对象寿命短，也被频繁促升或被长时间扫描。对于高 throughput +低延迟 +大量临时对象的系统，这成为瓶颈。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong><br />
JEP 521 把 generational 模式引入 Shenandoah: 设置 young / old regions，使得短生命周期对象更快被回收；保留了 Shenandoah 的并发标记与整理特性，减少全堆停顿；改进 young-gen 回收、promotion策略，以及与 compaction / evacuation 的交互。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -jar yourapp.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>监控 GC 日志（-Xlog:gc*, -Xlog:gc+pause=info）</li>
<li>用 JFR /GC采样工具观察 young-gen 回收时间、promotion rate、allocation rate、小对象分配及淘汰比例。</li>
</ul>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
高并发 web 服务、大数据管道 /流处理节点 /在线事务系统，这些系统既要低延迟又有高吞吐；尤其那些短生命周期对象很多、内存分配 &amp;回收频繁。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
在某些极端场景，generational Shenandoah 的复杂度高于简单 GC; young-gen 对象 promotion 逻辑带来的同步或内存碎片问题可能出现；长期运行的大堆 /大对象情况仍需对比 G1 或 ZGC 的表现。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
优化 young-gen 大小、promotion Age；监控 survivor 区间的填满速率；定位大对象分配；观察 GC pause latency 的分布；在服务级别设置可接受延迟范围并设定 fallback GC 策略。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读vector-api-jep-508-tenth-incubator"><a class="markdownIt-Anchor" href="#深入解读vector-api-jep-508-tenth-incubator"></a> 深入解读：Vector API (JEP 508, Tenth Incubator)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
数值/媒体/ML/信号处理类代码需要利用 SIMD 指令（CPU 向量化能力）以提高吞吐。手写 JNI 或依赖 C/C++ 库增加维护成本。Vector API 提供一个平台独立、可移植的向量编程接口，让 JVM 在运行时将向量化操作映射到底层 SIMD 指令。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
<code>jdk.incubator.vector</code> 提供 <code>Vector</code>、<code>IntVector</code>、<code>FloatVector</code>、<code>VectorSpecies</code> 等类，允许以数组/向量批量方式进行算术、混洗（shuffle）、加载/存储。JEP 508 在 JDK 25 中再次以 incubator 的形式出现（第十轮），包含 API 与实现改进。使用时需显式启用 incubator 模块。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li><strong>代码示例（整型向量批量加法，可直接编译/运行）</strong></li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile: javac --release 25 --add-modules jdk.incubator.vector VectorAdd.java</span></span><br><span class="line"><span class="comment">// Run:     java --add-modules jdk.incubator.vector VectorAdd</span></span><br><span class="line"><span class="keyword">import</span> jdk.incubator.vector.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorAdd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] b = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        VectorSpecies&lt;Integer&gt; SPECIES = IntVector.SPECIES_PREFERRED;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> SPECIES.loopBound(a.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; upper; i += SPECIES.length()) &#123;</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">va</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, a, i);</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">vb</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, b, i);</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">vc</span> <span class="operator">=</span> va.add(vb);</span><br><span class="line">            vc.intoArray(c, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = a[i] + b[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : c) System.out.print(v + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>最佳应用场景：</strong>  <br />
数值计算密集型应用；图像/音频处理；机器学习推理；大数据批处理；科学计算等需要大量并行数值运算的场景。</p>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
</li>
<li>
<p><strong>性能与权衡：</strong>  <br />
在支持 SIMD 的平台上可带来显著加速；但对于短数组/高分支逻辑，向量化开销可能抵消收益。还需关注对不同 CPU ISA 的映射差异（ARM NEON vs x86 AVX）。</p>
</li>
<li>
<p><strong>调优策略：</strong>  <br />
基准驱动的优化：先在热点（内核循环）引入 Vector API，并做 A/B 测试；把实现封装在低层 util/adapter 中，避免分散到业务代码；注意在 CI 测试矩阵覆盖主要 CPU 架构。因为是 incubator，API 可能继续演进，封装能降低未来迁移成本。</p>
</li>
</ul>
<h1 id="三-核心库-api-更新编程体验的持续进化"><a class="markdownIt-Anchor" href="#三-核心库-api-更新编程体验的持续进化"></a> 三、核心库 API 更新：编程体验的持续进化</h1>
<p>这部分讲几个库层面的更新，着重安全 /状态管理 /工具支持上对现有架构影响的地方。</p>
<h2 id="深入解读stable-values-jep-502"><a class="markdownIt-Anchor" href="#深入解读stable-values-jep-502"></a> 深入解读：Stable Values (JEP 502)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
Java 的 <code>final</code> 字段虽能在编译期提供不变性承诺，但在初始化时（尤其在依赖注入容器、模块启动或大型系统初始化）它必须在构造完成或 static 初始化块中被设定；而某些延迟初始化 /按需加载场景中，想要不牺牲性能 /语义安全地“像 final 那样”的不变状态，需要复杂同步或锁。状态初始化早晚与并发安全性成为常见痛点。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong><br />
<code>StableValue&lt;T&gt;</code> 提供一个 holder，可以被设定一次（atomically），在设定之前处于 unset 状态；通过 <code>orElseSet(...)</code> 初始化；一旦设定，不可变；支持查询 <code>isSet()</code>；Treatable by JVM 的编译器优化潜力因为其语义接近 final。处于预览状态。 (<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcz91dG1fc291cmNlPWNoYXRncHQuY29t" title="JDK 25 Release Notes - Java Net">jdk.java.net<i class="fa fa-external-link-alt"></i></span>)</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StableValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StableValueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StableValue&lt;String&gt; config = StableValue.of();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.orElseSet(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟某种昂贵的配置读取或外部依赖</span></span><br><span class="line">            <span class="keyword">return</span> loadConfigFromFileOrEnv();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">loadConfigFromFileOrEnv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这是昂贵或 I/O 的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Loading config...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CONFIG_VALUE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StableValueDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StableValueDemo</span>();</span><br><span class="line">        System.out.println(demo.getConfig());</span><br><span class="line">        System.out.println(demo.getConfig());  <span class="comment">// 第二次调用不会重新加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong><br />
现有项目中通常用 <code>volatile</code> + <code>double‐check locking</code> 或者 <code>AtomicReference</code> + CAS 操作，或者 lazy holder +同步。这些方案虽然成熟，但常见的错误有锁粒度过大、初始化重复、异常安全性不佳。<code>StableValue</code> 提供一种更语义化、更清晰、不易出错的模式。</p>
</li>
<li>
<p><strong>集成与迁移：</strong><br />
在项目中引入时，建议先用于非关键路径（日志、缓存、工具类等），并且明确哪些部分需要“一次初始化即不可变”；与依赖注入框架结合时要小心 error handling；如果已有很多类似机制，需要决定是否重构。因为是预览特性，迁移成本含编译器支持、测试支持、与旧版本 JDK 的兼容性。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>将 <code>StableValue.of()</code> 放在对象字段里，而非静态变量，以避免类加载 /初始化阶段的复杂依赖。</li>
<li>在 <code>orElseSet</code> lambda 内不要做长时间 I/O 或阻塞操作——最好像 lazy initialization 那样尽早失败/快速返回。</li>
<li>在并发使用中关注异常传播与线程安全（如果两个线程同时调用 orElseSet，应确保只有一个初始化成功）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读key-derivation-function-api-jep-510"><a class="markdownIt-Anchor" href="#深入解读key-derivation-function-api-jep-510"></a> 深入解读：Key Derivation Function API (JEP 510)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
加密协议中衍生密钥的需求普遍（如 HKDF, Argon2, TLS /混合加密），但之前 Java 标准库对此支持不统一、各实现散落在不同 provider 或第三方库中。开发者经常会手写或引入 BouncyCastle /外部库，导致难以审计、兼容性问题、算法规范互异。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong><br />
JEP 510 在 JDK 25 中正式纳入标准 Key Derivation Function (KDF) API。支持标准算法名称（如 <code>HKDF-SHA256</code> 等），提供参数规范如 extract / expand 阶段、长度控制、provider 插拔性。使得协议实现 /安全库集成更为一致。</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.KDF;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.HKDFParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KDFDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] ikm  = <span class="string">&quot;input-key-material&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] salt = <span class="string">&quot;salt&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] info = <span class="string">&quot;info&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 HKDF-SHA256 实例</span></span><br><span class="line">        <span class="type">KDF</span> <span class="variable">hkdf</span> <span class="operator">=</span> KDF.getInstance(<span class="string">&quot;HKDF-SHA256&quot;</span>);</span><br><span class="line">        <span class="type">HKDFParameterSpec</span> <span class="variable">params</span> <span class="operator">=</span> HKDFParameterSpec.ofExtract()</span><br><span class="line">                                      .addIKM(ikm)</span><br><span class="line">                                      .addSalt(salt)</span><br><span class="line">                                      .thenExpand(info, <span class="number">32</span>);  <span class="comment">// 想要 32 bytes 的输出</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">derived</span> <span class="operator">=</span> hkdf.deriveKey(<span class="string">&quot;AES&quot;</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived key (Hex): &quot;</span> + HexFormat.of().formatHex(derived.getEncoded()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong><br />
在很多项目里 BouncyCastle /外部安全库已提供 HKDF / Argon2 等。多数团队可开始逐步切换到标准 API，以减少依赖、提升可维护性，并受益于平台安全基线与审计。</p>
</li>
<li>
<p><strong>集成与迁移：</strong><br />
在兼容性方面先进行算法行为的一致性测试（输出、边缘情况等）。如之前使用 BC 的某个具体版本，对 salt/ikm 长度或处理方式的差异要评估。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>明确说使用哪个算法名称；文档中列明参数格式 /边界处理；</li>
<li>对于敏感密钥材料，用完后及时清零 /垃圾回收；</li>
<li>在测试中包括安全性边界（如重复 derive，zero salt 等情况）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读pem-encodings-of-cryptographic-objects-jep-470-preview"><a class="markdownIt-Anchor" href="#深入解读pem-encodings-of-cryptographic-objects-jep-470-preview"></a> 深入解读：PEM Encodings of Cryptographic Objects (JEP 470, Preview)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
PEM（Privacy-Enhanced Mail，RFC 7468）是应用极广的文本格式，用于传输证书、公/私钥和 CRL。以前 Java 平台没有统一、易用的 API：解码/编码 PEM 需要手写解析或依赖 BouncyCastle/OpenSSL 等第三方库，导致审计、跨平台行为和加密参数一致性问题。JEP 470 目标是把 PEM 编解码标准化为平台 API，简化常见操作并降低外部依赖。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong>  <br />
在 <code>java.security</code> 包中新增接口与类（<code>DEREncodable</code>、<code>PEMEncoder</code>、<code>PEMDecoder</code>、<code>PEMRecord</code> 等），提供可重用、线程安全的编码/解码器。<code>PEMDecoder</code> 可以把 PEM 文本解码成受支持的 DER 可编码对象（例如 <code>X509Certificate</code>、<code>EncryptedPrivateKeyInfo</code> 等）；<code>PEMEncoder</code> 可以把证书、密钥等编码回 PEM 文本，并支持对私钥的默认 PBE 加密或通过 <code>EncryptedPrivateKeyInfo</code> 指定自定义参数。<strong>此 API 在 JDK 25 为 preview，需要 <code>--enable-preview</code> 来编译/运行示例。</strong></p>
</li>
<li>
<p><strong>用法示例：</strong><br />
把一个 PEM 编码的证书字符串解码为 <code>X509Certificate</code> 并打印主题信息。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile: javac --release 25 --enable-preview PemDecodeDemo.java</span></span><br><span class="line"><span class="comment">// Run:     java --enable-preview PemDecodeDemo</span></span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PemDecodeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个最小示例替代真实证书内容（实际使用请替换为真实 PEM）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CERT_PEM</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        -----BEGIN CERTIFICATE-----  </span></span><br><span class="line"><span class="string">        MIIBszCCAVigAwIBAgIJAO3q...REPLACE_WITH_REAL_BASE64...IDAQAB  </span></span><br><span class="line"><span class="string">        -----END CERTIFICATE-----  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用平台的 PEMDecoder（java.security.PEMDecoder）</span></span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> java.security.PEMDecoder.of()</span><br><span class="line">                                    .decode(CERT_PEM, X509Certificate.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject DN: &quot;</span> + cert.getSubjectDN());</span><br><span class="line">        System.out.println(<span class="string">&quot;Issuer DN : &quot;</span> + cert.getIssuerDN());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：该 API 会返回 <code>PEMRecord</code> 当遇到未知/自定义 PEM 类型；对于加密私钥，可以先 <code>decode</code> 到 <code>EncryptedPrivateKeyInfo</code>，再调用其 <code>getKey(password)</code> 解密成 <code>PrivateKey</code>。</p>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong>  <br />
把 PEM 转换纳入标准库，项目应优先使用平台 API，减少对 BC/OpenSSL 的直接依赖；但对于非常新或非标准格式，仍可能需要第三方支持。</p>
</li>
<li>
<p><strong>集成与迁移：</strong>  <br />
在安全敏感的代码里替换手写 PEM 解析；对现有使用第三方库的模块做回归测试（加密参数、默认 PBE 算法差异）；因为是 preview，逐步迁移并在 CI 中保留对旧 JDK（若需）构建的兼容分支。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>PEM 编解码本质为文本→Base64→DER 转换，CPU 开销低。主要收益是<strong>安全性审计、可维护性与一致行为</strong>，不是显著的运行时性能改进。</li>
<li>对于敏感密钥材料，用完后及时清零/垃圾回收；在测试中包括安全性边界处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读structured-concurrency-jep-505-fifth-preview"><a class="markdownIt-Anchor" href="#深入解读structured-concurrency-jep-505-fifth-preview"></a> 深入解读：Structured Concurrency (JEP 505, Fifth Preview)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
    传统使用 <code>ExecutorService</code>/<code>Future</code> 管理并发时，错误处理、取消、线程泄漏与可观察性变得复杂，尤其在使用虚拟线程的大规模并发下。结构化并发（structured concurrency）以&quot;任务-子任务&quot;的嵌套语法语义，把一组相关子任务视为单个逻辑单元，简化 error/cancel 管理并增强可观测性。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong>  <br />
    引入 <code>StructuredTaskScope</code>（位于 <code>java.util.concurrent</code>）等 API：在一个<strong>词法作用域</strong>内 fork 子任务，调用 <code>join()</code> 后统一处理成功或失败（失败时自动取消其它子任务），并将子任务的生命周期限制在这个作用域。JDK 25 是第五次预览，API 有多次调整（factory open 方法、join/short-circuit 行为、Subtask/resultNow 细节等）。</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile/Run with JDK25 (no special flags needed for preview here; JEP505 is a preview API in JDK25)</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.StructuredTaskScope;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StructuredConcurrencyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">findUser</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="keyword">return</span> <span class="string">&quot;alice&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer <span class="title function_">fetchOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">        Thread.sleep(<span class="number">150</span>); <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">record</span> <span class="title class_">Response</span><span class="params">(String user, <span class="type">int</span> order)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Response <span class="title function_">handle</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> StructuredTaskScope.open()) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">user</span> <span class="operator">=</span> scope.fork(() -&gt; findUser());</span><br><span class="line">            <span class="type">var</span> <span class="variable">order</span> <span class="operator">=</span> scope.fork(() -&gt; fetchOrder());</span><br><span class="line">            scope.join();        <span class="comment">// 等待所有子任务，若有失败，会触发短路与取消</span></span><br><span class="line">            scope.throwIfFailed(); <span class="comment">// 将第一个失败的异常抛出（可选）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(user.resultNow(), order.resultNow());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(handle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong>  <br />
鼓励把&quot;请求处理/事务性工作&quot;建模为一个作用域，嫁接到微服务请求处理流程（例如：并行调用多个后端、并行校验、并行缓存填充）。这将显著减少 try/finally 风格的取消/清理样板。</p>
</li>
<li>
<p><strong>集成与迁移：</strong>  <br />
在服务端处理路径引入结构化并发的试点（例如：并行调用几个独立 I/O 服务）；把超时/取消策略集中化；在 APM/日志中记录 scope id 以便于 JFR 等工具可视化任务树。由于为 preview，先在非关键路径或 feature-flag 下试验。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>与虚拟线程结合时非常高效；但对传统线程池/同步密集型任务并不总是最佳。作用域在 <code>join()</code> 时会等待所有子任务的完成或触发取消，需注意对延迟敏感路径的超时策略（可在 scope 层面施加 deadline）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四-可观察性增强jfr-的全面进化"><a class="markdownIt-Anchor" href="#四-可观察性增强jfr-的全面进化"></a> 四、可观察性增强：JFR 的全面进化</h1>
<p>JDK 25 在 Java Flight Recorder (JFR) 方面带来了重大改进，包括更安全的采样机制、CPU 时间精确分析和方法级别的精确计时。这些改进使得生产环境的性能监控和问题诊断更加精确和稳定。</p>
<h2 id="深入解读jfr-cooperative-sampling-jep-518-与-cpu-time-profiling-jep-509-experimental"><a class="markdownIt-Anchor" href="#深入解读jfr-cooperative-sampling-jep-518-与-cpu-time-profiling-jep-509-experimental"></a> 深入解读：JFR Cooperative Sampling (JEP 518) 与 CPU-Time Profiling (JEP 509, Experimental)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
现有 JFR 的样本采集存在：采用异步 stack-walking heuristics 有安全/稳定问题，并且 JFR 的执行时间采样（ExecutionSample）无法准确反映<strong>CPU 时间</strong>（尤其当很多工作在 native code 中完成时）。这导致在短时间窗口或 native-heavy代码中，分析结果不精确或不安全。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong></p>
<ul>
<li>
<p><strong>JEP 518 (Cooperative Sampling)</strong>：重构 JFR 的方法采样机制，使得线程栈在 safepoints（安全点）进行 walking，从而避免不安全/ heuristics 的 stack parsing 并提高稳定性，为更高级采样功能打基础。</p>
</li>
<li>
<p><strong>JEP 509 (JFR CPU-Time Profiling, Experimental)</strong>：利用 Linux 内核的 CPU-timer（基于 CPU 时间而非wall-time触发）来收集 <code>jdk.CPUTimeSample</code> 事件，能正确归因在 native-code 中消耗的 CPU 时间（例如 JNI 调用、FFI 调用等）。该特性目前为 experimental，仅支持 Linux（内核支持）并通过新的 <code>jdk.CPUTimeSample</code> / <code>jdk.CPUTimeSamplesLost</code> 事件暴露。</p>
</li>
</ul>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用 CPU 时间采样</span></span><br><span class="line">java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=<span class="literal">true</span>,filename=profile.jfr -jar myapp.jar</span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">jfr view cpu-time-hot-methods profile.jfr</span><br><span class="line"><span class="comment"># 检查样本丢失情况</span></span><br><span class="line">jfr view Events --categories <span class="string">&#x27;Java Virtual Machine&#x27;</span> profile.jfr | grep CPUTimeSamplesLost</span><br></pre></td></tr></table></figure>
<p>JEP 509 依赖 JEP 518 的 cooperative sampling 机制来保证栈采样稳定与准确。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong>  <br />
        需要细粒度 CPU 归因（例如：CPU-bound 服务、混合 Java+native 性能瓶颈定位、持续性能回归检测）的团队将立刻受益。尤其在容器化/云环境下要找出真正的 CPU hotspot（非 IO 等）时，CPU-time profiler 更准确。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong>  <br />
启用较高采样率会增加监控开销（JEP 指出默认 throttle 及 profile.jfc 中的配置）。CPU-time profiling 目前为 Linux 专用并标注为 experimental：生产使用需先评估开销与稳定性。</p>
</li>
<li>
<p><strong>调优策略：</strong></p>
<ul>
<li>在测试环境做代表性负载的采样，验证 <code>jdk.CPUTimeSample</code> 输出与现有工具（async-profiler）的一致性。</li>
<li>对生产上的持续采样保持 conservative throttle（例如 500/s 或 10ms），并结合 <code>jdk.CPUTimeSamplesLost</code> 事件检查样本丢失。</li>
<li>将 JFR 录制文件与 FlameGraph 工具链配合使用，侧重短轮廓（minutes）分析与长期监控（low sampling）策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读jfr-method-timing-tracing-jep-520"><a class="markdownIt-Anchor" href="#深入解读jfr-method-timing-tracing-jep-520"></a> 深入解读：JFR Method Timing &amp; Tracing (JEP 520)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
    采样型分析难以统计每个方法的精确调用次数与精确耗时；要么要在源代码中插入计时逻辑（不方便且污染业务代码），要么使用外部代理。JEP 520 将「方法级别的计时与可选追踪（trace）」放到 JFR 内部，由 JVM 通过字节码插桩在运行时注入事件，允许按过滤器进行精确计时或记录栈信息。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
    引入 <code>jdk.MethodTiming</code>（聚合统计：调用次数/平均/最小/最大）和 <code>jdk.MethodTrace</code>（每次调用的事件记录，带可选栈跟踪）。支持通过命令行配置、JFR 配置文件、<code>jcmd</code>、JMX 或 <code>RemoteRecordingStream</code> 远程控制。过滤器语法类似方法引用（<code>com.foo.Bar::baz</code>）或注解过滤（<code>@jakarta.ws.rs.GET</code>）。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监控静态初始化器</span></span><br><span class="line">java -XX:StartFlightRecording:method-timing=::&lt;clinit&gt;,filename=clinit.jfr -jar app.jar</span><br><span class="line">jfr view method-timing clinit.jfr</span><br><span class="line"><span class="comment"># 监控特定类的所有方法</span></span><br><span class="line">java -XX:StartFlightRecording:method-timing=com.example.CriticalService::*,filename=service.jfr -jar app.jar</span><br><span class="line"><span class="comment"># 通过 jcmd 动态启用（运行时控制）</span></span><br><span class="line">jcmd &lt;pid&gt; JFR.configure method-timing=<span class="string">&quot;com.example.OrderProcessor::processOrder&quot;</span></span><br></pre></td></tr></table></figure>
<p>JFR 会在运行时注入/移除字节码 instrumentation（可远程控制）。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
启动延迟分析（static initializer）、第三方库耗时度量、生产中针对少量关键方法的低开销精确统计。不同于采样器，这能统计每次方法的调用次数与准确时间（若你只需要热点的近似排名仍用 sampling）。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong>  <br />
方法逐个注入事件会带来明显开销，JEP 明确不建议对大量方法同时启用。最佳做法是<strong>精确过滤</strong>（类/方法/注解），并在必要时只启用短时间的录制或在测试环境使用。</p>
</li>
<li>
<p><strong>调优策略：</strong>  <br />
在 CI 或 Canary 环境里使用 <code>MethodTiming</code> 做回归检查（例如关键路径的平均耗时是否在阈值之内）；把过滤规则以配置文件形式存入版本库（便于复现）；远程配置能力允许在生产短暂开启但需设定安全/访问控制。</p>
</li>
</ul>
</li>
</ul>
<h1 id="五-平台支持与兼容性战略性调整"><a class="markdownIt-Anchor" href="#五-平台支持与兼容性战略性调整"></a> 五、平台支持与兼容性：战略性调整</h1>
<p>这一章节涵盖平台支持层面的重要变化，虽然看似不直接影响功能开发，但对架构决策和长期维护有重要意义。</p>
<h2 id="深入解读remove-the-32-bit-x86-port-jep-503-delivered"><a class="markdownIt-Anchor" href="#深入解读remove-the-32-bit-x86-port-jep-503-delivered"></a> 深入解读：Remove the 32-bit x86 Port (JEP 503, Delivered)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
维护 32-bit x86（Linux/Windows）平台的源代码路径与测试开销越来越大，且阻碍某些新特性的实现（如 Loom、Vector API 的某些优化）。JEP 503 的目标是从 JDK 主线中移除 32-bit x86 的源码与构建支持，以简化开发与加速新功能交付。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
JEP 503 删除源码和构建支持，清理 HotSpot 中针对 32-bit 的特殊分支和补丁，更新构建系统与文档以不再包含该构建目标。目标注意点是保持对其他 32-bit 架构（例如某些嵌入式平台）不受影响。</p>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>架构/运维影响：</strong><br />
如果组织仍在运行 32-bit x86 的生产/边缘实例（极少见，但存在于遗留工业控制或老旧嵌入式系统），将无法使用 JDK 25+ 的二进制分发。多数云/现代服务器均为 64-bit，影响有限。</p>
</li>
<li>
<p><strong>迁移与兼容性：</strong><br />
对仍在 32-bit 上的系统，要么维持在旧 JDK（例如长期支持的旧版本），要么计划尽快升级操作系统和硬件。构建管线中若有混合平台（CI runner 包含 32-bit），要移除相关构建目标。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
审核现有部署环境，确认无 32-bit x86 依赖；更新 CI/CD 构建矩阵；制定遗留系统的升级时间表或维护策略；在迁移到 JDK 25+ 前评估硬件升级成本与业务价值。</p>
</li>
</ul>
</li>
</ul>
<h1 id="总结与展望面向未来的-java-平台"><a class="markdownIt-Anchor" href="#总结与展望面向未来的-java-平台"></a> 总结与展望：面向未来的 Java 平台</h1>
<p>JDK 25 并不只是又一个半年版本，它是最新 LTS，也是一个“收割与固化”的版本：那些在 JDK 24 实验/预览中的不错特性在 25 中成熟或成为正式产品／预览；同时语言向减少样板与提高表达力靠拢，并发与 GC 模型在性能 &amp;资源利用上有实质性优化；安全与可观察性也进步显著。对资深工程师而言，这意味着现有架构中在启动、内存占用、并发状态管理、安全协议实现上的旧权衡正变得松动：可以选择更轻量、更统一且更可预测的方案。</p>
<h2 id="未来预测与讨论"><a class="markdownIt-Anchor" href="#未来预测与讨论"></a> 未来预测与讨论</h2>
<ol>
<li><strong>Project Valhalla 的继续推进</strong> —— primitive patterns 与 Vector API 的演进，以及 Stable Values 与 scoped values，预示着 value types /泛型 over primitives /更高性能的低级数据结构将是未来几年 Java 的核心方向。</li>
<li><strong>AOT + 映像 +预热优化成为主流运维策略</strong>，尤其在云原生 /serverless /边缘环境中。团队将需要把“预热 /训练 /缓存 /版本管理”流程纳入标准部署管线。</li>
<li><strong>并发 /状态共享模型规范化</strong> 会推动更多设计范式变化：向 structured concurrency + scoped / stable value 的结合，看起来将成为现代框架（web 框架 /微服务 /消息处理）的标准组件。</li>
<li><strong>安全与库标准化</strong>：随着 KDF API + PEM 支持等进入平台标准库，外部库依赖将减少，安全审计与跨库兼容性问题将减少；但也意味着平台 API 的行为规范和文档质量比以往更关键。</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Gerrit1999
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/" title="JDK 25 新特性深度解析与代码示例">https://gerrit1999.github.io/2025/jdk-25-新特性深度解析与代码示例/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/JDK25/" rel="tag"><i class="fa fa-tag"></i> JDK25</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/minio-%E9%A2%84%E7%AD%BE%E5%90%8D-url-%E6%8A%A5%E9%94%99-signaturedoesnotmatch-%E7%9A%84%E6%8E%92%E6%9F%A5%E5%A4%8D%E7%9B%98/" rel="prev" title="MinIO 预签名 URL 报错 SignatureDoesNotMatch 的排查复盘">
                  <i class="fa fa-angle-left"></i> MinIO 预签名 URL 报错 SignatureDoesNotMatch 的排查复盘
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/redis-lua-%E8%84%9A%E6%9C%AC%E5%BC%82%E5%B8%B8%EF%BC%9A%E2%80%9Cnoscript-no-matching-script%E2%80%9D-%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E5%A4%8D/" rel="next" title="Redis Lua 脚本异常：“NOSCRIPT No matching script” 故障分析与修复">
                  Redis Lua 脚本异常：“NOSCRIPT No matching script” 故障分析与修复 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Gerrit1999</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <style>
  .moe_icp a {
    all: unset; /* 重置所有默认样式 */
    text-decoration: none;
  }

  .moe_icp a:hover {
    filter: brightness(1.2);
  }
</style>

<div class="moe_icp" style="display: flex; justify-content: center; align-items: center; gap: 10px;">
  <a href="https://icp.gov.moe/?keyword=20248869" target="_blank">
    <img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%8720248869%E5%8F%B7-e22b84" alt="萌ICP备20248869号">
  </a>

  <a style="color:#e77c8e; display: inline-flex; align-items: center;" 
     href="https://travel.moe/go.html" 
     title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！" 
     target="_blank">
    <img src="https://travel.moe/images/icon/icon64pink.png" style="width:24px;height:24px; margin-right: 4px;">
    异次元之旅
  </a>
</div>

  <div id="site-runtime">
  <span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
  </span>
  <span id="runtime"></span>
</div>

<script language="javascript">
  function isPC() {
    var userAgentInfo = navigator.userAgent;
    var agents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (var i = 0; i < agents.length; i++) {
      if (userAgentInfo.indexOf(agents[i]) > 0) {
        return false;
      }
    }
    return true;
  }

  function siteTime(openOnPC, start) {
    window.setTimeout("siteTime(openOnPC, start)", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
      start = new Date("2024-11-18 09:00:00 +0800");
    var now = new Date();
    var year = now.getFullYear();
    var month = now.getMonth() + 1;
    var date = now.getDate();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
    var diff = now - start;

    var diffYears = Math.floor(diff / years);
    var diffDays = Math.floor((diff / days) - diffYears * 365);
    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);

    if (openOnPC) {
      document.getElementById("runtime").innerHTML = "本站已运行: " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分 " + diffSeconds + " 秒";
    } else {
      document.getElementById("runtime").innerHTML = "本站已运行: " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分 " + diffSeconds + "秒";
    }
  }

  var showOnMobile = true;
  var openOnPC = isPC();
  var start = new Date();
  siteTime(openOnPC, start);

  if (!openOnPC && !showOnMobile) {
    document.getElementById('site-runtime').style.display = 'none';
  }
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlcnJpdDE5OTk=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="/js/clicklove.js"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://gerrit1999.github.io/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline.gerrit2025.xyz","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/waline/2.15.8/waline.js","dark":"body.darkmode--activated","el":"#waline","comment":true,"path":"/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://cdn.staticfile.org/Darkmode.js/1.5.7/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
