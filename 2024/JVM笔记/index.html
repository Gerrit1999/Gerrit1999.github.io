<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pace/1.2.4/themes/blue/pace-theme-flash.css">
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"gerrit1999.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.21.1","exturl":true,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":"mac","show_result":true},"fold":{"enable":true,"height":300},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这篇文章介绍了JVM的架构、类加载、运行时数据区、垃圾回收机制及其相关算法和概念，涵盖了JVM的各个方面。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 笔记">
<meta property="og:url" content="https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="星轨时光机">
<meta property="og:description" content="这篇文章介绍了JVM的架构、类加载、运行时数据区、垃圾回收机制及其相关算法和概念，涵盖了JVM的各个方面。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301594b5b782545715a.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/JVM-240301cdc7c5feae0bf7a7.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/JVM-2-240301245de16c7f4cea78.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/PC-2403012479a887ab9c9e6e.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/Visual_GC-240301c4ec1bb1944d5b97.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/Minor-GC1-240301539459107f91fa1f.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/Minor-GC2-2403014b8cecb8c17dbb91.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/Minor-GC3-24030130268c288ab6d016.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403015e3e922afdeb44d7.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/TLAB-24030104a6334a50759597.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301ac4cf47384d7a2c3.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301a32e0ccf462adb3a.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301e9c4a2165f489612.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-24030155755c1800bb4ec0.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301308aaa7ea4814fd3.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403015da642e992d0b2fb.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301eab8558f1de88aca.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/JVM-24030141a7fd39b3fe63b6.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/class-2403014dfd28a2382f258d.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403014cf6511a1dd334fd.gif">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/staticObj-24030138613beab926ed6c.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/JVM-2403012360f44f709ef021.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403017c2f6cf428469f43.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403019d666a1114f82943.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403018f1173d87a7c56cd.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301d2704155bd449f06.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-24030163501f61b4addc0c.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301373543359a9945f1.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2403015e6247d506b2fe8e.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-240301052ee57f9be95572.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-1-2403013b064f6c436f0072.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--2403018ab9eb91fcdb4237.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--2403010fc6fd3a1be18e90.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-Java-2403011a5ebcf8d4544d06.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-Java-2403016bf66852ca819c92.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2-2403010beefd56c75d6f7c.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--240301f67b1854906ee9a5.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--240301638e9dd044ec299f.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-1-240301c3378f8f41e1978b.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-2-24030182cc8d2063732221.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-3-240301be03c9a8ed7bd239.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-4-240301ec35ae503cddb503.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-5-2403016ef5ab0a9f006641.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/StringTable-StringTable-240301eb4c852331a3e830.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-1-240301ac54b076a6ad0594.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-GC-240301c032c54b76675b43.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--24030128740784a89f4b6e.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2-240301e3f30ff5192ca9e6.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--240301e0d32be041e67917.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-3-24030164ed2335f156dc4c.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-jmap-2403013709399f3fae8ec4.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-4-240301744f286f6255b604.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-5-2403013919c3aacd5efb86.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-6-2403013869e935a9a4f3db.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-7-240301436c5959dafe79df.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-8-2403011badc5e7b90e76a5.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-9-240301064a35724942d310.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-10-2403019249f018346ca410.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-11-240301fb33fb3b9eca609f.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-12-240301544cc76c448366ab.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-13-240301bb3131d5bfa9ac90.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-14-240301e9da4fb49e94651d.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-15-240301ee2cd69eb4bd6c54.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/---24030175e497cbf0609d3f.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--240301f5469e2b20023571.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-16-2403014ac3d186f1564cb8.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/---240301908b695495c8baa1.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--24030103f7f06532fbe875.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-17-24030101d31e50e6761db7.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-18-2403016890fef7da6de304.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-19-24030182599a2921b13d29.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--2403012fb2e63f510090e7.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--24030180b40edfe5511b5b.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--240301bfb6932cd7d29fbc.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-20-2403011f422600aef81d1a.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/23/220af395fff51614a8.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-1-240301337a8c0cf7684c92.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--2403017cd3bfd9fe59577a.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/--2403010b04d784d983d834.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-2-24030114fc55bb5599096d.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-3-2403010affe0ad2519cb72.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-4-24030193ea0fb167eb35f1.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-Serial-240301df3d3618327be114.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-ParNew-2403013ad52f9cfa15b139.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-Parallel-Scavenge-24030169e84e42515958d1.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-CMS-2403013af2c01918492649.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-6-240301593f0669f0910b69.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-7-240301c632f4c6e8592878.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-8-240301cdd02a36e1b0bf92.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-region-240301b174a4c427cfe0f5.jpg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-9-24030171d8ab85e969f24e.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-10-240301996aa998a81c6702.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-11-24030145e8e40fa2eeee6a.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-12-2403016721689d39f2bf1c.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-13-240301978b96b59371bcf1.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-14-240301cdd6f227e6f12a2d.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-15-240301605cefc98cc10f0c.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-16-240301be13001555ebb8cf.jpeg">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-17-24030136ec53cf80809d13.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-18-240301bee93226f609ec1a.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-19-24030115db9abfa4850cd2.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-20-240301638d167fc2188db5.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-21-240301e2614e7cde73528d.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-Shenandoah-2403014156181d344db4af.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-ZGC1-240301adf6d068206269f3.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-ZGC2-2403013dd0918acc912d1a.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-ZGC3-2403010c250759cfcd1ce1.png">
<meta property="og:image" content="https://img.picgo.net/2025/01/20/-AliGC-240301968f08e3f45a3398.png">
<meta property="article:published_time" content="2024-08-08T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-08T16:00:00.000Z">
<meta property="article:author" content="Gerrit1999">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.picgo.net/2025/01/20/-240301594b5b782545715a.png">


<link rel="canonical" href="https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/","path":"2024/JVM笔记/","title":"JVM 笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM 笔记 | 星轨时光机</title>
  







<link rel="dns-prefetch" href="waline.gerrit2025.xyz"><link rel="stylesheet" type="text/css" href="/css/injector/main.css" /><link rel="preload" as="style" href="/css/injector/light.css" /><link rel="preload" as="style" href="/css/injector/dark.css" />
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星轨时光机</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Gerrit1999的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E5%88%9D%E8%AF%86jvm"><span class="nav-text"> 一、初识JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-jvm%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="nav-text"> 1、JVM的架构模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-jvm%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text"> 2、JVM的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-jvm%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="nav-text"> 3、JVM的发展历程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-text"> 二、类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BD%9C%E7%94%A8"><span class="nav-text"> 1、类加载器子系统作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text"> 2、类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E5%8A%A0%E8%BD%BD"><span class="nav-text"> 1）加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E9%93%BE%E6%8E%A5"><span class="nav-text"> 2）链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text"> 3）初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text"> 3、类加载器的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text"> 虚拟机自带的加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A"><span class="nav-text"> 几种类加载器的使用体会</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text"> 用户自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-text"> 4、双亲委派机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%85%B6%E4%BB%96"><span class="nav-text"> 5、其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 三、运行时数据区概述及线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text"> 1、运行时数据区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 2、线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8pc%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text"> 四、程序计数器（PC寄存器）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-text"> 1、程序计数器介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%A4%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text"> 2、两个常见面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-cpu%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-text"> 3、CPU时间片</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text"> 五、虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="nav-text"> 1、虚拟机栈的主要特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text"> 面试题：开发中遇到的异常有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D"><span class="nav-text"> 2、栈的存储单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8local-variables"><span class="nav-text"> 3、局部变量表（Local Variables）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Eslot%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text"> 关于Slot的理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88operand-stack"><span class="nav-text"> 4、操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5dynamic-linking"><span class="nav-text"> 5、动态链接（Dynamic Linking）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text"> 方法的调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80return-address"><span class="nav-text"> 6、方法返回地址（Return Address）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%80%80%E5%87%BA%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-text"> 方法退出的两种方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%B8%80%E4%BA%9B%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-text"> 7、一些附加信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text"> 8、相关面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text"> 六、本地方法栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-text"> 1、什么是本地方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-text"> 2、为什么要使用本地方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E7%9A%84%E7%8E%B0%E7%8A%B6"><span class="nav-text"> 3、本地方法的现状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text"> 4、本地方法栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-%E5%A0%86"><span class="nav-text"> 七、堆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="nav-text"> 1、堆的核心概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A0%86%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%86%E5%88%86"><span class="nav-text"> 2、堆的内存细分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-text"> 3、堆空间大小的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-text"> 4、年轻代和老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text"> 5、对象分配过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%B8%B8%E7%94%A8%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7"><span class="nav-text"> 6、常用调优工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-gc%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text"> 7、GC回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#71-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%80%9D%E6%83%B3"><span class="nav-text"> 7.1 分代收集思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-minor-gc"><span class="nav-text"> 7.2 Minor GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-major-gc"><span class="nav-text"> 7.3 Major GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-full-gc%E5%90%8E%E9%9D%A2%E7%BB%86%E8%AE%B2"><span class="nav-text"> 7.4 Full GC（后面细讲）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-gc%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-text"> 7.5 GC日志分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-text"> 8、堆空间分代思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-text"> 9、内存分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-text"> 10、为对象分配内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%A0%86%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text"> 11、堆空间参数设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-text"> 11.1 常用参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-text"> 11.2 空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="nav-text"> 12、堆是分配对象的唯一选择吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#121-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="nav-text"> 12.1 逃逸分析概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-text"> 12.2 栈上分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5"><span class="nav-text"> 12.3 同步省略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#124-%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-text"> 12.4 标量替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-text"> 12.5 逃逸分析的不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E5%B0%8F%E7%BB%93"><span class="nav-text"> 13、小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text"> 八、方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%88-%E5%A0%86-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB"><span class="nav-text"> 1、栈、堆、方法区的交互关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text"> 2、方法区的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text"> 2.1 方法区的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3"><span class="nav-text"> 2.2 方法区的基本理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text"> 2.3 方法区的演进</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%E5%8C%BA%E5%A4%A7%E5%B0%8F%E4%B8%8Eoom"><span class="nav-text"> 3、设置方法区大小与OOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-text"> 4、方法区的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%BB%93%E6%9E%84"><span class="nav-text"> 4.1 方法区结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E5%9F%9F%E4%BF%A1%E6%81%AF%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-text"> 4.2 域信息特殊情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text"> 4.3 运行时常量池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%9B%BE%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="nav-text"> 5、方法区图解示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-text"> 6、方法区的演进</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-%E6%B0%B8%E4%B9%85%E4%BB%A3%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="nav-text"> 6.1 永久代演进过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-%E5%85%83%E7%A9%BA%E9%97%B4%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="nav-text"> 6.2 元空间出现原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text"> 6.3 字符串常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BD%8D%E7%BD%AE"><span class="nav-text"> 6.4 静态变量位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-text"> 7、方法区的垃圾收集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%80%BB%E7%BB%93"><span class="nav-text"> 8、运行时数据区总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text"> 9、大厂面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-text"> 九、对象的实例化内存布局与访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text"> 1、对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text"> 1.1 对象创建的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text"> 1.2 对象创建的步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text"> 2、对象的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-text"> 3、对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-text"> 十、直接内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text"> 1、概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text"> 2、数据缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B6%E4%BB%96"><span class="nav-text"> 3、其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-text"> 十一、执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="nav-text"> 1、执行引擎概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-text"> 2、执行引擎工作过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-text"> 3、Java代码编译和执行的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%9C%BA%E5%99%A8%E7%A0%81-%E6%8C%87%E4%BB%A4-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="nav-text"> 4、机器码、指令、汇编语言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E6%9C%BA%E5%99%A8%E7%A0%81"><span class="nav-text"> 4.1 机器码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E6%8C%87%E4%BB%A4"><span class="nav-text"> 4.2 指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E8%AF%AD%E8%A8%80"><span class="nav-text"> 4.3 语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-text"> 4.4 字节码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-text"> 5、解释器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text"> 6、编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-java%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="nav-text"> 6.1 Java代码的执行分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-hotspot-jvm%E6%89%A7%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="nav-text"> 6.2 HotSpot JVM执行方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="nav-text"> 6.3 概念解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81%E5%8F%8A%E6%8E%A2%E6%B5%8B%E6%96%B9%E5%BC%8F"><span class="nav-text"> 6.4 热点代码及探测方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-jit%E5%88%86%E7%B1%BB"><span class="nav-text"> 6.5 JIT分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-aot%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-text"> 6.6 AOT编译器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-stringtable"><span class="nav-text"> 十二、StringTable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-string%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="nav-text"> 1、String的基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-string%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-text"> 2、String的底层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-string%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text"> 3、String的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-string%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-text"> 4、String拼接操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-new-string%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text"> 5、new String()的说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-intern"><span class="nav-text"> 6、intern</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-intern%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-text"> 6.1 intern()的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-intern%E7%9A%84%E6%95%88%E7%8E%87%E6%B5%8B%E8%AF%95%E7%A9%BA%E9%97%B4%E8%A7%92%E5%BA%A6"><span class="nav-text"> 6.2 intern()的效率测试（空间角度）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-stringtable%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text"> 7、StringTable的垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-g1%E4%B8%AD%E7%9A%84string%E5%8E%BB%E9%87%8D%E6%93%8D%E4%BD%9C"><span class="nav-text"> 8、G1中的String去重操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="nav-text"> 十二、垃圾回收概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text"> 1、大厂面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-text"> 2、什么是垃圾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81gc"><span class="nav-text"> 3、为什么需要GC？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text"> 4、早期垃圾回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-java%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text"> 5、Java的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text"> 5.1 自动内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-%E5%BA%94%E8%AF%A5%E5%85%B3%E5%BF%83%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-text"> 5.2 应该关心哪些区域的回收？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-text"> 十三、垃圾回收相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-text"> 1、标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-text"> 1.1 标记阶段的目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-text"> 1.2 引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-text"> 1.3 可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%AF%B9%E8%B1%A1%E7%9A%84-finalization-%E6%9C%BA%E5%88%B6"><span class="nav-text"> 1.4 对象的 finalization 机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%BD%BF%E7%94%A8mat%E6%9F%A5%E7%9C%8Bgc-roots"><span class="nav-text"> 1.5 使用MAT查看GC Roots</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E4%BD%BF%E7%94%A8jprofiler%E8%BF%9B%E8%A1%8Cgc-roots%E6%BA%AF%E6%BA%90"><span class="nav-text"> 1.6 使用JProfiler进行GC Roots溯源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E4%BD%BF%E7%94%A8jprofiler%E7%9B%91%E6%8E%A7oom"><span class="nav-text"> 1.7 使用JProfiler监控OOM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-text"> 2、清除阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%9E%83%E5%9C%BE%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-text"> 2.1 垃圾清除阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.2 标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.3 复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.4 标记-压缩（整理）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E5%B0%8F%E7%BB%93%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-text"> 2.5 小结（三种算法对比）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.6 分代收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.7 增量收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-text"> 2.8 分区算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="nav-text"> 写在最后</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-text"> 十四、垃圾回收相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-systemgc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text"> 1、System.gc() 的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%89%8B%E5%8A%A8%E6%89%A7%E8%A1%8C-gc-%E6%93%8D%E4%BD%9C"><span class="nav-text"> 1.1 代码示例：手动执行 GC 操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%89%8B%E5%8A%A8-gc-%E7%90%86%E8%A7%A3%E4%B8%8D%E5%8F%AF%E8%BE%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9E%E6%94%B6%E8%A1%8C%E4%B8%BA"><span class="nav-text"> 1.2 手动 GC 理解不可达对象的回收行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-text"> 2、内存溢出与内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BAoom"><span class="nav-text"> 2.1 内存溢出（OOM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8Fmemory-leak"><span class="nav-text"> 2.2 内存泄漏（Memory Leak）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-stop-the-world"><span class="nav-text"> 3、Stop the World</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text"> 4、 垃圾回收的并行与并发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E5%B9%B6%E5%8F%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text"> 4.1 并发的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text"> 4.2 并行的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text"> 4.3 垃圾回收的并发与并行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-text"> 5、安全点与安全区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-%E5%AE%89%E5%85%A8%E7%82%B9safe-point"><span class="nav-text"> 5.1 安全点（Safe Point）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9Fsafe-region"><span class="nav-text"> 5.2 安全区域（Safe Region）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="nav-text"> 6、再谈引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#61-%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-text"> 6.1 强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="nav-text"> 6.2 软引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="nav-text"> 6.3 弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-%E8%99%9A%E5%BC%95%E7%94%A8"><span class="nav-text"> 6.4 虚引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#65-%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-text"> 6.5 终结器引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%94-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text"> 十五、垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-gc-%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text"> 1、GC 分类与性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text"> 1.1 垃圾回收器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-text"> 1.2 垃圾回收器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E8%AF%84%E4%BC%B0-gc-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text"> 1.3 评估 GC 的性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text"> 2、不同的垃圾回收器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="nav-text"> 2.1 垃圾收集器发展史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E4%B8%83%E6%AC%BE%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text"> 2.2 七款经典的垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-text"> 2.3 如何查看默认垃圾收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-serial-%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-text"> 2.4 Serial 回收器：串行回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-parnew-%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-text"> 2.5 ParNew 回收器：并行回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-parallel-%E5%9B%9E%E6%94%B6%E5%99%A8%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-text"> 2.6 Parallel 回收器：吞吐量优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-cms-%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-text"> 2.7 CMS 回收器：低延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-g1-%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-text"> 2.8 G1 回收器：区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA-region%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="nav-text"> 分区 Region：化整为零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%80%E5%B9%B4%E8%BD%BB%E4%BB%A3-gc"><span class="nav-text"> G1回收过程一：年轻代 GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%BA%8C%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="nav-text"> G1回收过程二：并发标记过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%89%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-text"> G1回收过程三：混合回收过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#g1%E5%9B%9E%E6%94%B6%E5%8F%AF%E9%80%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%9B%9Bfull-gc"><span class="nav-text"> G1回收可选的过程四：Full GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-text"> 补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-text"> 2.9 垃圾回收器总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-gc-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-text"> 3、GC 日志分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-text"> 3.1 常用参数配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-gc-%E6%97%A5%E5%BF%97%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="nav-text"> 3.2 GC 日志补充说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-gc-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-text"> 3.3 GC 日志分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-text"> 3.4 常用日志分析工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95"><span class="nav-text"> 4、垃圾回收器的新发展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-open-jdk12%E7%9A%84shenandoash-gc%E4%BD%8E%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E7%9A%84gc%E5%AE%9E%E9%AA%8C%E6%80%A7"><span class="nav-text"> 4.1 Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E4%BB%A4%E4%BA%BA%E9%9C%87%E6%83%8A-%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84-zgcjdk14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text"> 4.2 令人震惊、革命性的 ZGC（JDK14 新特性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E5%85%B6%E4%BB%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8aligc"><span class="nav-text"> 4.3 其他垃圾回收器：AliGC</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gerrit1999"
      src="https://avatars.githubusercontent.com/u/71630591">
  <p class="site-author-name" itemprop="name">Gerrit1999</p>
  <div class="site-description" itemprop="description">今人不见古时月，今月曾经照古人</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlcnJpdDE5OTk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gerrit1999"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmdlcnJpdDE5OTlAcXEuY29t" title="E-Mail → mailto:gerrit1999@qq.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnpoaGVvLmNvbS8=" title="https:&#x2F;&#x2F;blog.zhheo.com&#x2F;">张洪Heo - 分享设计与科技生活</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly95dXJpay5jYWZlLw==" title="https:&#x2F;&#x2F;yurik.cafe&#x2F;">景蓝的小屋</span>
            </li>
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV1YW5xaW4udG9wLw==" title="https:&#x2F;&#x2F;blog.uuanqin.top&#x2F;">半方池水半方田 - Qin's blog</span>
            </li>
        </ul>
      </div>
    </div>
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/71630591">
      <meta itemprop="name" content="Gerrit1999">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星轨时光机">
      <meta itemprop="description" content="今人不见古时月，今月曾经照古人">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM 笔记 | 星轨时光机">
      <meta itemprop="description" content="这篇文章介绍了JVM的架构、类加载、运行时数据区、垃圾回收机制及其相关算法和概念，涵盖了JVM的各个方面。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM 笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-09T00:00:00+08:00">2024-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/JVM%E7%AC%94%E8%AE%B0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/JVM%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>77k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4:15</span>
    </span>
</div>

            <div class="post-description">这篇文章介绍了JVM的架构、类加载、运行时数据区、垃圾回收机制及其相关算法和概念，涵盖了JVM的各个方面。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一-初识jvm"><a class="markdownIt-Anchor" href="#一-初识jvm"></a> 一、初识JVM</h1>
<h2 id="1-jvm的架构模型"><a class="markdownIt-Anchor" href="#1-jvm的架构模型"></a> 1、JVM的架构模型</h2>
<p><font color='red'>Java编译器输入的指令流基本上是一种基于栈的指令集架构。</font></p>
<p>基于栈式架构的特点：</p>
<ol>
<li>
<p>设计和实现更简单，适用于资源受限的系统；</p>
</li>
<li>
<p>避开了寄存器的分配难题：使用零地址指令方式分配；</p>
</li>
<li>
<p>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器更容易实现；</p>
</li>
<li>
<p>不需要硬件支持，可移植性更好，更好实现跨平台。</p>
</li>
</ol>
<p>总结：由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="2-jvm的生命周期"><a class="markdownIt-Anchor" href="#2-jvm的生命周期"></a> 2、JVM的生命周期</h2>
<ol>
<li>
<p>虚拟机的启动</p>
<p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建的一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
</li>
<li>
<p>虚拟机的执行</p>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行它才运行，程序结束时它就停止。</li>
<li>执行一个所谓Java程序的时候，真真正正执行的是一个叫做Java虚拟机的进程。</li>
</ul>
</li>
<li>
<p>虚拟机的退出</p>
<p>有以下几种情况：</p>
<ul>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到异常或错误而异常终止。</li>
<li>由于操作系统出现错误导致Java虚拟机进程终止。</li>
<li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
</li>
</ol>
<h2 id="3-jvm的发展历程"><a class="markdownIt-Anchor" href="#3-jvm的发展历程"></a> 3、JVM的发展历程</h2>
<ol>
<li>
<p>Sun Classic VM</p>
<p>是世界第一款商用Java虚拟机。JDK1.4时被完全淘汰。这款虚拟机内部只提供解释器，效率较低。现在HotSpot内置了此虚拟机。</p>
</li>
<li>
<p>Exact VM</p>
<ul>
<li>
<p>JDK1.2时，sun提供了此虚拟机。</p>
</li>
<li>
<p>Exact Memory Management：准确式内存管理</p>
<p>虚拟机可以知道内存中的某个位置的数据具体是什么类型。</p>
</li>
<li>
<p>具备现代高性能虚拟机的雏形</p>
<ul>
<li>热点探测</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>
<p>只在Solaris平台短暂使用，其他平台还是Classic VM。</p>
</li>
</ul>
</li>
<li>
<p>HotSpot VM</p>
<p>JDK1.3时，HotSpot VM成为默认虚拟机。</p>
<ul>
<li>
<p>目前HotSpot占有绝对的市场定位。</p>
<p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot。</p>
</li>
<li>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
</li>
<li>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值的代码，触发即时编译或栈上替换。</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JRockit</p>
<ul>
<li>专注于服务端应用
<ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即使编译器编译后执行。</li>
</ul>
</li>
<li>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</li>
<li>优势：全面的Java运行时解决方案组合
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要。</li>
<li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>J9</p>
<ul>
<li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途JVM。</li>
<li>广泛用于IBM的各种Java产品。</li>
<li>目前，有影响力的三大商用虚拟机之一，已号称是世界上最快的Java虚拟机。</li>
</ul>
</li>
<li>
<p>KVM和CDC/CLDC HotSpot</p>
<ul>
<li>目前移动领域地位尴尬，智能手机被Android和IOS二分天下。</li>
<li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Azul VM</p>
<ul>
<li>这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机。</li>
<li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li>
</ul>
</li>
<li>
<p>Liquid VM</p>
<ul>
<li>Liquid VM即是现在的JRockit VE （Virtual Edition） ，Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li>
</ul>
</li>
<li>
<p>Apache Harmony</p>
<ul>
<li>Apache也曾经推出过与JDK 1.5和JDK 1.6兼容的Java运行平台Apache Harmony。</li>
<li>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压制，sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK。</li>
<li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li>
</ul>
</li>
<li>
<p>Microsoft JVM</p>
<ul>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li>
<li>只能在window平台下运行。但确是当时windows下性能最好的Java VM。</li>
<li>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windows XP SP3中抹掉了其VM。现在windows上安装的JDK都是HotSpot。</li>
</ul>
</li>
<li>
<p>Taobao JVM</p>
<ul>
<li>
<p>由Ali JVM 团队发布，基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。|</p>
</li>
<li>
<p>基于OpenJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>
<p>创新的GCIH (GC invisible heap ）技术实现了off-heap ，即将生命周期。较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</li>
<li>
<p>GCIH 中的对象还能够在多个Java虚拟机进程中实现共享。</p>
</li>
<li>
<p>使用crc32指令实现JVM intrinsic，降低JNI 的调用开销。</p>
</li>
<li>
<p>PMU hardware 的Java profiling tool 和诊断协助功能。</p>
</li>
<li>
<p>针对大数据场景的ZenGC。</p>
</li>
</ul>
</li>
<li>
<p>Taobao VM应用在阿里产品上性能高，硬件严重依赖intel的CPU，损失了兼容性，但提高了性能。</p>
<ul>
<li>目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dalvik VM</p>
<ul>
<li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li>
<li><font color='red'> Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”</font>，它没有遵循Java虚拟机规范。</li>
<li>不能直接执行Java 的 class 文件基于寄存器架构，不是JVM的栈架构。</li>
<li>执行的是编译以后的dex (Dalvik Executable）文件。执行效率比较高。</li>
</ul>
</li>
<li>
<p>Graal VM</p>
<ul>
<li>Graal VM在HotSpot VM的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。</li>
<li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件。</li>
<li>如果说HotSpot有一天真的被取代，Graal VM希望最大。但是Java的软件生态没有丝毫变化。</li>
</ul>
</li>
</ol>
<h1 id="二-类加载子系统"><a class="markdownIt-Anchor" href="#二-类加载子系统"></a> 二、类加载子系统</h1>
<h2 id="1-类加载器子系统作用"><a class="markdownIt-Anchor" href="#1-类加载器子系统作用"></a> 1、类加载器子系统作用</h2>
<ul>
<li>类加载器子系统负责从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</li>
</ul>
<h2 id="2-类的加载过程"><a class="markdownIt-Anchor" href="#2-类的加载过程"></a> 2、类的加载过程</h2>
<h3 id="1加载"><a class="markdownIt-Anchor" href="#1加载"></a> 1）加载</h3>
<ol>
<li>通过一个类的全限定类名获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li><font color="red">在内存中生成一个代表这个类的java.lang.Class对象</font>，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="2链接"><a class="markdownIt-Anchor" href="#2链接"></a> 2）链接</h3>
<ol>
<li>
<p>验证（Verify）</p>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身的安全。</li>
<li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</li>
</ul>
</li>
<li>
<p>准备（Prepare）</p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li><font color="red">这里不包含用final修饰的static类变量，因为final在编译的时候已经分配了，准备阶段会显示初始化</font>。</li>
<li><font color="red">这里不会为实例变量分配初始化</font>，类变量会分配到方法区中，而实例类变量会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li>
<p>解析（Resolve）</p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再进行。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li>
</ul>
</li>
</ol>
<h3 id="3初始化"><a class="markdownIt-Anchor" href="#3初始化"></a> 3）初始化</h3>
<ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;</code>()的过程。</li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在原文件中出现的顺序执行。</li>
<li><code>&lt;clinit&gt;</code>()不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;</code>()）。</li>
<li>若该类有父类，JVM会保证在子类的<code>&lt;clinit&gt;</code>()执行前，父类的<code>&lt;clinit&gt;</code>()已经执行完毕。</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;</code>()方法在多线程下被同步加锁。</li>
</ul>
<h2 id="3-类加载器的分类"><a class="markdownIt-Anchor" href="#3-类加载器的分类"></a> 3、类加载器的分类</h2>
<ul>
<li>JVM支持两种类型的类加载器，分别是引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li>
<li>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li>
<li>无论类加载器的类型如何区分，在程序中我们最常见的类加载器始终只有三个，如下所示：</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-240301594b5b782545715a.png" alt="常见的类加载器-240301" /></p>
<hr />
<h3 id="虚拟机自带的加载器"><a class="markdownIt-Anchor" href="#虚拟机自带的加载器"></a> 虚拟机自带的加载器</h3>
<ul>
<li>
<p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p>
<ul>
<li>这个类加载器是使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar或<code>sun.boot.class.path</code>路径下的内容），用于提供JVM自身需要的类。</li>
<li>并不继承java.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用类加载器，并指定它们的父类加载器。</li>
<li>处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun开头的类。</li>
</ul>
</li>
<li>
<p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li>派生于ClassLoader类。</li>
<li>父类加载器为启动类加载器。</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录加载类库，或从JDK安装目录JAVA_HOME/jre/lib/ext子目录（扩展目录）下加载类库。<font color="red">如果用户创建的jar包放在此目录下，也会自动由扩展类加载器加载。</font></li>
</ul>
</li>
<li>
<p>应用类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>Java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现。</li>
<li>派生于ClassLoader类。</li>
<li>父类加载器为扩展类加载器。</li>
<li>它负责加载环境变量classpath或环境属性<code>java.class.path</code>指定路径下的类库。</li>
<li><font color="red">该类加载器是程序中默认的类加载器。</font>一般来说，Java应用的类都是由它来完成加载。</li>
<li>通过<code>ClassLoader.getSystemClassLoader()</code>方法可以获取该类加载器。</li>
</ul>
</li>
</ul>
<h3 id="几种类加载器的使用体会"><a class="markdownIt-Anchor" href="#几种类加载器的使用体会"></a> 几种类加载器的使用体会</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;systemClassLoader = &quot;</span> + systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层： 扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;extClassLoader = &quot;</span> + extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrapClassLoader = &quot;</span> + bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户自定义类的类加载：使用系统类加载器来加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String是使用引导类加载器加载的（Java的核心类库都是如此）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">stringClassLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;stringClassLoader = &quot;</span> + stringClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemClassLoader = sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">extClassLoader = sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">bootstrapClassLoader = null</span><br><span class="line">classLoader = sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">stringClassLoader = null</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====BootstrapClassLoader=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的Api路径</span></span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">            System.out.println(urL.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上面位置中随意选择一个类，看看它的类加载器是什么：引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====ExtClassLoader=====&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">exitDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : exitDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上面位置中随意选择一个类，看看它的类加载器是什么：扩展类加载器</span></span><br><span class="line">        classLoader = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">=====BootstrapClassLoader=====</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/resources.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/rt.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jsse.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jce.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/charsets.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jfr.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/classes</span><br><span class="line">classLoader = null</span><br><span class="line">=====ExtClassLoader=====</span><br><span class="line">D:\java\jdk1.8.0_261\jre\lib\ext</span><br><span class="line">C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">classLoader = sun.misc.Launcher$ExtClassLoader@30f39991</span><br></pre></td></tr></table></figure>
<h3 id="用户自定义类加载器"><a class="markdownIt-Anchor" href="#用户自定义类加载器"></a> 用户自定义类加载器</h3>
<ul>
<li>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li>
<p>为什么要自定义类加载器</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
</li>
<li>
<p>用户自定义类加载器实现步骤：</p>
<ol>
<li>
<p>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求。</p>
</li>
<li>
<p>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类。但是在JDK1.2之后已不建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中。</p>
</li>
<li>
<p>在编写自定义类加载器时，如果没有太过复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，是自定义类加载器编写更加简洁。</p>
</li>
</ol>
</li>
</ul>
<h2 id="4-双亲委派机制"><a class="markdownIt-Anchor" href="#4-双亲委派机制"></a> 4、双亲委派机制</h2>
<p>Java虚拟机对class文件采用的是<font color="red">按需加载</font>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<font color="red">双亲委派</font>模式，即把请求交由父类处理。它是一种任务委派模式。</p>
<ul>
<li>
<p>工作原理</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己去加载，而是把这个请求委托给父类加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
</li>
<li>
<p>优势</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
</li>
</ul>
<h2 id="5-其他"><a class="markdownIt-Anchor" href="#5-其他"></a> 5、其他</h2>
<p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名一致，包括包名。</li>
<li>加载这两个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>
</ul>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源于同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个对象也是不相等的。</p>
<hr />
<p>对类加载器的引用</p>
<ul>
<li>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器所加载的，那么JVM<font color="red">会将这个类加载器的引用作为类型信息的一部分保存在方法区中。</font>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li>
</ul>
<hr />
<p>类的主动使用和被动使用</p>
<ul>
<li>主动使用，又分为七种情况：
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：<code>Class.forName()</code>）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供的动态语言支持：
<ul>
<li><code>java.lang.invoke.MethodHandle</code>实例的解析结果</li>
<li><code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看作是<font color="red">对类的被动引用，都不会导致类的初始化。</font></li>
</ul>
</li>
</ul>
<h1 id="三-运行时数据区概述及线程"><a class="markdownIt-Anchor" href="#三-运行时数据区概述及线程"></a> 三、运行时数据区概述及线程</h1>
<h2 id="1-运行时数据区"><a class="markdownIt-Anchor" href="#1-运行时数据区"></a> 1、运行时数据区</h2>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<font color="red">不同的JVM对于内存的划分方式和管理机制存在着部分差异。</font>结合JVM虚拟机规范，来探讨一下经典的VM内存布局。</p>
<blockquote>
<p>下图来自阿里巴巴手册JDK8</p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/JVM-240301cdc7c5feae0bf7a7.jpeg" alt="JVM运行时数据区划分-240301" /></p>
<hr />
<p><img src="https://img.picgo.net/2025/01/20/JVM-2-240301245de16c7f4cea78.png" alt="JVM运行时数据区划分 (2)-240301" /></p>
<p>Java虚拟机定义了若千种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li>灰色的为单独线程私有的，红色的为多个线程共享的。即：
<ul>
<li>每个线程：独立包括程序计数器、虚拟机栈、本地方法栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
</li>
</ul>
<h2 id="2-线程"><a class="markdownIt-Anchor" href="#2-线程"></a> 2、线程</h2>
<ul>
<li>
<p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行执行。</p>
</li>
<li>
<p>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也会同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
</li>
<li>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的<code>run()</code>方法。</p>
</li>
</ul>
<h1 id="四-程序计数器pc寄存器"><a class="markdownIt-Anchor" href="#四-程序计数器pc寄存器"></a> 四、程序计数器（PC寄存器）</h1>
<h2 id="1-程序计数器介绍"><a class="markdownIt-Anchor" href="#1-程序计数器介绍"></a> 1、程序计数器介绍</h2>
<p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p>
<p>这里并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也成为程序钩子），并且也不容易引起一些不必要的误会。<font color='red'>JVM中的PC寄存器是对物理寄存器的一种抽象模拟。</font></p>
<p>作用：</p>
<p>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<hr />
<ul>
<li>
<p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p>
</li>
<li>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
</li>
<li>
<p>任何时间一个线程都只只一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。</p>
</li>
<li>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</li>
<li>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
</li>
<li>
<p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</li>
</ul>
<hr />
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>javap - v</code> 查看字节码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Classfile /F:/IdeaProjects/JVMDemo/target/classes/com/example/java/PCRegisterTest.class</span><br><span class="line">  Last modified 2021年9月13日; size 673 bytes</span><br><span class="line">  SHA-256 checksum 5e7afa6c22e208e5060ed0ea958666594fe013313113a3c4314f3d6fb6ca8b88</span><br><span class="line">  Compiled from &quot;PCRegisterTest.java&quot;</span><br><span class="line">public class com.example.java.PCRegisterTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #5                          // com/example/java/PCRegisterTest</span><br><span class="line">  super_class: #6                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // str</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/example/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/example/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               str</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/example/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.example.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=5, args_size=1</span><br><span class="line">         0: iconst_1</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iconst_2</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iload_1</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iadd</span><br><span class="line">         7: istore_3</span><br><span class="line">         8: ldc           #2                  // String str</span><br><span class="line">        10: astore        4</span><br><span class="line">        12: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        15: iload_1</span><br><span class="line">        16: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        19: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        22: iload_3</span><br><span class="line">        23: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        26: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 2</span><br><span class="line">        line 14: 4</span><br><span class="line">        line 16: 8</span><br><span class="line">        line 17: 12</span><br><span class="line">        line 18: 19</span><br><span class="line">        line 19: 26</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      27     0  args   [Ljava/lang/String;</span><br><span class="line">            2      25     1     i   I</span><br><span class="line">            4      23     2     j   I</span><br><span class="line">            8      19     3     k   I</span><br><span class="line">           12      15     4     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;PCRegisterTest.java&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>左边的数字代表指令地址（指令偏移），即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/PC-2403012479a887ab9c9e6e.jpg" alt="PC寄存器的作用-240301" /></p>
<h2 id="2-两个常见面试题"><a class="markdownIt-Anchor" href="#2-两个常见面试题"></a> 2、两个常见面试题</h2>
<ol>
<li>
<p>使用PC寄存器存储字节码指令有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<blockquote>
<p>因为CPU需要不停的切换各个线程，切换回来以后，就得知道接着从哪里开始执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行的字节码指令。</p>
</blockquote>
</li>
<li>
<p>PC寄存器为什么会被设定为线程私有？</p>
<blockquote>
<p><font color="red">为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，</font>这样一来各个线程直接便可以进行独立计算，从而不会出现相互干扰的情况。</p>
</blockquote>
</li>
</ol>
<h2 id="3-cpu时间片"><a class="markdownIt-Anchor" href="#3-cpu时间片"></a> 3、CPU时间片</h2>
<ol>
<li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li>
<li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li>
</ol>
<h1 id="五-虚拟机栈"><a class="markdownIt-Anchor" href="#五-虚拟机栈"></a> 五、虚拟机栈</h1>
<h2 id="1-虚拟机栈的主要特点"><a class="markdownIt-Anchor" href="#1-虚拟机栈的主要特点"></a> 1、虚拟机栈的主要特点</h2>
<ul>
<li>
<p>虚拟机栈出现的背景</p>
<blockquote>
<p>由于跨平台的设计，Java的指令是根据栈来设计的。不同平台CPU架构不同，所以不能设计基于寄存器的。</p>
<p><font color="red">优点是跨平台，指令集小，编译器更容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</font></p>
</blockquote>
</li>
<li>
<p>内存中的栈和堆</p>
<blockquote>
<p><font color="red">栈是运行时单位，而堆是存储的单位。</font></p>
<p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储问题，即数据怎么放、放在哪。</p>
</blockquote>
</li>
<li>
<p>虚拟机栈的基本内容</p>
<ul>
<li>
<p>Java虚拟机栈是什么？</p>
<blockquote>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。是线程私有的。</p>
</blockquote>
</li>
<li>
<p>生命周期</p>
<blockquote>
<p>生命周期与线程一致。</p>
</blockquote>
</li>
<li>
<p>作用</p>
<blockquote>
<p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>栈的特点（优点）</p>
<ul>
<li>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li>
<p>JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着入栈</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>
<p>对于栈来说不存在垃圾回收问题</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="面试题开发中遇到的异常有哪些"><a class="markdownIt-Anchor" href="#面试题开发中遇到的异常有哪些"></a> 面试题：开发中遇到的异常有哪些？</h3>
<p>栈中可能出现的异常</p>
<ul>
<li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个<font color="red">StackOverFlowError</font>异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出一个<font color="red">OutOfMemoryError</font>异常。</li>
</ul>
</li>
</ul>
<p><em>PS：设置栈内存的大小</em></p>
<blockquote>
<p><em>我们可以使用参数<code>-Xss</code>来设置线程的最大栈空间。栈的大小直接决定了函数调用的最大可达深度。</em></p>
</blockquote>
<h2 id="2-栈的存储单位"><a class="markdownIt-Anchor" href="#2-栈的存储单位"></a> 2、栈的存储单位</h2>
<ol>
<li>
<p>栈中存储什么？</p>
<ul>
<li>
<p>每个线程都有自己的栈，栈里的数据都是以<font color="red">栈帧（Stack Frame）的格式存在。</font></p>
</li>
<li>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
</li>
<li>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
</li>
<li>
<p>栈运行原理</p>
<ul>
<li>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
</li>
<li>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<font color="red">当前栈帧（Current Frame）</font>，与当前栈帧相对应的方法就是<font color="red">当前方法（Current Method）</font>，定义这个方法的类就是<font color="red">当前类（Current Class）</font>。</p>
</li>
<li>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
</li>
<li>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈。</p>
</li>
<li>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
</li>
<li>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
</li>
<li>
<p>Java方法有两种返回函数的方式，<font color="red">一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</font></p>
</li>
</ul>
</li>
<li>
<p>栈的内部结构</p>
<p>每个栈帧存储着：</p>
<ul>
<li><font color="red">局部变量表（Local Variables）</font></li>
<li><font color="red">操作数栈（Operand Stack）（或表达式栈）</font></li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</li>
</ol>
<h2 id="3-局部变量表local-variables"><a class="markdownIt-Anchor" href="#3-局部变量表local-variables"></a> 3、局部变量表（Local Variables）</h2>
<ul>
<li>局部变量表也称之为局部变量数组或本地变量表</li>
<li><font color="red">定义一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</font>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li>
<li>由于局部变量表示建立在线程的栈上，是线程的私有数据，因此<font color="red">不存在数据安全问题。</font></li>
<li><font color="red">局部变量表所需的容量大小是在编译期确定下来的</font>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li><font color="red">方法嵌套调用的次数由栈的大小决定。</font>一般来说，<font color="red">栈越大，方法嵌套调用次数越多。</font>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><font color="red">局部变量表中的变量只在当前方法调用中有效。</font>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<font color="red">当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</font></li>
</ul>
<h3 id="关于slot的理解"><a class="markdownIt-Anchor" href="#关于slot的理解"></a> 关于Slot的理解</h3>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li>
<li>局部变量表，<font color="red">最基本的存储单元是Slot（变量槽）。</font></li>
<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>
<li>在局部变量表里，<font color="red">32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个Slot。</font>
<ul>
<li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法内部定义的局部变量将会<font color="red">按照顺序</font>被复制到局部变量表中的每一个Slot上。</li>
<li>如果需要访问局部变量表中一个64bit的局部变量值时，<font color="red">只需要使用前一个索引即可</font>。（比如访问long和double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么<font color="red">该对象引用this将会存放在index0的Slot处</font>，其余参数按照参数表顺序继续排列。</li>
</ul>
<p><em>Slot的重复利用</em></p>
<blockquote>
<p><em><font color="red">栈帧中的局部变量表的槽位是可以重用的</font>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能复用过期局部变量的槽位，从而<font color="red">达到节省资源的目的。</font></em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 c 会复用 b 的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充说明：</p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><font color="red">局部变量表中的对象也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></li>
</ul>
<h2 id="4-操作数栈operand-stack"><a class="markdownIt-Anchor" href="#4-操作数栈operand-stack"></a> 4、操作数栈（Operand Stack）</h2>
<ul>
<li>
<p>每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出的操作数栈，也可以称之为表达式栈。（Expression Stack）。</p>
</li>
<li>
<p><font color="red">在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。</font></p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>
<li>比如：执行复制、交换、求和等操作。</li>
</ul>
</li>
<li>
<p>操作数栈，<font color="red">主要用于保存计算过程的中间结果，同时作为计算过程变量临时的存储空间。</font></p>
</li>
<li>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<font color="red">这个方法的操作数栈是空的。</font></p>
</li>
<li>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<code>max_stack</code>的值。</p>
</li>
<li>
<p>栈中的任何一个元素可以是任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度。</li>
<li>64bit的类型占用两个栈单位深度。</li>
</ul>
</li>
<li>
<p>操作数栈<font color="red">并非采用索引的方式来进行数据访问的，</font>而是只能通过标准的入栈和出栈操作来完成一次数据访问。</p>
</li>
<li>
<p><font color="red">如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</font>并更新PC寄存器中下一条需要执行的字节码指令。</p>
</li>
<li>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li>
<p>另外，我们说Java虚拟机的<font color="red">执行引擎是基于栈的执行引擎，</font>其中的栈指的就是操作数栈。</p>
</li>
</ul>
<p><strong>栈顶缓存（Top-of-Stack-Cashing）技术</strong></p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h2 id="5-动态链接dynamic-linking"><a class="markdownIt-Anchor" href="#5-动态链接dynamic-linking"></a> 5、动态链接（Dynamic Linking）</h2>
<ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中<font color="red">该栈帧所属方法的引用</font>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：<code>invokedynamic</code>指令。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在Class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向的方法符号引用来表示的，那么<font color="red">动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</font></li>
</ul>
<p><em>为什么需要常量池呢？</em></p>
<blockquote>
<p><em>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</em></p>
</blockquote>
<h3 id="方法的调用"><a class="markdownIt-Anchor" href="#方法的调用"></a> 方法的调用</h3>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。</p>
<ul>
<li>
<p>静态链接：</p>
<blockquote>
<p>当一个字节码文件被装载到JVM内部时，如果被调用的<font color="red">目标方法在编译期可知，</font>且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程成为静态链接。</p>
</blockquote>
</li>
<li>
<p>动态链接：</p>
<blockquote>
<p>如果<font color="red">被调用的方法在编译期无法确定下来，</font>也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接。</p>
</blockquote>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<font color="red">绑定是一个字段、方法或者类的符号引用被替换为直接引用的过程，这仅仅发生一次。</font></p>
<p>1）方法的绑定机制</p>
<ul>
<li>
<p>早期绑定：</p>
<blockquote>
<p>早期绑定就是指被调用的<font color="red">目标方法如果在编译期可知，且运行期保持不变</font>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</blockquote>
</li>
<li>
<p>晚期绑定：</p>
<blockquote>
<p>如果<font color="red">被调用的方法在编译期无法确认下来，只能够在程序运行期间根据实际的类型绑定相关的方法</font>，这种绑定方式称为晚期绑定。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><em>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<font color="red">这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</font></em></p>
<p><em>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C<ins>语言中的虚函数（C</ins>中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字<code>final</code>来标记这个方法。</em></p>
</blockquote>
<p>2）虚方法和非虚方法</p>
<p>非虚方法：</p>
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类（super）方法都是非虚方法。</li>
<li>其他方法为虚方法。</li>
</ul>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令：
<ol>
<li><strong><code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong><code>invokespecial</code>：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</strong></li>
<li><code>invokevirtual</code>：调用所有虚方法</li>
<li><code>invokeinterface</code>：调用接口方法</li>
</ol>
</li>
<li>动态调用指令：<br />
5. <code>invokedynamic</code>：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而<code>invokedynamic</code>指令则支持由用户确定方法版本。其中<code>invokestatic</code>指令和<code>invokespecial</code>指令调用的方法称为非虚方法，其余的（ final修饰的除外）称为虚方法。</p>
<hr />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是重写的父类的静态方法，因为静态方法不能被重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法是非虚方法</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic();  <span class="comment">// invokestatic</span></span><br><span class="line">        showStatic();  <span class="comment">// invokestatic</span></span><br><span class="line"></span><br><span class="line">        showPrivate();  <span class="comment">// invokespecial</span></span><br><span class="line">        <span class="comment">// 非private方法是虚方法</span></span><br><span class="line">        info(); <span class="comment">// invokevirtual</span></span><br><span class="line">        display(<span class="built_in">this</span>);  <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.showCommon(); <span class="comment">// invokespecial</span></span><br><span class="line">        <span class="comment">// 没有显示加super，是虚方法</span></span><br><span class="line">        showCommon();   <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虽然显示为invokevirtual，但此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        showFinal();    <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        in.methodA();   <span class="comment">// invokeinterface</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>show()</code>方法的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 0 invokestatic #4 &lt;Father.showStatic : ()V&gt;</span><br><span class="line"> 3 invokestatic #5 &lt;Son.showStatic : ()V&gt;</span><br><span class="line"> 6 aload_0</span><br><span class="line"> 7 invokespecial #6 &lt;Son.showPrivate : ()V&gt;</span><br><span class="line">10 aload_0</span><br><span class="line">11 invokevirtual #7 &lt;Son.info : ()V&gt;</span><br><span class="line">14 aload_0</span><br><span class="line">15 aload_0</span><br><span class="line">16 invokevirtual #8 &lt;Son.display : (LFather;)V&gt;</span><br><span class="line">19 aload_0</span><br><span class="line">20 invokespecial #3 &lt;Father.showCommon : ()V&gt;</span><br><span class="line">23 aload_0</span><br><span class="line">24 invokevirtual #9 &lt;Son.showCommon : ()V&gt;</span><br><span class="line">27 aload_0</span><br><span class="line">28 invokevirtual #10 &lt;Son.showFinal : ()V&gt;</span><br><span class="line">31 aconst_null</span><br><span class="line">32 astore_1</span><br><span class="line">33 aload_1</span><br><span class="line">34 invokeinterface #11 &lt;Son$MethodInterface.methodA : ()V&gt; count 1</span><br><span class="line">39 return</span><br></pre></td></tr></table></figure>
<p>3）关于invokedynamic指令</p>
<ul>
<li>
<p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个<code>invokedynamic</code>指令，这是<font color="red">Java为了实现『动态类型语言』支持而做的一种改进。</font></p>
</li>
<li>
<p>但是在Java7中并没有提供直接生成<code>invokedynamic</code>指令的方法，需要借助ASM这种底层字节码工具来产生<code>invokedynamic</code>指令。<font color="red">直到Java8的Lambda表达式的出现，<code>invokedynamic</code>指令的生成，在Java中才有了直接的生成方式。</font></p>
</li>
<li>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvokedynamicTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IPrint</span> <span class="variable">i</span> <span class="operator">=</span> str -&gt; &#123;</span><br><span class="line">            str += <span class="string">&quot;！&quot;</span>;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPrint</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 invokedynamic #2 &lt;fun, BootstrapMethods #0&gt;</span><br><span class="line">5 astore_1</span><br><span class="line">6 return</span><br></pre></td></tr></table></figure>
<p>4）动态语言和静态语言</p>
<ol>
<li>动态类型语言和静态类型语言两者的区别就在于<font color="red">对类型的检查是在编译期还是在运行期</font>，满足前者就是静态类型语言，反之是动态类型语言。</li>
<li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>
</ol>
<blockquote>
<p>Java：<code>String info = &quot;hello world&quot;;</code> （Java是静态类型语言，会先编译就进行类型检查）</p>
<p>JS：<code>var info = &quot;hello world&quot;; var info = 10;</code> （运行时才进行检查）</p>
</blockquote>
<p>5）方法重写的本质</p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。
<ul>
<li>如果通过，则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回<code>java.lang.IllegalAccessError</code> 异常</li>
</ul>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果最终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<blockquote>
<p>以上的过程成为动态分派。</p>
</blockquote>
<p><strong><code>IllegalAccessError</code>介绍</strong></p>
<ol>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突。</li>
</ol>
<p>6）虚方法表</p>
<ul>
<li>
<p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<font color="red">为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引来代替查找。</font></p>
</li>
<li>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li>
<p>那么虚方法表什么时候被创建？</p>
<blockquote>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。</p>
</blockquote>
</li>
</ul>
<h2 id="6-方法返回地址return-address"><a class="markdownIt-Anchor" href="#6-方法返回地址return-address"></a> 6、方法返回地址（Return Address）</h2>
<ul>
<li>
<p>存放调用该方法的PC寄存器的值。</p>
</li>
<li>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>
<p>无论通过哪种方式退出，在方法退出后都返回该方法被调用的位置。方法正常退出时，<font color="red">调用者的PC寄存器计数的值作为返回地址，即调用该方法的指令的下一条指令的地址。</font>而异常退出的方法，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
</li>
<li>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
</li>
<li>
<p><font color="red">正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。</font></p>
</li>
</ul>
<h3 id="方法退出的两种方式"><a class="markdownIt-Anchor" href="#方法退出的两种方式"></a> 方法退出的两种方式</h3>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<p><strong>正常退出</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<font color="red">正常完成出口</font>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：
<ul>
<li><code>ireturn</code>：当返回值是boolean，byte，char，short和int类型时使用</li>
<li><code>lreturn</code>：Long类型</li>
<li><code>freturn</code>：Float类型</li>
<li><code>dreturn</code>：Double类型</li>
<li><code>areturn</code>：引用类型</li>
<li><code>return</code>：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li>
</ul>
</li>
</ol>
<p><strong>异常退出</strong></p>
<ol>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<font color="red">异常完成出口</font>。</li>
<li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li>
</ol>
<h2 id="7-一些附加信息"><a class="markdownIt-Anchor" href="#7-一些附加信息"></a> 7、一些附加信息</h2>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h2 id="8-相关面试题"><a class="markdownIt-Anchor" href="#8-相关面试题"></a> 8、相关面试题</h2>
<ul>
<li>
<p>举例栈溢出的情况？（StackOverflowError）</p>
<blockquote>
<p>栈大小分为固定和动态变化。如果是固定的就可能出现<code>StackOverflowError</code>。如果是动态变化的，在申请内存时内存不足时就可能出现<code>OutOfMemoryError</code>。</p>
</blockquote>
</li>
<li>
<p>调整栈大小，就能保证不出现溢出么？</p>
<blockquote>
<p>不能保证不溢出，只能保证SOF出现的几率小。</p>
</blockquote>
</li>
<li>
<p>分配的栈内存越大越好么？</p>
<blockquote>
<p>不是，虽然一定程度内降低了SOF概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的。</p>
</blockquote>
</li>
<li>
<p>垃圾回收是否涉及到虚拟机栈？</p>
<blockquote>
<p>不会</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>是否会出现Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC计数器</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>方法区</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li>
<p>方法中定义的局部变量是否线程安全？</p>
<blockquote>
<p>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// s的声明方式是线程安全的（只在方法内部使用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s的操作过程，是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s)</span>&#123;</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s的操作，是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s的操作：是线程安全的（s自己消亡了，最后返回的只是s.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="六-本地方法栈"><a class="markdownIt-Anchor" href="#六-本地方法栈"></a> 六、本地方法栈</h1>
<h2 id="1-什么是本地方法"><a class="markdownIt-Anchor" href="#1-什么是本地方法"></a> 1、什么是本地方法？</h2>
<p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制。</p>
<p><font color='red'>标识符native可以与所有其它的java标识符连用，但是abstract除外。</font></p>
<h2 id="2-为什么要使用本地方法"><a class="markdownIt-Anchor" href="#2-为什么要使用本地方法"></a> 2、为什么要使用本地方法？</h2>
<p>Java使用起来很方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>
<p>与Java环境外交互：</p>
<p><font color='red'>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</font>你可以想想Java需要与一些底层系统，如操作系统或者某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用以外的繁琐的细节。</p>
</li>
<li>
<p>与操作系统的交互</p>
<ol>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li>
<li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li>
<li><font color='red'>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。</font></li>
<li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ol>
</li>
<li>
<p>Sun’s Java</p>
<ol>
<li><font color='red'>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</font>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li>
<li>例如：类<code>java.lang.Thread</code>的<code>setPriority()</code>方法是用Java实现的，但是它实现调用的是该类里的本地方法<code>setPriority0()</code>。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 <code>setpriority()</code> API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ol>
</li>
</ul>
<h2 id="3-本地方法的现状"><a class="markdownIt-Anchor" href="#3-本地方法的现状"></a> 3、本地方法的现状</h2>
<p><font color='red'>目前该方法使用的越来越少了，除非是与硬件有关的应用，</font>比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h2 id="4-本地方法栈"><a class="markdownIt-Anchor" href="#4-本地方法栈"></a> 4、本地方法栈</h2>
<ol>
<li>
<p><font color='red'>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</font></p>
</li>
<li>
<p>本地方法栈，也是线程私有的。</p>
</li>
<li>
<p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）</p>
<ul>
<li>
<p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</p>
</li>
<li>
<p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</p>
</li>
</ul>
</li>
<li>
<p>本地方法一般是使用C语言或C++语言实现的。</p>
</li>
<li>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
</li>
</ol>
<p><strong>PS：</strong></p>
<blockquote>
<ul>
<li>
<p><font color='red'>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</font></p>
<ul>
<li>本地方法可以通过本地方法接口来<font color='red'>访问虚拟机内部的运行时数据区。</font></li>
<li>它甚至可以直接使用本地处理器中的寄存器。</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li>
<p><font color='cornflowerblue'>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</font>如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
</li>
<li>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
</li>
</ul>
</blockquote>
<h1 id="七-堆"><a class="markdownIt-Anchor" href="#七-堆"></a> 七、堆</h1>
<h2 id="1-堆的核心概述"><a class="markdownIt-Anchor" href="#1-堆的核心概述"></a> 1、堆的核心概述</h2>
<ol>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</li>
<li>《Java虚拟机规范》规定，堆可以处于<font color='red'>物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</font></li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：<font color='red'>所有的对象实例以及数组都应当在运行时分配在堆上。</font>（The heap is the run-time data area from which memory for all class instances and arrays is allocated）
<ul>
<li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
<ul>
<li>也就是触发了GC的时候，才会进行回收。</li>
<li>在垃圾回收过程中经常涉及到对对象的挪动，进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿，用户线程受到影响。</li>
</ul>
</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ol>
<h2 id="2-堆的内存细分"><a class="markdownIt-Anchor" href="#2-堆的内存细分"></a> 2、堆的内存细分</h2>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ul>
<li>
<p>Java7及之前的堆内存逻辑上分为三部分：新生区+养老区+<font color='red'>永久区</font></p>
<ul>
<li>Young Generation Space 		新生区			Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space         养老区            Old/Tenure</li>
<li>Permanent Space                      永久区            Perm</li>
</ul>
</li>
<li>
<p>Java8及之后的堆内存逻辑上分为三部分：新生区+养老区+<font color='red'>元空间</font></p>
<ul>
<li>Young Generation Space 		新生区			Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space         养老区            Old/Tenure</li>
<li>Meta Space                                 永久区            Meta</li>
</ul>
</li>
</ul>
<blockquote>
<p>约定：新生区&lt;=&gt;新生代&lt;=&gt;年轻代		养老区&lt;=&gt;老年区&lt;=&gt;老年代		永久区&lt;=&gt;永久代</p>
</blockquote>
<h2 id="3-堆空间大小的设置"><a class="markdownIt-Anchor" href="#3-堆空间大小的设置"></a> 3、堆空间大小的设置</h2>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项<code>-Xms</code>和<code>-Xmx</code>来进行设置。
<ul>
<li><code>-Xms</code>用于表示堆区的起始内存，等价于<code>-XX:InitalHeapSize</code></li>
<li><code>-Xmx</code>用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li>
</ul>
</li>
<li>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出<code>OutOfMemoryError</code>异常。</li>
<li>通常会将<code>-Xms</code>和<code>-Xmx</code>两个配置相同的值，其<font color='red'>目的是为了能够在Java垃圾回收器机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</font></li>
<li>默认情况下，初始内存大小=物理内存大小/64，最大内存大小=物理内存大小/4。</li>
</ul>
<p><strong>JVisualVM可视化查看堆内存</strong></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOOM</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[random.nextInt(<span class="number">1024</span> * <span class="number">1024</span>)]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开jvisualvm查看Visual GC：</p>
<p><img src="https://img.picgo.net/2025/01/20/Visual_GC-240301c4ec1bb1944d5b97.jpg" alt="Visual_GC-240301" /></p>
<p>此时程序也报了OOM异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at HeapTest.testOOM(HeapTest.java:<span class="number">59</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="4-年轻代和老年代"><a class="markdownIt-Anchor" href="#4-年轻代和老年代"></a> 4、年轻代和老年代</h2>
<ul>
<li>
<p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另一类对象的生命周期却非常长，在某些极端的环境下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和年老代（OldGen）。</p>
</li>
<li>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。</p>
</li>
<li>
<p>配置新生代与老年代在堆结构的占比：</p>
<ul>
<li>默认<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1/3。</li>
<li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占1，老年代占4，新生代占整个堆的1/5。</li>
</ul>
</li>
<li>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1。</p>
</li>
<li>
<p>可以通过选项<code>-XX:SurvivorRatio</code>调整这个空间比例。比如<code>-XX:SurvivorRatio=6</code>表示6 : 1 : 1。</p>
</li>
<li>
<p><font color='red'>几乎所有</font>的Java对象都是在Eden区被new出来的。</p>
</li>
<li>
<p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
</li>
<li>
<p>可以使用选项<code>-Xmn</code>设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
</li>
</ul>
<h2 id="5-对象分配过程"><a class="markdownIt-Anchor" href="#5-对象分配过程"></a> 5、对象分配过程</h2>
<p>​	为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>
<p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li>
<p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
</li>
<li>
<p>然后将伊甸园中的剩余对象移动到幸存者0区。</p>
</li>
<li>
<p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
</li>
<li>
<p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li>
<p>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，</p>
<p>设置 JVM 参数：<code>-XX:MaxTenuringThreshold=N</code> 进行设置。</p>
</li>
<li>
<p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p>
</li>
<li>
<p>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</p>
</li>
</ol>
<hr />
<p><strong>图解对象分配过程</strong></p>
<ul>
<li>我们创建的对象，一般都是存放在Eden区的，<font color='red'>当我们Eden区满了后，就会触发GC操作</font>，一般被称为 <code>YGC / Minor GC</code>操作</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC1-240301539459107f91fa1f.png" alt="Minor GC1-240301" /></p>
<ul>
<li>
<p>当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个<font color='red'>年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</font></p>
</li>
<li>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个Minor GC操作，此时<font color='red'>GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To区，同时让存活的对象年龄 + 1。</font></p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC2-2403014b8cecb8c17dbb91.png" alt="Minor GC2-240301" /></p>
<ul>
<li>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次<code>Promotion</code>晋升的操作，也就是将<font color='red'>年轻代中的对象晋升到老年代中。</font></li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC3-24030130268c288ab6d016.png" alt="Minor GC3-240301" /></p>
<p><strong>总结：</strong></p>
<ul>
<li>
<p>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。</p>
</li>
<li>
<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p>
</li>
</ul>
<p><strong>特殊情况说明：</strong></p>
<ol>
<li>
<p>特别注意，在Eden区满了的时候，才会触发Minor GC，<font color='red'>而幸存者区满了后，不会触发MinorGC操作</font>。</p>
</li>
<li>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。</p>
</li>
<li>
<p>如果来了一个新对象，先看看 Eden 是否放的下？</p>
<blockquote>
<p>如果 Eden 放得下，则直接放到 Eden 区。</p>
<p>如果 Eden 放不下，则触发 YGC ，执行垃圾回收之后再看看Eden还能不能放下？放得下就放。</p>
</blockquote>
</li>
<li>
<p>将对象放到老年区又有两种情况：</p>
<blockquote>
<p>如果 Eden 执行了 YGC 还是无法放不下该对象，那直接放老年代。<br />
万一老年代都放不下，则先触发Full GC ，Full GC后看老年代能不能放下，如果还是放不下，就报OOM错误。</p>
</blockquote>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-2403015e3e922afdeb44d7.png" alt="对象分配过程-240301" /></p>
<h2 id="6-常用调优工具"><a class="markdownIt-Anchor" href="#6-常用调优工具"></a> 6、常用调优工具</h2>
<ol>
<li>JDK命令行</li>
<li>Eclipse: Memory Analyzer Tool</li>
<li><font color='red'>Jconsole</font></li>
<li><font color='red'>Visual VM（实时监控）</font></li>
<li><font color='red'>Jprofiler</font></li>
<li><font color='red'>Java Flight Recorder（实时监控）</font></li>
<li>GCViewer</li>
<li>GCEasy</li>
</ol>
<h2 id="7-gc回收器"><a class="markdownIt-Anchor" href="#7-gc回收器"></a> 7、GC回收器</h2>
<h3 id="71-分代收集思想"><a class="markdownIt-Anchor" href="#71-分代收集思想"></a> 7.1 分代收集思想</h3>
<blockquote>
<ul>
<li>Minor GC: 只清除新生代的垃圾</li>
<li>Major GC: 只清除老年代的垃圾</li>
<li>Full GC: 对整个堆, 以及方法区的垃圾进行清除</li>
</ul>
</blockquote>
<ol>
<li>JVM的调优的一个环节，也就是垃圾收集，我们需要<font color='red'>尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上。</font></li>
<li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</li>
</ol>
<p><strong>部分收集：</strong></p>
<p>不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的圾收集。
<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><font color='red'>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
<ul>
<li>目前，只有G1 GC会有这种行为。</li>
</ul>
</li>
</ul>
<p><strong>整堆收集：</strong></p>
<p>收集整个Java堆和方法区的垃圾收集。</p>
<h3 id="72-minor-gc"><a class="markdownIt-Anchor" href="#72-minor-gc"></a> 7.2 Minor GC</h3>
<p>年轻代（Minor GC）触发机制：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会触发GC。<font color='red'>（当Eden满的时候, 会对Eden进行回收, 顺带也会回收Survivor区的垃圾）</font></li>
<li>因为Java对象<font color='red'>大多都具备朝生夕灭</font>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束后，用户线程才会恢复运行。</li>
</ul>
<h3 id="73-major-gc"><a class="markdownIt-Anchor" href="#73-major-gc"></a> 7.3 Major GC</h3>
<p>老年代（Major GC）触发机制：</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说Major Gc或Full GC发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC。</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
<h3 id="74-full-gc后面细讲"><a class="markdownIt-Anchor" href="#74-full-gc后面细讲"></a> 7.4 Full GC（后面细讲）</h3>
<p>触发Full GC执行的情况有如下五种：</p>
<ol>
<li>调用<code>System.gc()</code>时，系统建议执行Full GC，但不是必然执行。</li>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</li>
<li>由Eden区，Survivor space0（from space） 区向Survivor space1（to space）区复制时，对象大小大于to space可用内存，则把该对象转存到老年代，且老年代的可用内存大小小于该对象大小。</li>
</ol>
<p>说明：<font color='red'>Full GC是开发或调优中尽量要避免的，这样暂停时间会短一些。</font></p>
<h3 id="75-gc日志分析"><a class="markdownIt-Anchor" href="#75-gc日志分析"></a> 7.5 GC日志分析</h3>
<ul>
<li>JVM参数： <code>-Xms9m -Xmx9m -XX:+PrintGCDetails</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GCtest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; i++) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">            s = s + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;789K(9728K), 0.0008126 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2536K-&gt;504K(2560K)] 2837K-&gt;1149K(9728K), 0.0012230 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2552K-&gt;504K(2560K)] 3197K-&gt;1430K(9728K), 0.0006978 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">...</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 6374K-&gt;6374K(9216K), 0.0003482 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 6374K-&gt;6172K(7168K)] 6374K-&gt;6172K(9216K), [Metaspace: 9269K-&gt;9244K(1058816K)], 0.0184342 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] </span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	...</span><br><span class="line">遍历次数为：16</span><br></pre></td></tr></table></figure>
<ul>
<li>在 OOM 之前，一定会触发一次 Full GC ，因为只有在老年代空间不足时候，才会爆出OOM异常。</li>
<li>[PSYoungGen: 2048K-&gt;488K(2560K)]：年轻代总空间为 2560K ，回收前内存占用 2048K ，经过垃圾回收后内存占用 488K。</li>
<li>[ParOldGen: 6374K-&gt;6172K(7168K)]：老年代总空间为 7168K ，回收前内存占用 6374K ，经过垃圾回收后内存占用 6172K。</li>
<li>2048K-&gt;789K(9728K)：堆内存总空间为 9728K ，当前占用 2048K ，经过垃圾回收后内存占用 789K。</li>
<li>[Metaspace: 9269K-&gt;9244K(1058816K)]：元空间总空间为 1058816K，当前占用 9269K，经过垃圾回收后剩余 9244K。</li>
<li>0.0184342 secs ：垃圾回收用时。</li>
</ul>
<h2 id="8-堆空间分代思想"><a class="markdownIt-Anchor" href="#8-堆空间分代思想"></a> 8、堆空间分代思想</h2>
<p><font color='red'>为什么需要把Java堆分代？不分代就无法工作了吗？</font></p>
<blockquote>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：由Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是 : 优化GC性能。如果没有分代，那所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
</blockquote>
<h2 id="9-内存分配策略"><a class="markdownIt-Anchor" href="#9-内存分配策略"></a> 9、内存分配策略</h2>
<p><strong>内存分配策略或对象提升（Promotion）规则</strong></p>
<p>​	如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每经过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15，每个JVM、每个GC都有所不同）时，就会被晋升到老年代。<br />
​	对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p>
<ol>
<li>优先分配到Eden
<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象大都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比Minor GC要更少，因此可能回收起来就会比较慢，就会长时间占用老年代的空间。</li>
</ul>
</li>
<li>大对象直接分配到老年代，尽量避免程序中出现过多的大对象。</li>
<li>长期存活的对象分配到老年代。</li>
<li>动态对象年龄判断
<ul>
<li>如果Survivor区中相同年龄的所有对象占用内存的总和大于Survivor内存容量的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>（年龄阈值）中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保
<ul>
<li><code>-XX:HandlePromotionFailure</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<ul>
<li>JVM参数：<code>-Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整个过程并没有进行垃圾回收，并且 ParOldGen 区被占用了 20MB 的空间，说明大对象放到了老年代中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 18432K, used 2637K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 16384K, 16% used [0x00000000fec00000,0x00000000fee935c8,0x00000000ffc00000)</span><br><span class="line">  from space 2048K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000)</span><br><span class="line">  to   space 2048K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x00000000ffe00000)</span><br><span class="line"> ParOldGen       total 40960K, used 20480K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)</span><br><span class="line">  object space 40960K, 50% used [0x00000000fc400000,0x00000000fd800010,0x00000000fec00000)</span><br><span class="line"> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h2 id="10-为对象分配内存"><a class="markdownIt-Anchor" href="#10-为对象分配内存"></a> 10、为对象分配内存</h2>
<p><font color='red'>为什么有TLAB（Thread Local Allocation Buffer）？</font></p>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区的共享数据。</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在<font color='red'>并发环境下从堆区中划分内存空间是线程不安全的。</font></li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<p><font color='red'>什么是TLAB？</font></p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<font color='red'>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</font></li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<font color='red'>快速分配策略</font>。</li>
<li>据我所知所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><strong>TLAB的再说明</strong></p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<font color='red'>JVM确实是将TLAB作为内存分配的首选。</font></li>
<li>在程序中，开发人员可以通过选项<code>-XX:UseTLAB</code>设置是否开启TLAB空间。</li>
<li>默认情况下，TLAB空间的内存非常小，<font color='red'>仅占有整个Eden空间的1%</font>，当然我们可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<font color='red'>使用加锁机制</font>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
<p><strong>TLAB分配过程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/TLAB-24030104a6334a50759597.png" alt="TLAB分配过程-240301" /></p>
<h2 id="11-堆空间参数设置"><a class="markdownIt-Anchor" href="#11-堆空间参数设置"></a> 11、堆空间参数设置</h2>
<h3 id="111-常用参数设置"><a class="markdownIt-Anchor" href="#111-常用参数设置"></a> 11.1 常用参数设置</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvdW5peC9qYXZhLmh0bWw=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li><code>-XX:+PrintFlagsInitial</code>：查看所有的参数的默认初始值</li>
<li><code>-XX:+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li>
<li><code>-Xms</code>：初始堆空间内存（默认为物理内存的1/64）</li>
<li><code>-Xmx</code>：最大堆空间内存（默认为物理内存的1/4）</li>
<li><code>-Xmn</code>：设置新生代的大小（初始值及最大值）</li>
<li><code>-XX:NewRatio</code>：配置老年代与新生代在堆结构的占比</li>
<li><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0/S1空间的比例</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄，最大可设置为15</li>
<li><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</li>
<li><code>-XX:+PrintGC</code>或<code>-verbose:gc</code>：打印GC简要信息</li>
<li><code>-XX:HandlePromotionFalilure</code>：是否设置空间分配担保，当Young GC后，Survivor区仍然满了，就将新对象直接存在老年代</li>
</ol>
<p><strong>PS：</strong></p>
<blockquote>
<p>查看某个参数的指令：</p>
<p><code>jps</code>：查看当前运行中的JVM进程。</p>
<p><code>jinfo -flag SurvivorRatio 进程id</code>：查看某个进程的<code>SurvivorRatio</code>的值。</p>
</blockquote>
<h3 id="112-空间分配担保"><a class="markdownIt-Anchor" href="#112-空间分配担保"></a> 11.2 空间分配担保</h3>
<p>在发生Minor GC之前，虚拟机会<font color='red'>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</font></p>
<ul>
<li>如果大于，则此次Minor GC是安全的。（因为最坏的情况，新生代的所有对象都不需要回收，且它们都达到了晋升老年代的要求，此时将它们都放入到老年代，老年代的内存足够存放它们。）</li>
<li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。
<ul>
<li>如果<code>HandlePromotionFailure=true</code>，那么会继续<font color='red'>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</font>
<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的。</li>
<li>如果小于，则进行一次Full GC。</li>
</ul>
</li>
<li>如果<code>HandlePromotionFailure=false</code>，则进行一次Full GC。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update 24之后，<code>HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了<code>HandlePromotionFailure</code>参数，但是在代码中已经不会再使用它。<font color='red'>JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。即 <code>HandlePromotionFailure=true</code>。</font></p>
<h2 id="12-堆是分配对象的唯一选择吗"><a class="markdownIt-Anchor" href="#12-堆是分配对象的唯一选择吗"></a> 12、堆是分配对象的唯一选择吗？</h2>
<blockquote>
<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与<font color='red'>逃逸分析技术</font>逐渐成熟，<font color='red'>栈上分配、标量替换优化技术</font>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<font color='red'>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</font>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的Taobao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</blockquote>
<h3 id="121-逃逸分析概述"><a class="markdownIt-Anchor" href="#121-逃逸分析概述"></a> 12.1 逃逸分析概述</h3>
<ul>
<li>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li>
<p>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只能在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	对象的作用域仅在当前方法中有效，没有发生逃逸. 方法结束后, 该对象的引用就销毁了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">// getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逃逸分析参数设置</strong></p>
<ul>
<li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析。</li>
<li>如果使用的是较早的版本，开发人员则可以通过：
<ul>
<li>选项<code>-XX:+DoEscapeAnalysis</code>显式开启逃逸分析。</li>
<li>选项<code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong></p>
<p>开发中能使用局部变量的，就不要在方法外定义变量。（因为成员变量，可能会被多个线程使用，只能放在堆中，可能需要GC。如果是局部变量，存储在虚拟机栈中，是线程私有的，没有线程安全问题，也不需要GC）</p>
<p><strong>逃逸分析代码优化</strong></p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。</li>
<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<h3 id="122-栈上分配"><a class="markdownIt-Anchor" href="#122-栈上分配"></a> 12.2 栈上分配</h3>
<ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的对象逃逸的场景：
<ul>
<li>在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
</li>
</ul>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StackAllocationTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看执行时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx1g -Xms1g -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</code>，未开启逃逸分析。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 57 ms</span><br></pre></td></tr></table></figure>
<p>内存占用</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301ac4cf47384d7a2c3.jpg" alt="未开启逃逸分析时的内存占用-240301" /></p>
<ul>
<li>JVM参数：<code>-Xmx1g -Xms1g -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</code>，开启逃逸分析。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure>
<p>内存占用</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301a32e0ccf462adb3a.jpg" alt="开启逃逸分析时的内存占用-240301" /></p>
<h3 id="123-同步省略"><a class="markdownIt-Anchor" href="#123-同步省略"></a> 12.3 同步省略</h3>
<ol>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<font color='red'>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</font>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<font color='red'>锁消除</font>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码中对<code>obj</code>这个对象加锁，但是<code>obj</code>对象的生命周期只在<code>f()</code>方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="124-标量替换"><a class="markdownIt-Anchor" href="#124-标量替换"></a> 12.4 标量替换</h3>
<p><font color='red'>标量（Scalar）</font>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。<br />
相对的，那些还可以分解的数据叫做<font color='red'>聚合量（Aggregate）</font>，Java中的对象就是聚合量，因为它可以分解成其他聚合量和标量。<br />
在JIT编译阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<font color='red'>标量替换</font>。</p>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ScalarReplace</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();    <span class="comment">//未发生逃逸</span></span><br><span class="line">    u.id = <span class="number">5</span>;</span><br><span class="line">    u.name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx128m -Xms128m -XX:+PrintGC -XX:-EliminateAllocations</code>，未开启标量替换。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  33280K-&gt;4175K(125952K), 0.0031847 secs]</span><br><span class="line">[GC (Allocation Failure)  37455K-&gt;2368K(125952K), 0.0013988 secs]</span><br><span class="line">[GC (Allocation Failure)  35648K-&gt;2392K(125952K), 0.0013342 secs]</span><br><span class="line">[GC (Allocation Failure)  35672K-&gt;2352K(125952K), 0.0013205 secs]</span><br><span class="line">[GC (Allocation Failure)  35632K-&gt;2328K(125952K), 0.0013186 secs]</span><br><span class="line">[GC (Allocation Failure)  35608K-&gt;2336K(126976K), 0.0015186 secs]</span><br><span class="line">[GC (Allocation Failure)  37152K-&gt;2277K(126464K), 0.0015978 secs]</span><br><span class="line">花费的时间为： 48 ms</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx128m -Xms128m -XX:+PrintGC -XX:+EliminateAllocations</code>，开启标量替换。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 4 ms</span><br></pre></td></tr></table></figure>
<h3 id="125-逃逸分析的不足"><a class="markdownIt-Anchor" href="#125-逃逸分析的不足"></a> 12.5 逃逸分析的不足</h3>
<ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<font color='red'>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</font></li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也<font color='red'>是即时编译器优化技术中一个十分重要的手段。</font></li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<font color='red'>对象实例都是分配在堆上。</font></li>
</ul>
<h2 id="13-小结"><a class="markdownIt-Anchor" href="#13-小结"></a> 13、小结</h2>
<ol>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选（年龄计数器为15的对象）拷贝过来的Java对象。</li>
<li>当然，也有特殊情况，我们知道<font color='red'>普通的对象可能会被分配在TLAB上</font>；</li>
<li>如果对象较大，无法分配在TLAB上，则JVM会试图直接分配在Eden其他位置上。</li>
<li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li><font color='red'>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</font></li>
<li><font color='red'>当GC发生在老年代时则被称为Major GC或者Full GC。</font></li>
<li>一般的，Minor GC的发生频率要比Major GC高很多，即<font color='red'>老年代中垃圾回收发生的频率将大大低于年轻代。</font>（因为new的对象一般都分配在新生代，新生代的对象大都是朝生夕死的，所以GC的频率很高）</li>
</ol>
<h1 id="八-方法区"><a class="markdownIt-Anchor" href="#八-方法区"></a> 八、方法区</h1>
<h2 id="1-栈-堆-方法区的交互关系"><a class="markdownIt-Anchor" href="#1-栈-堆-方法区的交互关系"></a> 1、栈、堆、方法区的交互关系</h2>
<p><strong>从内存结构来看</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-240301e9c4a2165f489612.jpg" alt="方法区在运行时数据区的位置-240301" /></p>
<p><strong>从线程共享与否的角度来看</strong></p>
<blockquote>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及独立会话管理</p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/-24030155755c1800bb4ec0.jpg" alt="从线程共享与否的角度来看-240301" /></p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<ol>
<li>Person类的.class信息存放在方法区中；</li>
<li>person变量存放在Java栈的局部变量表中；</li>
<li>真正的person对象存放在Java堆中；</li>
<li>在person对象中，有个指针指向方法区中的Person类型数据，表明这个person对象是用方法区中的Person类new出来的。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-240301308aaa7ea4814fd3.jpg" alt="对象的访问定位-240301" /></p>
<h2 id="2-方法区的理解"><a class="markdownIt-Anchor" href="#2-方法区的理解"></a> 2、方法区的理解</h2>
<h3 id="21-方法区的位置"><a class="markdownIt-Anchor" href="#21-方法区的位置"></a> 2.1 方法区的位置</h3>
<p>​	《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言， 方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以，<font color='red'> 方法区可以看作是一块独立于Java堆的内存空间。</font></p>
<h3 id="22-方法区的基本理解"><a class="markdownIt-Anchor" href="#22-方法区的基本理解"></a> 2.2 方法区的基本理解</h3>
<ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。（多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即<font color='red'>类只能加载一次</font>）</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code>。
<ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ol>
<h3 id="23-方法区的演进"><a class="markdownIt-Anchor" href="#23-方法区的演进"></a> 2.3 方法区的演进</h3>
<p><strong>Hotspot 方法区的演进过程</strong></p>
<ol>
<li>在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。</li>
<li>JDK 1.8后，元空间存放在堆外内存中，我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过<code>-XX:MaxPermsize</code>上限）</li>
</ul>
</li>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于： <font color='red'>元空间不在虚拟机设置的内存中，而是使用本地内存。</font></li>
<li>永久代、元空间二者并不只是名字变了， 内部结构也调整了。</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ol>
<h2 id="3-设置方法区大小与oom"><a class="markdownIt-Anchor" href="#3-设置方法区大小与oom"></a> 3、设置方法区大小与OOM</h2>
<p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<p><strong>JDK7 之前版本设置永久代大小</strong></p>
<ol>
<li>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是20.75M</li>
<li><code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code>。</li>
</ol>
<p><strong>JDK8 版本设置元空间大小</strong></p>
<ol>
<li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定。</li>
<li>默认值依赖于平台，<font color='cornflowerblue'>Windows下，<code>-XX:MetaspaceSize</code>约为21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，即没有限制。</font></li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code>。</li>
<li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端 JVM来说，其默认的<code>-XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。
<ul>
<li>如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。</li>
<li>如果释放空间过多，则适当降低该值。</li>
</ul>
</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li>
</ol>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OOMTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt; clazz = ClassLoader.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">defineClass</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        defineClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">10000</span>; i++) &#123;    <span class="comment">// 不断生成并加载类</span></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">            classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">            defineClass.invoke(<span class="built_in">this</span>, <span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认的 JVM 参数，元空间不设置上限</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM 参数：<code>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</code>，设置元空间大小上限为10MB。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at MethodAreaTest.OOMTest(MethodAreaTest.java:36)</span><br><span class="line">	at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="line">	at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">	at MethodAreaTest.OOMTest(MethodAreaTest.java:36)</span><br><span class="line">991</span><br></pre></td></tr></table></figure>
<p><strong>如何解决OOM</strong></p>
<ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。
<ul>
<li>内存泄漏就是有大量的引用指向某些对象，这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象不会被回收，这就是内存泄漏问题。</li>
</ul>
</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="4-方法区的内部结构"><a class="markdownIt-Anchor" href="#4-方法区的内部结构"></a> 4、方法区的内部结构</h2>
<h3 id="41-方法区结构"><a class="markdownIt-Anchor" href="#41-方法区结构"></a> 4.1 方法区结构</h3>
<p><img src="https://img.picgo.net/2025/01/20/-2403015da642e992d0b2fb.jpg" alt="方法区结构-240301" /></p>
<p><strong>方法区（Method Area）存储什么？</strong></p>
<blockquote>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机<font color='red'>加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</font></p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/-240301eab8558f1de88aca.jpg" alt="方法区存储什么-240301" /></p>
<p><strong>类型信息</strong></p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于<code>interface</code>或是<code>java.lang.Object</code>，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<p><strong>域（Field）信息</strong></p>
<ol>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li>
</ul>
</li>
</ol>
<p><strong>方法（Method）信息</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（包括void返回类型），void在Java中对应的类为<code>void.class</code></li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStructTest</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>反编译字节码文件，并输出值文本文件中，便于查看</li>
<li>参数 -p 确保能查看 private 权限类型的字段或方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v -p MethodInnerStructTest.class &gt; text.txt</span><br></pre></td></tr></table></figure>
<p><strong>类型信息</strong></p>
<ul>
<li>
<p>在方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类。</p>
</li>
<li>
<p>从反编译文件可以看出，字节码文件记录了 <code>MethodInnerStructTest</code> 继承了哪些类，实现了哪些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class com.example.java.MethodInnerStructTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>域信息</strong></p>
<ol>
<li>descriptor： I表示字段类型为 Integer</li>
<li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int num;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0001) ACC_PUBLIC</span><br><span class="line">private static java.lang.String str;</span><br><span class="line">  descriptor: Ljava/lang/String;</span><br><span class="line">  flags: (0x000a) ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>
<p><strong>方法信息</strong></p>
<ol>
<li>descriptor：<code>()V</code> 表示方法返回值类型为 void</li>
<li>flags: <code>ACC_PUBLIC</code> 表示方法权限修饰符为 public</li>
<li><code>stack=3</code> 表示操作数栈深度为 3</li>
<li><code>locals=2</code> 表示局部变量个数为 2 个（实例方法包含 this）</li>
<li><code>test1()</code> 方法虽然没有参数，但是其 <code>args_size</code>=1 ，这时因为将 this 作为了参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 18: 0</span><br><span class="line">        line 19: 3</span><br><span class="line">        line 20: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lcom/example/java/MethodInnerStructTest;</span><br><span class="line">            3      26     1 count   I</span><br></pre></td></tr></table></figure>
<h3 id="42-域信息特殊情况"><a class="markdownIt-Anchor" href="#42-域信息特殊情况"></a> 4.2 域信息特殊情况</h3>
<p><strong>non-final 类型的类变量</strong></p>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。</li>
<li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它。</li>
</ul>
<p><strong>代码示例</strong></p>
<ol>
<li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常。</li>
<li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAreaTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    order.hello();</span><br><span class="line">    System.out.println(order.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>全局常量：static final</strong></p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
<ul>
<li>
<p>反编译查看字节码指令，可以发现 number 的值已经写在字节码文件中了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static int count;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">public static final int number;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: int 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="43-运行时常量池"><a class="markdownIt-Anchor" href="#43-运行时常量池"></a> 4.3 运行时常量池</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy00Lmh0bWw=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>方法区内部包含了运行时常量池。</li>
<li>字节码文件内部包含了常量池。</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/JVM-24030141a7fd39b3fe63b6.jpg" alt="JVM运行时内存结构-240301" /></p>
<p><strong>常量池</strong></p>
<p>​	一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是常量池表（ Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p><img src="https://img.picgo.net/2025/01/20/class-2403014dfd28a2382f258d.jpg" alt="常量池在class文件中的位置-240301" /></p>
<p><strong>为什么需要常量池？</strong></p>
<ol>
<li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池</li>
<li>这个字节码包含了指向常量池的引用，在动态链接的时候会用到运行时常量池。</li>
</ol>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>虽然上述代码只有194字节，但是里面却使用了<code>String</code>、<code>System</code>、<code>PrintStream</code>及<code>Object</code>等结构。</li>
<li>如果不使用常量池，就需要将用到的类信息、方法信息等记录在当前的字节码文件中，造成文件臃肿</li>
<li>所以我们将所需用到的结构信息记录在常量池中，并通过引用的方式来加载、调用所需的结构。</li>
</ol>
<p><strong>常量池中有什么？</strong></p>
<ol>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ol>
<p><strong>小结：</strong></p>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<hr />
<p><strong>运行时常量池</strong></p>
<ol>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是Class字节码文件的一部分，<font color='red'>用于存放编译期生成的各种字面量与符号引用</font>，<font color='cornflowerblue'>这部分内容将在类加载后存放到方法区的运行时常量池中。</font></li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li><font color='red'>JVM为每个已加载的类型（类或接口）都维护一个常量池。</font>池中的数据项像数组项一样，是通过<font color='cornflowerblue'>索引访问</font>的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。 此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<font color='red'>具备动态性</font>。</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛<code>OutOfMemoryError</code>异常。</li>
</ol>
<h2 id="5-方法区图解示例"><a class="markdownIt-Anchor" href="#5-方法区图解示例"></a> 5、方法区图解示例</h2>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解字节码指令执行流程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-2403014cf6511a1dd334fd.gif" alt="字节码指令执行流程-240301" /></p>
<p><strong>关于【符号引用 --&gt; 直接引用】的理解</strong></p>
<ol>
<li>上面代码调用<code>System.out.println()</code>方法时，首先需要看看<code>System</code>类有没有加载，再看看<code>PrintStream</code>类有没有加载</li>
<li>如果没有加载，则执行加载，<font color='red'>执行时，将常量池中的符号引用（字面量）转换为直接引用（真正的地址值）。</font></li>
</ol>
<p><strong>关于程序计数器的说明</strong></p>
<p>​	程序计数器始终计算的都是当前代码运行的位置，目的是为了方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>
<h2 id="6-方法区的演进"><a class="markdownIt-Anchor" href="#6-方法区的演进"></a> 6、方法区的演进</h2>
<h3 id="61-永久代演进过程"><a class="markdownIt-Anchor" href="#61-永久代演进过程"></a> 6.1 永久代演进过程</h3>
<ol>
<li>
<p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
</li>
<li>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th style="text-align:center">JDK1.6及以前</th>
<th style="text-align:center">有永久代（permanent generation），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>JDK1.7</strong></td>
<td style="text-align:center"><strong>有永久代，但已经逐步 “去永久代”， 字符串常量池、静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>JDK1.8及以后</strong></td>
<td style="text-align:center"><strong>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="62-元空间出现原因"><a class="markdownIt-Anchor" href="#62-元空间出现原因"></a> 6.2 元空间出现原因</h3>
<ul>
<li>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<font color='red'>与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</font></p>
</li>
<li>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
</li>
<li>
<p>这项改动是很有必要的，原因有：</p>
<ol>
<li>
<p>为永久代设置空间大小是很难确定的。</p>
<p>​	在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<blockquote>
<p><code>Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space</code></p>
</blockquote>
<p>​	而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li>
<p>对永久代进行调优是很困难的。</p>
<p>​	有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
<p>​	方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低Full GC。一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
</ol>
</li>
</ul>
<h3 id="63-字符串常量池"><a class="markdownIt-Anchor" href="#63-字符串常量池"></a> 6.3 字符串常量池</h3>
<p><strong>字符串常量池StringTable为什么要调整位置？</strong></p>
<ol>
<li>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</li>
<li>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。 放到堆里，能及时回收内存。</li>
</ol>
<h3 id="64-静态变量位置"><a class="markdownIt-Anchor" href="#64-静态变量位置"></a> 6.4 静态变量位置</h3>
<p><strong>静态变量存放在那里？</strong></p>
<p><strong>代码示例 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>运行环境：JDK8</p>
</li>
<li>
<p>JVM参数：<code>-Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</code></p>
</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 59904K, used 5171K [0x00000000fbd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 51712K, 10% used [0x00000000fbd80000,0x00000000fc28ceb0,0x00000000ff000000)</span><br><span class="line">  from space 8192K, 0% used [0x00000000ff800000,0x00000000ff800000,0x0000000100000000)</span><br><span class="line">  to   space 8192K, 0% used [0x00000000ff000000,0x00000000ff000000,0x00000000ff800000)</span><br><span class="line"> ParOldGen       total 136704K, used 102400K [0x00000000f3800000, 0x00000000fbd80000, 0x00000000fbd80000)</span><br><span class="line">  object space 136704K, 74% used [0x00000000f3800000,0x00000000f9c00010,0x00000000fbd80000)</span><br><span class="line"> Metaspace       used 3473K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>通过 GC 日志可以看出： <font color='red'>静态变量引用对应的对象实体始终都存在堆空间</font></p>
<p><strong>代码示例 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用jhsdb进行分析（在JDK9后才有此工具）。</p>
</li>
<li>
<p>分析：<code>staticObj</code>随着<code>Test</code>的类型信息存放在方法区，<code>instanceObj</code>随着<code>Test</code>的对象实例存放在Java堆，<code>localObject</code>则是存放在<code>foo()</code>方法栈帧的局部变量表中。（指引用）</p>
</li>
<li>
<p>测试发现：三个对象的数据（指对象本身）在内存中的地址都落在Eden区范围内，所以结论： <font color='red'>只要是对象实例必然会在Java堆中分配</font>。</p>
</li>
<li>
<p>接着，找到了一个引用该<code>staticObj</code>对象的地方，是在一个<code>java.lang.Class</code>的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个<code>java.lang.Class</code>类型的对象实例，里面有一个名为<code>staticObj</code>的实例字段：</p>
<p><img src="https://img.picgo.net/2025/01/20/staticObj-24030138613beab926ed6c.jpg" alt="staticObj的地址-240301" /></p>
</li>
<li>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量<font color='red'>与类型在Java语言一端的映射Class对象存放在一起， 存储于Java堆之中</font>，从我们的实验中也明确验证了这一点</p>
</li>
</ul>
<h2 id="7-方法区的垃圾收集"><a class="markdownIt-Anchor" href="#7-方法区的垃圾收集"></a> 7、方法区的垃圾收集</h2>
<p><strong>方法区常量的回收</strong>（关于常量的回收比较简单，重点是类的回收）</p>
<ol>
<li>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用
<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</li>
<li>而符号引用则属于编译原理方面的概念，包括下面三类常量：
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
</ol>
<p><strong>方法区类的回收</strong></p>
<ul>
<li>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类“的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其<font color='cornflowerblue'>任何派生子类的实例</font>。</li>
<li><font color='cornflowerblue'>加载该类的类加载器已经被回收</font>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，<font color='cornflowerblue'>无法在任何地方通过反射访问该类的方法</font>。</li>
</ol>
</li>
<li>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是&quot;被允许&quot;，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及 <code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
</li>
<li>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<font color='cornflowerblue'>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</font></p>
</li>
</ul>
<h2 id="8-运行时数据区总结"><a class="markdownIt-Anchor" href="#8-运行时数据区总结"></a> 8、运行时数据区总结</h2>
<ul>
<li>线程私有结构：程序计数器、虚拟机栈、本地方法栈</li>
<li>每个虚拟机栈由具体的栈帧组成，在栈帧的动态链接中，保存了对方法的引用</li>
<li>方法区在JDK7之前，使用永久代实现，在 JDK8 之后，使用元空间实现</li>
<li>Minor GC针对于新生区，Major GC针对于老年区，Full GC针对于整个堆空间和方法区</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/JVM-2403012360f44f709ef021.jpg" alt="JVM运行时数据区-240301" /></p>
<h2 id="9-大厂面试题"><a class="markdownIt-Anchor" href="#9-大厂面试题"></a> 9、大厂面试题</h2>
<ol>
<li>百度
<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：
<ul>
<li>JDK8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个Survivor区？</li>
<li>二面：Eden和Survior的比例分配</li>
</ul>
</li>
<li>小米：
<ul>
<li>JVM内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
<li>字节跳动：
<ul>
<li>二面：JVM的内存分区</li>
<li>二面：讲讲JVM运行时数据区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：
<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li>
</ul>
</li>
<li>天猫：
<ul>
<li>一面：JVM内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：
<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：
<ul>
<li>JVM内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：JVM内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
<h1 id="九-对象的实例化内存布局与访问定位"><a class="markdownIt-Anchor" href="#九-对象的实例化内存布局与访问定位"></a> 九、对象的实例化内存布局与访问定位</h1>
<h2 id="1-对象的实例化"><a class="markdownIt-Anchor" href="#1-对象的实例化"></a> 1、对象的实例化</h2>
<p><strong>大厂面试题</strong></p>
<p>美团：</p>
<ol>
<li>对象在<code>JVM</code>中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
</ol>
<p>蚂蚁金服：</p>
<ol>
<li>二面：<code>java</code>对象头里有什么？</li>
</ol>
<hr />
<p><img src="https://img.picgo.net/2025/01/20/-2403017c2f6cf428469f43.png" alt="对象的实例化-240301" /></p>
<h3 id="11-对象创建的方式"><a class="markdownIt-Anchor" href="#11-对象创建的方式"></a> 1.1 对象创建的方式</h3>
<ol>
<li><code>new</code>：最常见的方式。或者是单例模式中调用静态类方法，xxxBuilder/xxxFactory的静态方法。</li>
<li><code>Class</code>的<code>newInstance()</code>方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为public。</li>
<li><code>Constructor</code>的<code>newInstance()</code>：反射的方式，可以调用空参的，或者带参的构造器。</li>
<li>使用<code>clone()</code>：不调用任何的构造器，要求当前的类需要实现<code>Cloneable</code>接口中的<code>clone()</code>方法。</li>
<li>使用序列化：从文件中、网络中获取一个对象的二进制流，进行序列化。一般用于Socket的网络传输。</li>
<li>第三方库<code>Objenesis</code>。</li>
</ol>
<h3 id="12-对象创建的步骤"><a class="markdownIt-Anchor" href="#12-对象创建的步骤"></a> 1.2 对象创建的步骤</h3>
<ol>
<li>
<p>判断对象对应的类是否加载、链接、初始化</p>
<ul>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</li>
<li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出<code>ClassNotFoundException</code>异常，如果找到，则进行类加载，并生成对应的Class对象。</li>
</ul>
</li>
<li>
<p>为对象分配内存</p>
<ul>
<li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</li>
<li>如果内存规整：采用指针碰撞分配内存
<ul>
<li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存时只需把指针往空闲内存那边挪动一段与对象大小相等的距离。</li>
<li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域。</li>
</ul>
</li>
<li>如果内存不规整
<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li>
<li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为 “空闲列表（Free List）”。</li>
</ul>
</li>
<li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li>
</ul>
</li>
<li>
<p>处理并发问题</p>
<ol>
<li>采用CAS+失败重试保证更新的原子性。</li>
<li>每个线程预先分配TLAB——通过<code>-XX:+UseTLAB</code>参数来设置（区域加锁机制）。</li>
</ol>
</li>
<li>
<p>初始化分配到的空间</p>
<ul>
<li>
<p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p>
</li>
<li>
<p>给对象属性赋值的顺序：</p>
<ul>
<li>属性的默认值初始化</li>
<li>显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li>
<li>构造器初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置对象的对象头</p>
<p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li>
<p>执行init方法进行初始化</p>
<ul>
<li>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
</li>
<li>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-对象的内存布局"><a class="markdownIt-Anchor" href="#2-对象的内存布局"></a> 2、对象的内存布局</h2>
<p><img src="https://img.picgo.net/2025/01/20/-2403019d666a1114f82943.png" alt="对象内存布局-240301" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.picgo.net/2025/01/20/-2403018f1173d87a7c56cd.png" alt="图示对象的内存布局-240301" /></p>
<h2 id="3-对象的访问定位"><a class="markdownIt-Anchor" href="#3-对象的访问定位"></a> 3、对象的访问定位</h2>
<p><img src="https://img.picgo.net/2025/01/20/-240301d2704155bd449f06.png" alt="对象的访问定位-240301" /></p>
<p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p>定位，通过栈上reference访问</p>
<p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p>
<ol>
<li>
<p>句柄访问</p>
<p><img src="https://img.picgo.net/2025/01/20/-24030163501f61b4addc0c.png" alt="对象的句柄访问-240301" /></p>
<ul>
<li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</li>
<li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低。</li>
</ul>
</li>
<li>
<p>直接指针</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301373543359a9945f1.png" alt="对象的直接指针-240301" /></p>
<ul>
<li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</li>
<li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值。</li>
</ul>
</li>
</ol>
<h1 id="十-直接内存"><a class="markdownIt-Anchor" href="#十-直接内存"></a> 十、直接内存</h1>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1、概述</h2>
<ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。</li>
<li>通常，访问直接内存的速度会优于Java堆。即读写性能高。
<ul>
<li>因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。</li>
</ul>
</li>
</ul>
<p>代码测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 直接分配本地内存空间</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存申请完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存开始释放&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过jps和任务管理器观察到对应Java进程内存发生的变化。</p>
<h2 id="2-数据缓冲区"><a class="markdownIt-Anchor" href="#2-数据缓冲区"></a> 2、数据缓冲区</h2>
<p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。这里需要两份内存存储重复数据，效率低。</p>
<p><img src="https://img.picgo.net/2025/01/20/-2403015e6247d506b2fe8e.png" alt="非直接缓冲区-240301" /></p>
<p>使用NIO时，如下图，操作系统划出的直接缓冲区可以被Java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301052ee57f9be95572.png" alt="直接缓冲区-240301" /></p>
<h2 id="3-其他"><a class="markdownIt-Anchor" href="#3-其他"></a> 3、其他</h2>
<ul>
<li>也可能导致<code>OutOfMemoryError</code>异常（<code>java.lang.OutOfMemoryError: Direct buffer memory</code>）。</li>
<li>由于直接内存在Java堆外，因此它的大小不会直接受限于<code>-Xmx</code>指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>缺点：
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。</li>
<li>如果不指定，默认与堆的最大值<code>-Xmx</code>参数值一致。</li>
</ul>
<h1 id="十一-执行引擎"><a class="markdownIt-Anchor" href="#十一-执行引擎"></a> 十一、执行引擎</h1>
<h2 id="1-执行引擎概述"><a class="markdownIt-Anchor" href="#1-执行引擎概述"></a> 1、执行引擎概述</h2>
<ol>
<li>执行引擎是Java虚拟机核心的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<font color='red'>虚拟机的执行引擎则是由软件自行实现的</font>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<font color='red'>能够执行那些不被硬件直接支持的指令集格式</font>。</li>
<li>JVM的主要任务是负责<font color='red'>装载字节码到其内部</font>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<font color='red'>将字节码指令解释/编译为对应平台上的本地机器指令才可以</font>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-1-2403013b064f6c436f0072.png" alt="执行引擎-1-240301" /></p>
<ul>
<li>
<p>前端编译：从Java文件-字节码文件的这个过程叫前端编译。</p>
</li>
<li>
<p>执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p>
</li>
</ul>
<h2 id="2-执行引擎工作过程"><a class="markdownIt-Anchor" href="#2-执行引擎工作过程"></a> 2、执行引擎工作过程</h2>
<ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
<li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/--2403018ab9eb91fcdb4237.png" alt="执行引擎-执行引擎工作过程-240301" /></p>
<h2 id="3-java代码编译和执行的过程"><a class="markdownIt-Anchor" href="#3-java代码编译和执行的过程"></a> 3、Java代码编译和执行的过程</h2>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p>
<p><img src="https://img.picgo.net/2025/01/20/--2403010fc6fd3a1be18e90.png" alt="执行引擎-编译和执行过程-240301" /></p>
<ul>
<li>前面橙色部分是生成字节码文件的过程，和JVM无关</li>
<li>后面蓝色和绿色才是JVM需要考虑的过程</li>
</ul>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="https://img.picgo.net/2025/01/20/-Java-2403011a5ebcf8d4544d06.png" alt="执行引擎-Java源码编译器执行流程-240301" /></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="https://img.picgo.net/2025/01/20/-Java-2403016bf66852ca819c92.png" alt="执行引擎-Java字节码执行流程-240301" /></p>
<p><strong>什么是解释器？</strong></p>
<p>解释器（Interpreter）：当Java虚拟机启动时会根据预定义的规范<font color='cornflowerblue'>对字节码采用逐行解释的方式执行</font>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p><strong>什么是JIT编译器？</strong></p>
<p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<p><strong>为什么Java是半编译半解释型语言？</strong></p>
<ul>
<li>
<p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
</li>
<li>
<p>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
</li>
</ul>
<p>结合下图可以更好理解解释器与编译器：</p>
<p><img src="https://img.picgo.net/2025/01/20/-2-2403010beefd56c75d6f7c.png" alt="执行引擎-2-240301" /></p>
<h2 id="4-机器码-指令-汇编语言"><a class="markdownIt-Anchor" href="#4-机器码-指令-汇编语言"></a> 4、机器码、指令、汇编语言</h2>
<h3 id="41-机器码"><a class="markdownIt-Anchor" href="#41-机器码"></a> 4.1 机器码</h3>
<ul>
<li>各种用二进制编码方式表示的指令，叫做<font color='cornflowerblue'>机器指令码</font>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h3 id="42-指令"><a class="markdownIt-Anchor" href="#42-指令"></a> 4.2 指令</h3>
<ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好。</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>
</ul>
<p><strong>指令集</strong></p>
<p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br />
如常见的：</p>
<ul>
<li>x86指令集，对应的是x86架构的平台。</li>
<li>ARM指令集，对应的是ARM架构的平台。</li>
</ul>
<h3 id="43-语言"><a class="markdownIt-Anchor" href="#43-语言"></a> 4.3 语言</h3>
<p><strong>汇编语言</strong></p>
<ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<font color='cornflowerblue'>助记符</font>（Mnemonics）<font color='cornflowerblue'>代替机器指令的操作码</font>，用地址符号（Symbol）或标号（Label）代替<font color='cornflowerblue'>指令或操作数的地址</font>。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。
<ul>
<li>由于计算机只认识指令码，所以用<font color='cornflowerblue'>汇编语言编写的程序还必须翻译成机器指令码</font>，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<p><strong>高级语言</strong></p>
<ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<font color='cornflowerblue'>更接近人的语言</font>。</li>
<li>当计算机执行高级语言编写的程序时，<font color='cornflowerblue'>仍然需要把程序解释和编译成机器的指令码</font>。完成这个过程的程序就叫做解释程序或编译程序。</li>
<li>高级语言不是直接翻译成机器指令，而是编译成汇编语言，再汇编成机器指令。编译过程又可以分成两个阶段：编译和汇编。
<ul>
<li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码。</li>
<li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
</li>
</ul>
<h3 id="44-字节码"><a class="markdownIt-Anchor" href="#44-字节码"></a> 4.4 字节码</h3>
<ul>
<li>字节码是一种<font color='cornflowerblue'>中间状态（中间码）的二进制代码（文件）</font>，它比机器码更抽象，需要直译器转译后才能成为机器码。</li>
<li>字节码主要为了实现特定软件运行和软件环境、<font color='cornflowerblue'>与硬件环境无关</font>。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。
<ul>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
</li>
</ul>
<h2 id="5-解释器"><a class="markdownIt-Anchor" href="#5-解释器"></a> 5、解释器</h2>
<p>JVM设计者们的初衷仅仅只是单纯地<font color='red'>为了满足Java程序实现跨平台特性</font>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<blockquote>
<p>为什么Java源文件不直接翻译成JVM，而是翻译成字节码文件？</p>
<ol>
<li>class 文件内容设计的更加紧凑，方便 JVM 执行，也方便网络传输（最初 JAVA 的一个重要应用就是 applet，在当年网络不是很放大的年代，程序的体积还是要挺重要的）。</li>
<li>方便其它语言执行。现在 JVM 上就有除了 Java 外大量的第三方语言，比如 scala，Clojure 等等。其它语言只要编译成 class 文件即可像 Java 一样在 JVM 上执行。</li>
</ol>
</blockquote>
<p><strong>解释器的工作机制（工作任务）</strong></p>
<ul>
<li>
<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
</li>
<li>
<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
</li>
</ul>
<p><strong>解释器的分类</strong></p>
<p>在Java的发展历史里，一共有两套解释执行器，即古老的<font color='red'>字节码解释器</font>、现在普遍使用的<font color='red'>模板解释器</font>。</p>
<ul>
<li>
<p>字节码解释器在执行时通过<font color='cornflowerblue'>纯软件代码</font>模拟字节码的执行，效率非常低下。</p>
</li>
<li>
<p>而模板解释器将<font color='cornflowerblue'>每一条字节码和一个模板函数相关联</font>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
<ul>
<li>
<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>
<ul>
<li>
<p>Interpreter模块：实现了解释器的核心功能</p>
</li>
<li>
<p>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>现状</strong></p>
<ul>
<li>
<p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，<font color='red'>基于解释器执行已经沦落为低效的代名词</font>，并且时常被一些C/C++程序员所调侃。</p>
</li>
<li>
<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<font color='red'>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码</font>即可，这种方式可以使执行效率大幅度提升。</p>
</li>
<li>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
</li>
</ul>
<h2 id="6-编译器"><a class="markdownIt-Anchor" href="#6-编译器"></a> 6、编译器</h2>
<h3 id="61-java代码的执行分类"><a class="markdownIt-Anchor" href="#61-java代码的执行分类"></a> 6.1 Java代码的执行分类</h3>
<ul>
<li>
<p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行。</p>
</li>
<li>
<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行。</p>
</li>
<li>
<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它<font color='cornflowerblue'>采用解释器与即时编译器并存的架构</font>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
</li>
<li>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p>
</li>
</ul>
<p><strong>问题来了</strong></p>
<p>有些开发人员会感觉到诧异，<font color='cornflowerblue'>既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</font>比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确：<br />
当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br />
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以：<br />
尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<font color='red'>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</font></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="62-hotspot-jvm执行方式"><a class="markdownIt-Anchor" href="#62-hotspot-jvm执行方式"></a> 6.2 HotSpot JVM执行方式</h3>
<p>当虚拟机启动的时候，<font color='cornflowerblue'>解释器可以首先发挥作用</font>，而不必等待即时编译器全部编译完成再执行，这样可以<font color='cornflowerblue'>省去许多不必要的编译时间</font>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据<font color='cornflowerblue'>热点探测</font>功能，将<font color='cornflowerblue'>有价值的字节码编译为本地机器指令</font>，以换取更高的程序执行效率。</p>
<p><strong>案例</strong></p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<font color='cornflowerblue'>机器在热机状态可以承受的负载要大于冷机状态</font>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<blockquote>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。——阿里团队</p>
</blockquote>
<h3 id="63-概念解释"><a class="markdownIt-Anchor" href="#63-概念解释"></a> 6.3 概念解释</h3>
<ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<font color='cornflowerblue'>前端编译器</font>（其实叫“编译器的前端”更准确一些）把<code>.java</code>文件转变成<code>.class</code>文件的过程。</li>
<li>也可能是指虚拟机的<font color='cornflowerblue'>后端运行期编译器</font>（JIT编译器，Just In Time Compiler），把字节码转变成机器码的过程。</li>
<li>还可能是指使用<font color='cornflowerblue'>静态提前编译器</font>（AOT编译器，Ahead of Time Compiler）直接把<code>.java</code>文件编译成本地机器代码的过程。</li>
</ul>
<blockquote>
<p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>
<p>JIT编译器：HotSpot VM的C1、C2编译器。</p>
<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
</blockquote>
<h3 id="64-热点代码及探测方式"><a class="markdownIt-Anchor" href="#64-热点代码及探测方式"></a> 6.4 热点代码及探测方式</h3>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<font color='red'>执行的频率</font>而定。关于那些需要被编译为本地代码的字节码，也被称之为<font color='red'>“热点代码”</font>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<font color='red'>深度优化</font>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<ul>
<li>
<p><font color='cornflowerblue'>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</font>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<font color='red'>OSR（On Stack Replacement）编译</font>。</p>
</li>
<li>
<p>一个方法究竟<font color='cornflowerblue'>要被调用多少次</font>，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<font color='red'>热点探测功能</font>。</p>
</li>
<li>
<p><font color='red'>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</font></p>
</li>
<li>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<p><strong>方法调用计数器</strong></p>
<ul>
<li>
<p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
</li>
<li>
<p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 来人为设定。</p>
</li>
<li>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<font color='cornflowerblue'>方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值</font>。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301f67b1854906ee9a5.png" alt="执行引擎-方法调用计数器-240301" /></p>
<p><strong>热点衰减</strong></p>
<ul>
<li>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<font color='cornflowerblue'>一段时间之内方法被调用的次数</font>。当超过<font color='red'>一定的时间限度</font>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<font color='red'>减少一半</font>，这个过程称为方法调用计数器热度的<font color='red'>衰减</font>（Counter Decay），而这段时间就称为此方法统计的<font color='red'>半衰周期</font>（Counter Half Life Time）。</p>
</li>
<li>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
</li>
<li>
<p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p>
</li>
</ul>
<p><strong>回边计数器</strong></p>
<p>它的作用是统计一个方法中<font color='cornflowerblue'>循环体代码执行的次数</font>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><img src="https://img.picgo.net/2025/01/20/--240301638e9dd044ec299f.png" alt="执行引擎-回边计数器-240301" /></p>
<p><strong>HotSpotVM可以设置程序执行方法</strong></p>
<p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<font color='cornflowerblue'>完全采用解释器</font>执行，还是<font color='cornflowerblue'>完全采用即时编译器</font>执行。如下所示：</p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行程序。</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 5335ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 684ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 696ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IntCompTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算100以内的质数</span></span><br><span class="line">        label:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= Math.sqrt(j); k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> label;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="65-jit分类"><a class="markdownIt-Anchor" href="#65-jit分类"></a> 6.5 JIT分类</h3>
<p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；
<ul>
<li>C1编译器会对字节码进行<font color='red'>简单和可靠的优化，耗时短</font>。以达到更快的编译速度。</li>
</ul>
</li>
<li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。
<ul>
<li>C2进行<font color='red'>耗时较长的优化，以及激进优化</font>。但优化的代码执行效率更高（使用C++）。</li>
</ul>
</li>
</ul>
<p><strong>C1 和 C2编译器不同的优化策略</strong></p>
<p>在不同的编译器上有不同的优化策略：</p>
<ul>
<li>
<p>C1编译器上主要有方法内联，去虚拟化、元余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。</li>
<li>去虚拟化：对唯一的实现类进行内联。</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉。</li>
</ul>
</li>
<li>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值。</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆。</li>
<li>同步消除：清除同步操作，通常指synchronized。</li>
</ul>
</li>
</ul>
<p><strong>分层编译策略</strong></p>
<p><font color='red'>分层编译（Tiered Compilation）策略</font>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在JDK7版本之后，一旦开发人员在程序中显式指定命令“-server&quot;时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p><strong>总结</strong></p>
<ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器高。</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器。</li>
</ul>
<h3 id="66-aot编译器"><a class="markdownIt-Anchor" href="#66-aot编译器"></a> 6.6 AOT编译器</h3>
<p>JDK9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）。Java 9还引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<font color='cornflowerblue'>在程序运行之前，便将字节码转换为机器码</font>的过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure>
<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验。</p>
<p>缺点：</p>
<ul>
<li>破坏了Java“一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包。</li>
<li><font color='cornflowerblue'>降低了Java链接过程的动态性</font>，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 Java base。</li>
</ul>
<p><strong>写到最后</strong></p>
<ul>
<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器。</li>
<li>编译效果短短几年时间就追评了C2编译器，未来可期。</li>
<li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用。</li>
</ul>
<h1 id="十二-stringtable"><a class="markdownIt-Anchor" href="#十二-stringtable"></a> 十二、StringTable</h1>
<h2 id="1-string的基本特性"><a class="markdownIt-Anchor" href="#1-string的基本特性"></a> 1、String的基本特性</h2>
<ol>
<li>String：字符串，使用一对 “” 引起来表示</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;   			  <span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure>
<ol>
<li>String被声明为final的，不可被继承。</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小。</li>
<li>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li>
</ol>
<p><strong>为什么 JDK9 改变了 String 的结构</strong></p>
<p><span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8yNTQ=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li>
<li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（<code>Latin-1</code>）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li>
<li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组外加一个编码标识存储。该编码表示如果字符集编码是<code>ISO-8859-1</code>或者<code>Latin-1</code>，那么只需要一个字节存。如果是其它编码，比如UTF-8，仍然需要用两个字节存。</li>
<li>结论：String再也不用<code>char[]</code>来存储了，改成了<code>byte []</code>加上编码标记，节约了一些空间。</li>
<li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改。</li>
</ol>
<p><strong>String 的基本特性</strong></p>
<ul>
<li>
<p>String：代表不可变的字符序列。简称：不可变性。</p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
</li>
<li>
<p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
<li>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);	<span class="comment">// good</span></span><br><span class="line">        System.out.println(ex.ch);	<span class="comment">// best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容。</p>
<h2 id="2-string的底层结构"><a class="markdownIt-Anchor" href="#2-string的底层结构"></a> 2、String的底层结构</h2>
<p><font color='red'>字符串常量池是不会存储相同内容的字符串的。</font></p>
<ol>
<li>
<p>String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String的<code>intern()</code>方法时性能会大幅下降。</p>
</li>
<li>
<p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度。</p>
<ul>
<li>
<p>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，<code>StringTablesize</code>设置没有要求。</p>
</li>
<li>
<p>在JDK7中，StringTable的长度默认值是60013，<code>StringTablesize</code>设置没有要求。</p>
</li>
<li>
<p>在JDK8中，StringTable的长度默认值是60013，<code>StringTablesize</code>可以设置的最小值为1009。</p>
</li>
</ul>
</li>
</ol>
<p>2、String的内存分配</p>
<ul>
<li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>
<li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;hello Gerrit&quot;;</code></li>
<li>如果不是用双引号声明的String对象，可以使用String提供的<code>intern()</code>方法。这个后面重点谈。</li>
</ul>
</li>
<li>JDK6及以前，字符串常量池存放在永久代。</li>
<li>JDK7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内。
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以在进行调优应用时仅需调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在JDK7中使用<code>String.intern()</code>。</li>
</ul>
</li>
<li>JDK8元空间，字符串常量在堆。</li>
</ul>
<p><strong>StringTable 为什么要调整？</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamRrNy1yZWxub3Rlcy5odG1sI2pkazdjaGFuZ2Vz">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>为什么要调整位置？
<ul>
<li><font color='red'>永久代的默认空间大小比较小；</font></li>
<li><font color='red'>永久代垃圾回收频率低</font>，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM；</li>
<li><font color='red'>堆中空间足够大，字符串可被及时回收。</font></li>
</ul>
</li>
<li>在JDK7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li>
<li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li>
</ol>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m -XX:-UseGCOverheadLimit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        set.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<ul>
<li>
<p>JDK6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-string的基本操作"><a class="markdownIt-Anchor" href="#3-string的基本操作"></a> 3、String的基本操作</h2>
<p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串常量池中的String对象个数</span></span><br><span class="line">        System.out.println();		<span class="comment">// 2293</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);	<span class="comment">// 2294</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);	<span class="comment">// 2303</span></span><br><span class="line">        <span class="comment">// 如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>官方实例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        mem.foo(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析运行时内存</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-1-240301c3378f8f41e1978b.png" alt="StringTable-1-240301" /></p>
<h2 id="4-string拼接操作"><a class="markdownIt-Anchor" href="#4-string拼接操作"></a> 4、String拼接操作</h2>
<p><strong>先说结论</strong></p>
<ol>
<li>常量与常量的拼接结果在常量池，原理是编译期优化。</li>
<li>常量池中不会存在相同内容的变量。</li>
<li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。</li>
<li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：
<ul>
<li>如果存在，则返回字符串在常量池中的地址</li>
<li>如果不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li>
</ul>
</li>
</ol>
<p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong>。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;	<span class="comment">// 编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;	<span class="comment">// &quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">     * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     * String s2 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2);		<span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2));	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt;</span><br><span class="line">2 astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line">5 astore_2</span><br><span class="line">6 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line">9 aload_1</span><br><span class="line">10 aload_2</span><br><span class="line">11 if_acmpne 18 (+7)</span><br><span class="line">14 iconst_1</span><br><span class="line">15 goto 19 (+4)</span><br><span class="line">18 iconst_0</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">22 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line">25 aload_1</span><br><span class="line">26 aload_2</span><br><span class="line">27 invokevirtual #5 &lt;java/lang/String.equals&gt;</span><br><span class="line">30 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">33 return</span><br></pre></td></tr></table></figure>
<p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中。调用<code>intern()</code>方法，则主动将字符串对象存入字符串常量池中，并将其地址返回。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;	<span class="comment">// 编译期优化</span></span><br><span class="line">    <span class="comment">// 如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7);	<span class="comment">// false</span></span><br><span class="line">    <span class="comment">// intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">// 如果不存在，则在常量池中加载一份javaEEhadoop，并返回该对象的地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、字符串拼接的底层细节</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">    ④ s.toString();  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">   如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、拼接操作与 append 操作的效率对比</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    method1(<span class="number">100000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;method1: &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    method2(<span class="number">100000</span>);</span><br><span class="line">    end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;method1: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">method1</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        s += <span class="string">&quot;a&quot;</span>;   <span class="comment">// 每次循环都会创建一个StringBuilder、String对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">method2</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要创建一个StringBuilder对象</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method1: 8406</span><br><span class="line">method1: 3</span><br></pre></td></tr></table></figure>
<p>结论：通过StringBuilder的<code>append()</code>的方式添加字符串的效率要远高于使用String的字符串拼接方式。</p>
<p>原因：</p>
<ol>
<li>StringBuilder的<code>append()</code>的方式：自始至终中只创建过一个StringBuilder的对象。</li>
<li>使用String的字符串拼接方式：
<ul>
<li>创建过多个StringBuilder和String（调的toString方法）对象，内存占用更大；</li>
<li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li>
</ul>
</li>
</ol>
<p>改进的空间：</p>
<ul>
<li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化，可以避免频繁扩容：<code>StringBuilder s = new StringBuilder(highLevel);	// new char[highLevel]</code></li>
</ul>
<h2 id="5-new-string的说明"><a class="markdownIt-Anchor" href="#5-new-string的说明"></a> 5、new String()的说明</h2>
<p><strong>new String(“ab”)会创建几个对象？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>
<p><code>new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象。</p>
<p><code>ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）。</p>
<p>所以答案是1或2个。</p>
<p><strong>new String(“a”) + new String(“b”) 会创建几个对象？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，不会在字符串常量池中生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>
<p>答案是4个或5个或6个</p>
<h2 id="6-intern"><a class="markdownIt-Anchor" href="#6-intern"></a> 6、intern</h2>
<h3 id="61-intern的说明"><a class="markdownIt-Anchor" href="#61-intern的说明"></a> 6.1 intern()的说明</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native String intern();</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>intern是一个native方法，调用的是底层C的方法。</p>
</li>
<li>
<p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由<code>equals(object)</code>方法确定的与该字符串内容相等的字符串，则<font color='red'>返回池中的字符串地址</font>。否则，<font color='red'>该字符串对象将被添加到池中，并返回该字符串对象的地址</font>。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;I love u&quot;</span>).intern();</span><br></pre></td></tr></table></figure>
<p>intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中，并返回池中的字符串地址。</p>
</li>
<li>
<p>也就是说，如果在任意字符串上调用intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern() == <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p>
</li>
</ol>
<p><strong>有点难的面试题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();	<span class="comment">// 调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);	<span class="comment">// jdk6：false   jdk7/8：false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span></span><br><span class="line"><span class="comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span></span><br><span class="line"><span class="comment">           中存的是new String（&quot;11&quot;）在堆中的地址。</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);	<span class="comment">// pos_1</span></span><br><span class="line">        s3.intern();	<span class="comment">// 调用此方法前，字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">// s4变量记录的地址是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);   <span class="comment">// jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内存分析</strong></p>
<p>JDK6</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-2-24030182cc8d2063732221.png" alt="StringTable-2-240301" /></p>
<p>JDK7后</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-3-240301be03c9a8ed7bd239.png" alt="StringTable-3-240301" /></p>
<p><strong>拓展</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);	<span class="comment">// != new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">// 在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line">        System.out.println(s3 == s4);	<span class="comment">// false</span></span><br><span class="line">        System.out.println(s5 == s4);	<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;。</span></span><br><span class="line"><span class="comment">        2、jdk7/8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向s的地址，将此引用返回。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:true  jdk7/8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:false  jdk7/8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:true  jdk7/8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:false  jdk7/8:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>字符串对象调用intern方法时：</p>
<ul>
<li>jdk1.6中：
<ul>
<li>如果字符串常量池中有，不会放入，返回已有的字符串常量池中该字符串对象的地址。</li>
<li>如果没有，会把此字符串放入字符串常量池，并返回字符串常量池中该字符串对象的地址。</li>
</ul>
</li>
<li>Jdk1.7后：
<ul>
<li>如果字符串常量池中有，不会放入。返回已有的字符串常量池中该字符串对象的地址。</li>
<li>如果没有，会把<font color='red'>对象的引用地址复制一份</font>，放入字符串常量池，并返回<font color='red'>该引用地址</font>。</li>
</ul>
</li>
</ul>
<h3 id="62-intern的效率测试空间角度"><a class="markdownIt-Anchor" href="#62-intern的效率测试空间角度"></a> 6.2 intern()的效率测试（空间角度）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line">    Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">        arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存占用对比</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-4-240301ec35ae503cddb503.png" alt="StringTable-4-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-5-2403016ef5ab0a9f006641.png" alt="StringTable-5-240301" /></p>
<p><strong>结论</strong></p>
<ul>
<li>
<p>直接new String ：由于每个String对象都在堆分配内存，所以程序需要维护大量存放在堆空间中的String实例，程序内存占用也会变高。</p>
</li>
<li>
<p>使用<code>intern()</code>方法：由于数组中字符串的引用都<font color='red'>指向字符串常量池中的字符串</font>，所以程序需要维护的String对象更少，内存占用也更低。</p>
</li>
<li>
<p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用<code>intern()</code>方法能够节省很大的内存空间。</p>
</li>
<li>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用<code>intern()</code>方法，就会很明显降低内存的大小。</p>
</li>
</ul>
<h2 id="7-stringtable的垃圾回收"><a class="markdownIt-Anchor" href="#7-stringtable的垃圾回收"></a> 7、StringTable的垃圾回收</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<ul>
<li>在PSYoungGen区发生了垃圾回收。</li>
<li>Number of entries 和 Number of literals 明显没有增加100000。</li>
<li>以上两点均说明 StringTable 区发生了垃圾回收。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-StringTable-240301eb4c852331a3e830.png" alt="StringTable-StringTable的垃圾回收-240301" /></p>
<h2 id="8-g1中的string去重操作"><a class="markdownIt-Anchor" href="#8-g1中的string去重操作"></a> 8、G1中的String去重操作</h2>
<p><span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8xOTI=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>暂时了解一下，后面会详解垃圾回收器</p>
<p><strong>String去重操作的背景</strong></p>
<blockquote>
<p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p>
</blockquote>
<ol>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<font color='cornflowerblue'>Java堆中存活的数据集合差不多25%是String对象</font>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。<font color='cornflowerblue'>堆上存在重复的String对象必然是一种内存的浪费。</font>这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
</ol>
<p><strong>String 去重的的实现</strong></p>
<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<font color='cornflowerblue'>对每一个访问的对象都会检查是否是候选的要去重的String对象。</font></li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
<p><strong>命令行选项</strong></p>
<ol>
<li>UseStringDeduplication(bool) ：开启String去重，<font color='red'>默认是不开启的，需要手动开启。</font></li>
<li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息。</li>
<li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象。</li>
</ol>
<h1 id="十二-垃圾回收概述"><a class="markdownIt-Anchor" href="#十二-垃圾回收概述"></a> 十二、垃圾回收概述</h1>
<p><img src="https://img.picgo.net/2025/01/20/-1-240301ac54b076a6ad0594.png" alt="垃圾回收概述-1-240301" /></p>
<ol>
<li>Java 和 C<ins>语言的区别，就在于垃圾收集技术和内存动态分配上，C</ins>语言没有垃圾收集技术，需要程序员手动的收集。</li>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<font color='cornflowerblue'>极大地提高了开发效率</font>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是<font color='cornflowerblue'>面试的热点</font>。</li>
</ol>
<h2 id="1-大厂面试题"><a class="markdownIt-Anchor" href="#1-大厂面试题"></a> 1、大厂面试题</h2>
<p><strong>蚂蚁金服</strong></p>
<ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点。</li>
</ol>
<p><strong>百度</strong></p>
<ol>
<li>说一下GC算法，分代回收说下。</li>
<li>垃圾收集策略和算法。</li>
</ol>
<p><strong>天猫</strong></p>
<ol>
<li>JVM GC原理，JVM怎么回收内存。</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<p><strong>滴滴</strong></p>
<ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的。</li>
</ol>
<p><strong>京东</strong></p>
<ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1。</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理。</li>
</ol>
<p><strong>阿里</strong></p>
<ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<p><strong>字节跳动</strong></p>
<ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h2 id="2-什么是垃圾"><a class="markdownIt-Anchor" href="#2-什么是垃圾"></a> 2、什么是垃圾</h2>
<ol>
<li>
<p>垃圾是指<font color='red'>在运行程序中没有任何指针指向的对象</font>，这个对象就是需要被回收的垃圾。</p>
<p>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</p>
</li>
<li>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
</li>
</ol>
<h2 id="3-为什么需要gc"><a class="markdownIt-Anchor" href="#3-为什么需要gc"></a> 3、为什么需要GC？</h2>
<p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<font color='cornflowerblue'>内存迟早都会被消耗完</font>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<font color='cornflowerblue'>以便JVM将整理出的内存分配给新的对象</font>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<font color='cornflowerblue'>没有GC就不能保证应用程序的正常进行</font>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ol>
<h2 id="4-早期垃圾回收"><a class="markdownIt-Anchor" href="#4-早期垃圾回收"></a> 4、早期垃圾回收</h2>
<ul>
<li>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line"><span class="comment">// 如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;<span class="built_in">Register</span>(kDestroy) != NO ERROR)</span><br><span class="line">    <span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<font color='cornflowerblue'>频繁申请和释放内存的管理负担</font>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<font color='cornflowerblue'>内存泄漏</font>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<font color='cornflowerblue'>应用程序崩溃</font>.</p>
</li>
<li>
<p>有了垃圾回收机制后，上述代码极有可能变成这样：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>
<ul>
<li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li>
</ul>
<h2 id="5-java的垃圾回收机制"><a class="markdownIt-Anchor" href="#5-java的垃圾回收机制"></a> 5、Java的垃圾回收机制</h2>
<h3 id="51-自动内存管理"><a class="markdownIt-Anchor" href="#51-自动内存管理"></a> 5.1 自动内存管理</h3>
<blockquote>
<p><strong>官网介绍</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3RvYy5odG1s">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>自动内存管理的优点</strong></p>
<ul>
<li>
<p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样能<font color='red'>降低内存泄漏和内存溢出的风险。</font></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
</li>
<li>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，<font color='red'>可以更专心地专注于业务开发。</font></p>
</li>
</ul>
<p><strong>关于自动内存管理的担忧</strong></p>
<ul>
<li>
<p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<font color='cornflowerblue'>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</font></p>
</li>
<li>
<p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见<code>OutofMemoryError</code>时，快速地根据错误异常日志定位问题和解决问题。</p>
</li>
<li>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<font color='cornflowerblue'>实施必要的监控和调节。</font></p>
</li>
</ul>
<h3 id="52-应该关心哪些区域的回收"><a class="markdownIt-Anchor" href="#52-应该关心哪些区域的回收"></a> 5.2 应该关心哪些区域的回收？</h3>
<p><img src="https://img.picgo.net/2025/01/20/-GC-240301c032c54b76675b43.png" alt="垃圾回收概述-GC的作用区域-240301" /></p>
<ul>
<li>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。</p>
<ul>
<li>其中，<font color='red'>Java堆是垃圾收集器的工作重点。</font></li>
</ul>
</li>
<li>
<p>从次数上讲：</p>
<ul>
<li><font color='red'>频繁收集Young区</font></li>
<li><font color='red'>较少收集Old区</font></li>
<li><font color='red'>基本不收集Perm区（元空间）</font></li>
</ul>
</li>
</ul>
<h1 id="十三-垃圾回收相关算法"><a class="markdownIt-Anchor" href="#十三-垃圾回收相关算法"></a> 十三、垃圾回收相关算法</h1>
<h2 id="1-标记阶段"><a class="markdownIt-Anchor" href="#1-标记阶段"></a> 1、标记阶段</h2>
<h3 id="11-标记阶段的目的"><a class="markdownIt-Anchor" href="#11-标记阶段的目的"></a> 1.1 标记阶段的目的</h3>
<p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<font color='cornflowerblue'>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</font>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<font color='cornflowerblue'>垃圾标记阶段</font>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：<font color='red'>引用计数算法</font>和<font color='red'>可达性分析算法</font>。</li>
</ul>
<h3 id="12-引用计数算法"><a class="markdownIt-Anchor" href="#12-引用计数算法"></a> 1.2 引用计数算法</h3>
<ul>
<li>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<font color='red'>引用计数器属性，用于记录对象被引用的情况。</font></p>
</li>
<li>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
</li>
<li>
<p>优点：<font color='cornflowerblue'>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</font></p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<font color='cornflowerblue'>存储空间的开销</font>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<font color='cornflowerblue'>时间开销</font>。</li>
<li>引用计数器有一个严重的问题，即<font color='red'>无法处理循环引用</font>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--24030128740784a89f4b6e.png" alt="垃圾回收概述-循环引用-240301" /></p>
<p>当p的指针断开的时候，内部的引用形成一个循环，计数器都为1，无法被回收，这就是循环引用，从而造成内存泄漏。</p>
<p><strong>证明：java使用的不是引用计数算法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">// 这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];	<span class="comment">// 5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.picgo.net/2025/01/20/-2-240301e3f30ff5192ca9e6.png" alt="垃圾回收概述-2-240301" /></p>
<p><strong>执行结果</strong></p>
<ul>
<li>
<p>没有进行GC时（注释<code>System.gc()</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 12841K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 19% used [0x000000076b780000,0x000000076c40a578,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line"> ParOldGen       total 173568K, used 0K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2600000,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2629K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进行GC后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;672K(75776K)] 11540K-&gt;680K(249344K), 0.0348225 secs] [Times: user=0.00 sys=0.00, real=0.04 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 672K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;519K(173568K)] 680K-&gt;519K(249344K), [Metaspace: 2623K-&gt;2623K(1056768K)], 0.0038984 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 519K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2681ed8,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>结论</strong></p>
<ol>
<li>从打印日志就可以明显看出来，已经进行了GC。</li>
<li>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</li>
</ol>
<p><strong>小结</strong></p>
<ol>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用？
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ol>
<h3 id="13-可达性分析算法"><a class="markdownIt-Anchor" href="#13-可达性分析算法"></a> 1.3 可达性分析算法</h3>
<p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p>
<ul>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决<font color='cornflowerblue'>在引用计数算法中循环引用的问题，防止内存泄漏的发生</font>。</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<font color='cornflowerblue'>追踪性垃圾收集</font>（Tracing Garbage Collection）</li>
</ul>
<p><strong>可达性分析实现思路</strong></p>
<ul>
<li>所谓&quot;GC Roots”根集合就是一组必须活跃的引用。</li>
<li>思路如下：
<ul>
<li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<font color='cornflowerblue'>搜索被根对象集合所连接的目标对象是否可达</font>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<font color='cornflowerblue'>引用链</font>（Reference Chain）。</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301e0d32be041e67917.png" alt="垃圾回收概述-可达性分析算法-240301" /></p>
<p><strong>在Java语言中，GC Roots包括以下几类元素：</strong></p>
<ol>
<li>虚拟机栈中引用的对象。
<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象。</li>
<li>方法区中类静态属性引用的对象。
<ul>
<li>比如：Java类的引用类型静态变量。</li>
</ul>
</li>
<li>方法区中常量引用的对象。
<ul>
<li>比如：字符串常量池（StringTable）里的引用。</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象。</li>
<li>Java虚拟机内部的引用。
<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：<code>NullPointerException</code>、<code>OutofMemoryError</code>），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-3-24030164ed2335f156dc4c.png" alt="垃圾回收概述-3-240301" /></p>
<ul>
<li>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li>
<p>小技巧</p>
<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<font color='red'>枚举根节点时也是必须要停顿的</font>。</li>
</ol>
<h3 id="14-对象的-finalization-机制"><a class="markdownIt-Anchor" href="#14-对象的-finalization-机制"></a> 1.4 对象的 finalization 机制</h3>
<p><strong>对象销毁前的回调函数：finalize()</strong></p>
<ol>
<li>
<p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<font color='cornflowerblue'>对象被销毁之前的自定义处理逻辑</font>。</p>
</li>
<li>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的<code>finalize()</code>方法。</p>
</li>
<li>
<p><code>finalize()</code>方法允许在子类中被重写，<font color='cornflowerblue'>用于在对象被回收时进行资源释放</font>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li>
<p>永远不要主动调用某个对象的<code>finalize()</code>方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>
<p>调用<code>finalize()</code>时可能会导致对象复活。</p>
</li>
<li>
<p><code>finalize()</code>方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则<code>finalize()</code>方法将没有执行机会。</p>
</li>
<li>
<p>一个糟糕的<code>finalize()</code>会严重影响GC的性能。比如finalize是个死循环。</p>
</li>
</ul>
</li>
<li>
<p>从功能上来说，finalize()方法与C<ins>中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以<code>finalize()</code>方法在本质上不同于C</ins>中的析构函数。</p>
</li>
<li>
<p><code>finalize()</code>方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收。</p>
</li>
</ol>
<p><strong>生存还是死亡？</strong></p>
<p>由于finalize()方法的存在，<font color='cornflowerblue'>虚拟机中的对象一般处于三种可能的状态</font>。</p>
<ul>
<li>
<p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<font color='red'>一个无法触及的对象有可能在某一个条件下“复活”自己</font>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><font color='red'>可触及的</font>：从根节点开始，可以到达这个对象。</li>
<li><font color='red'>可复活的</font>：对象的所有引用都被释放，但是对象有可能在<code>finalize()</code>中复活。</li>
<li><font color='red'>不可触及的</font>：对象的<code>finalize()</code>被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<font color='red'>因为<code>finalize()</code>只会被调用一次</font>。</li>
</ul>
</li>
<li>
<p>以上3种状态中，是由于<code>finalize()</code>方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</li>
</ul>
<p><strong>具体过程</strong></p>
<p>判定一个对象<code>objA</code>是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>
<p>如果对象<code>objA</code>到GC Roots没有引用链，则进行第一次标记。</p>
</li>
<li>
<p>进行筛选，判断此对象是否有必要执行<code>finalize()</code>方法：</p>
<ul>
<li>
<p>如果对象objA没有重写<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，<code>objA</code>被判定为不可触及的。</p>
</li>
<li>
<p>如果对象<code>objA</code>重写了<code>finalize()</code>方法，且还未执行过，那么<code>objA</code>会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其<code>finalize()</code>方法执行。</p>
</li>
<li>
<p><font color='red'><code>finalize()</code>方法是对象逃脱死亡的最后机会</font>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果<code>objA</code>在<code>finalize()</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，<code>objA</code>会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，<code>finalize()</code>方法不会被再次调用，对象会直接变成不可触及的状态。也就是说，一个对象的<code>finalize()</code>方法只会被调用一次。</p>
</li>
</ul>
</li>
</ol>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj; <span class="comment">// 类变量，属于 GC Roots</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;override finalize()&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>; <span class="comment">// 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();    <span class="comment">// 调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;first gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为 Finalizer 线程优先级很低，暂停 2 秒，等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;second gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first gc</span><br><span class="line">override finalize()</span><br><span class="line">obj is still alive</span><br><span class="line">second gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不重写<code>finalize()</code>方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first gc</span><br><span class="line">obj is dead</span><br><span class="line">second gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>
<h3 id="15-使用mat查看gc-roots"><a class="markdownIt-Anchor" href="#15-使用mat查看gc-roots"></a> 1.5 使用MAT查看GC Roots</h3>
<p><strong>MAT介绍</strong></p>
<ol>
<li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li>
<li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li>
<li>可以在<span class="exturl" data-url="aHR0cDovL3d3dy5lY2xpcHNlLm9yZy9tYXQ=">http://www.eclipse.org/mat<i class="fa fa-external-link-alt"></i></span>下载并使用MAT。</li>
</ol>
<blockquote>
<p>虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些。</p>
<p>此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件。</p>
</blockquote>
<p><strong>获取dump文件方式</strong></p>
<p><strong>方式一：命令行使用 jmap</strong></p>
<p><code>jmap -dump:format=b,live,file=文件名 [pid]</code></p>
<p><img src="https://img.picgo.net/2025/01/20/-jmap-2403013709399f3fae8ec4.png" alt="垃圾回收概述-jmap-240301" /></p>
<p><strong>方式二：使用JVisualVM</strong></p>
<ol>
<li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。</li>
<li>可通过以下方法捕获heap dump：
<ul>
<li>在左侧“Application”(应用程序）子窗口中右击相应的应用程序，选择Heap Dump(堆Dump) 。</li>
<li>在Monitor(监视）子标签页中点击Heap Dump(堆Dump）按钮。</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application(应用程序）栏中对应一个含有时间戳的节点。右击这个节点选择save as（另存为）即可将heap dump保存到本地。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-4-240301744f286f6255b604.png" alt="垃圾回收概述-4-240301" /></p>
<p><strong>捕捉 dump 示例</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>numList</code>和<code>birth</code>在第一次捕捉内存快照的时候，为 GC Roots。</li>
<li>之后<code>numList</code>和<code>birth</code>置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots。</li>
</ul>
<p><strong>使用MAT查看GC Roots</strong></p>
<ol>
<li>使用MAT打开 dump文件；</li>
<li>查看GCRoots</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-5-2403013919c3aacd5efb86.png" alt="垃圾回收概述-5-240301" /></p>
<p>打开第一个dump文件，即第一次捕捉的内存快照，GC Roots 中包含参数<code>args</code>和定义的两个局部变量，类型分别为<code>ArrayList</code>和<code>Date</code>，Total entries = 21。</p>
<p><img src="https://img.picgo.net/2025/01/20/-6-2403013869e935a9a4f3db.png" alt="垃圾回收概述-6-240301" /></p>
<p>打开第二个dump文件，即第二次捕捉的内存快照，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total entries = 19 也可以看出（少了两个 GC Roots）。</p>
<p><img src="https://img.picgo.net/2025/01/20/-7-240301436c5959dafe79df.png" alt="垃圾回收概述-7-240301" /></p>
<h3 id="16-使用jprofiler进行gc-roots溯源"><a class="markdownIt-Anchor" href="#16-使用jprofiler进行gc-roots溯源"></a> 1.6 使用JProfiler进行GC Roots溯源</h3>
<p>在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<font color='cornflowerblue'>GC Roots溯源。</font></p>
<p><img src="https://img.picgo.net/2025/01/20/-8-2403011badc5e7b90e76a5.png" alt="垃圾回收概述-8-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-9-240301064a35724942d310.png" alt="垃圾回收概述-9-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-10-2403019249f018346ca410.png" alt="垃圾回收概述-10-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-11-240301fb33fb3b9eca609f.png" alt="垃圾回收概述-11-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-12-240301544cc76c448366ab.png" alt="垃圾回收概述-12-240301" /></p>
<h3 id="17-使用jprofiler监控oom"><a class="markdownIt-Anchor" href="#17-使用jprofiler监控oom"></a> 1.7 使用JProfiler监控OOM</h3>
<blockquote>
<p>这里是简单的讲一下，后面篇章会详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];	<span class="comment">// 1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用JProfiler打开生成的dump文件，并查看其中的最大对象。</p>
<p><img src="https://img.picgo.net/2025/01/20/-13-240301bb3131d5bfa9ac90.png" alt="垃圾回收概述-13-240301" /></p>
<p>可以看到，ArrayList 是超大对象，占据了内存 89%的空间。</p>
<p><img src="https://img.picgo.net/2025/01/20/-14-240301e9da4fb49e94651d.png" alt="垃圾回收概述-14-240301" /></p>
<p>选择左边的线程选项，还可以看到是哪个线程出现了问题，然后定位到代码的行数。</p>
<p><img src="https://img.picgo.net/2025/01/20/-15-240301ee2cd69eb4bd6c54.png" alt="垃圾回收概述-15-240301" /></p>
<h2 id="2-清除阶段"><a class="markdownIt-Anchor" href="#2-清除阶段"></a> 2、清除阶段</h2>
<h3 id="21-垃圾清除阶段"><a class="markdownIt-Anchor" href="#21-垃圾清除阶段"></a> 2.1 垃圾清除阶段</h3>
<p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是：</p>
<ul>
<li>
<p>标记-清除算法（Mark-Sweep）</p>
</li>
<li>
<p>复制算法（Copying）</p>
</li>
<li>
<p>标记-压缩算法（Mark-Compact）</p>
</li>
</ul>
<h3 id="22-标记-清除算法"><a class="markdownIt-Anchor" href="#22-标记-清除算法"></a> 2.2 标记-清除算法</h3>
<p><strong>背景</strong></p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p><strong>执行过程</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>
<p><font color='cornflowerblue'>标记</font>：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<ul>
<li>注意：<font color='red'>标记的是被引用的对象，也就是可达对象，并非即将被清除的垃圾对象。</font></li>
</ul>
</li>
<li>
<p><font color='cornflowerblue'>清除</font>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/---24030175e497cbf0609d3f.png" alt="垃圾回收概述-标记-清除算法-240301" /></p>
<p><strong>缺点</strong></p>
<ol>
<li>标记清除算法的效率不算高。</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差。</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表。</li>
</ol>
<p><strong>注意：何为清除？</strong></p>
<ul>
<li>
<p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p>
<blockquote>
<p>关于空闲列表是在为对象分配内存的时候提过：</p>
<p>如果内存规整：采用指针碰撞的方式进行内存分配。</p>
<p>如果内存不规整：虚拟机需要维护一个空闲列表，采用空闲列表分配内存。</p>
</blockquote>
</li>
</ul>
<h3 id="23-复制算法"><a class="markdownIt-Anchor" href="#23-复制算法"></a> 2.3 复制算法</h3>
<p><strong>背景</strong></p>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器（CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<p><strong>核心思想</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/--240301f5469e2b20023571.png" alt="垃圾回收概述-复制算法-240301" /></p>
<p><strong>优点</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效。</li>
<li>复制过去以后保证<font color='red'>空间的连续性</font>，不会出现“碎片”问题。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<p><strong>特别的</strong></p>
<ul>
<li>如果系统中的垃圾对象很多，复制算法就不会很理想。复制算法适合<font color='red'>需要复制的存活对象数量不会太多</font>，或者说非常低才行。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收 70%-90% 的内存空间，回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-16-2403014ac3d186f1564cb8.png" alt="垃圾回收概述-16-240301" /></p>
<h3 id="24-标记-压缩整理算法"><a class="markdownIt-Anchor" href="#24-标记-压缩整理算法"></a> 2.4 标记-压缩（整理）算法</h3>
<p><strong>背景</strong></p>
<p>​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<font color='red'>基于老年代垃圾回收的特性，需要使用其他的算法。</font></p>
<p>​	标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark - Compact）算法由此诞生。</p>
<p>​	1970年前后，G. L. steele 、C. J. Chene和D.S. Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<p><strong>执行过程</strong></p>
<ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象；</li>
<li>第二阶段将所有的存活对象压缩到内存的一段，按顺序排放；</li>
<li>之后，清理边界外所有的空间。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/---240301908b695495c8baa1.png" alt="垃圾回收概述-标记-压缩算法-240301" /></p>
<p><strong>标记-压缩算法与标记-清除算法的比较</strong></p>
<ol>
<li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li>
<li>二者的本质差异在于标记-清除算法是一种<font color='cornflowerblue'>非移动式的回收算法</font>，标记-压缩是<font color='cornflowerblue'>移动式</font>的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>
<p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</p>
</li>
<li>
<p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p>从效率上来说，标记-整理算法要低于复制算法。</p>
</li>
<li>
<p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）。</p>
</li>
<li>
<p>移动过程中，需要全程暂停用户应用程序，即：STW。</p>
</li>
</ul>
<h3 id="25-小结三种算法对比"><a class="markdownIt-Anchor" href="#25-小结三种算法对比"></a> 2.5 小结（三种算法对比）</h3>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h3 id="26-分代收集算法"><a class="markdownIt-Anchor" href="#26-分代收集算法"></a> 2.6 分代收集算法</h3>
<p>​	前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>​	分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，<font color='cornflowerblue'>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</font>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>​	在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<font color='cornflowerblue'>Http请求中的session对象、线程、socket连接</font>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如: String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><font color='cornflowerblue'>目前几乎所有的 GC 都是采用分代收集（Generational collecting）算法执行垃圾回收的。</font></p>
<p>在Hotspot中，基于分代的概念，cc所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>
<p>年轻代（Young Gen）</p>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
</li>
<li>
<p>老年代（Tenured Gen）</p>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
<p>​	以HotSpot中的 CMS 回收器为例，CMS 是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure时)，将采用 Serial Old执行Full GC 以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h3 id="27-增量收集算法"><a class="markdownIt-Anchor" href="#27-增量收集算法"></a> 2.7 增量收集算法</h3>
<p>​	上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<font color='cornflowerblue'>Stop the World</font>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<font color='cornflowerblue'>将严重影响用户体验或者系统的稳定性。</font>为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p><strong>基本思想</strong></p>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<font color='cornflowerblue'>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</font></li>
<li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<font color='red'>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</font></li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<font color='cornflowerblue'>造成系统吞吐量的下降</font>。</li>
</ul>
<h3 id="28-分区算法"><a class="markdownIt-Anchor" href="#28-分区算法"></a> 2.8 分区算法</h3>
<p>​	一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>​	分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://img.picgo.net/2025/01/20/--24030103f7f06532fbe875.png" alt="垃圾回收概述-分区算法-240301" /></p>
<h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2>
<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<h1 id="十四-垃圾回收相关概念"><a class="markdownIt-Anchor" href="#十四-垃圾回收相关概念"></a> 十四、垃圾回收相关概念</h1>
<h2 id="1-systemgc-的理解"><a class="markdownIt-Anchor" href="#1-systemgc-的理解"></a> 1、System.gc() 的理解</h2>
<ul>
<li>
<p>在默认情况下，通过<code>System.gc()</code>者<code>Runtime.getRuntime().gc()</code>的调用，<font color='cornflowerblue'>会显式触发Full GC</font>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li>
<p>然而<code>System.gc()</code>调用附带一个免责声明，无法保证对垃圾收集器的调用（不能确保立即生效）。</p>
</li>
<li>
<p>JVM实现者可以通过<code>System.gc()</code>调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<font color='cornflowerblue'>无须手动触发，否则就太过于麻烦了</font>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用<code>System.gc()</code>。</p>
</li>
</ul>
<h3 id="11-代码示例手动执行-gc-操作"><a class="markdownIt-Anchor" href="#11-代码示例手动执行-gc-操作"></a> 1.1 代码示例：手动执行 GC 操作</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();    <span class="comment">// 提醒jvm的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生了GC，这个finalize()一定会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest finalize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果不确定：有时候会调用 finalize() 方法，有时候不会调用。</p>
<p>可以使用<code>System.runFinalization()</code>来强制调用失去引用对象的<code>finalize()</code>方法。</p>
<h3 id="12-手动-gc-理解不可达对象的回收行为"><a class="markdownIt-Anchor" href="#12-手动-gc-理解不可达对象的回收行为"></a> 1.2 手动 GC 理解不可达对象的回收行为</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localVarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        <span class="comment">// 通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        local.localVarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：-XX:+PrintGCDetails</li>
</ul>
<p><strong>调用<code>localVarGC1()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10736K(75776K)] 11540K-&gt;10904K(249344K), 0.0059694 secs] [Times: user=0.03 sys=0.02, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(75776K)] [ParOldGen: 168K-&gt;10760K(173568K)] 10904K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0041345 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 10760K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 6% used [0x00000006c2600000,0x00000006c3082250,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>执行<code>System.gc()</code>仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象并不会被回收。</p>
<p><strong>调用<code>localVarGC2()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;768K(75776K)] 11540K-&gt;776K(249344K), 0.0007120 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 768K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;520K(173568K)] 776K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0044018 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>由于 buffer 数组对象没有引用指向它，执行<code>System.gc()</code>将被回收。</p>
<p><strong>调用<code>localVarGC3()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10720K(75776K)] 11540K-&gt;10888K(249344K), 0.0056072 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10720K-&gt;0K(75776K)] [ParOldGen: 168K-&gt;10760K(173568K)] 10888K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0040429 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 10760K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 6% used [0x00000006c2600000,0x00000006c3082250,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收。</p>
<p>查看字节码：</p>
<p><img src="https://img.picgo.net/2025/01/20/-17-24030101d31e50e6761db7.png" alt="垃圾回收概述-17-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-18-2403016890fef7da6de304.png" alt="垃圾回收概述-18-240301" /></p>
<p>可以看到局部变量表的大小是 2，但是局部变量表里只有一个索引为0变量，那索引为1去哪了呢？实际上索引为1的位置是 buffer 的引用在占用着，所以没有进行GC。</p>
<p><strong>调用<code>localVarGC4()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;736K(75776K)] 11540K-&gt;744K(249344K), 0.0008649 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 736K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;520K(173568K)] 744K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0038737 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>这时 buffer 数组对象就被回收了。为什么多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p>
<p>因为局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行<code>System.gc()</code>时就会被回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/-19-24030182599a2921b13d29.png" alt="垃圾回收概述-19-240301" /></p>
<p><strong>调用<code>localVarGC5()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10736K(75776K)] 11540K-&gt;10920K(249344K), 0.0054120 secs] [Times: user=0.11 sys=0.02, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(75776K)] [ParOldGen: 184K-&gt;10760K(173568K)] 10920K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0060036 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(75776K)] 10760K-&gt;10760K(249344K), 0.0003260 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(75776K)] [ParOldGen: 10760K-&gt;520K(173568K)] 10760K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0040308 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2631K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>局部变量出了方法范围就失效了，堆中的 buffer 数组对象一定会被回收。</p>
<h2 id="2-内存溢出与内存泄漏"><a class="markdownIt-Anchor" href="#2-内存溢出与内存泄漏"></a> 2、内存溢出与内存泄漏</h2>
<h3 id="21-内存溢出oom"><a class="markdownIt-Anchor" href="#21-内存溢出oom"></a> 2.1 内存溢出（OOM）</h3>
<ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
<li>由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li>
<li>Javadoc中对<code>OutOfMemoryError</code>的解释是，<font color='cornflowerblue'>没有空闲内存，并且垃圾收集器也无法提供更多内存。</font></li>
<li>这里面隐含着一层意思是，在抛出<code>OutOfMemoryError</code>之前，通常垃圾收集器会被触发，尽其所能去清理出空间。
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试<font color='red'>回收软引用指向的对象</font>等。</li>
<li>在<code>java.nio.Bits.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发的。
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出<code>OutOfMemoryError</code>。</li>
</ul>
</li>
</ul>
<p><strong>内存溢出原因分析</strong></p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够。
<ul>
<li>可能存在内存泄漏问题，很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code>、<code>-Xmx</code>来调整。</li>
</ul>
</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
<ul>
<li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：<code>java.lang.OutOfMemoryError:PermGen space</code>。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：<code>java.lang.OutofMemoryError:Metaspace</code>。直接内存不足，也会导致OOM。</li>
</ul>
</li>
</ol>
<h3 id="22-内存泄漏memory-leak"><a class="markdownIt-Anchor" href="#22-内存泄漏memory-leak"></a> 2.2 内存泄漏（Memory Leak）</h3>
<ul>
<li>
<p>也称作“存储渗漏”。严格来说，<font color='red'>只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏。</font></p>
</li>
<li>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<font color='cornflowerblue'>宽泛意义上的“内存泄漏”</font>。</p>
</li>
<li>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现<code>OutOfMemory</code>异常，导致程序崩溃。</p>
</li>
<li>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
</li>
</ul>
<p><strong>内存泄露例子</strong></p>
<p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p>
<p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/--2403012fb2e63f510090e7.png" alt="垃圾回收概述-内存泄漏-240301" /></p>
<p><strong>常见例子</strong></p>
<ol>
<li>单例模式
<ul>
<li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果<font color='red'>持有对外部对象的引用的话</font>，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li>
</ul>
</li>
<li>一些提供<code>close()</code>的资源未关闭导致内存泄漏
<ul>
<li>数据库连接<code>dataSourse.getConnection()</code>，网络连接socket和io连接必须手动close，否则是不能被回收的。</li>
</ul>
</li>
</ol>
<h2 id="3-stop-the-world"><a class="markdownIt-Anchor" href="#3-stop-the-world"></a> 3、Stop the World</h2>
<ul>
<li>
<p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<font color='cornflowerblue'>停顿产生时整个应用程序线程都会被暂停，没有任何响应</font>，有点像卡死的感觉，这个停顿称为STW。</p>
<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所Java执行线程呢？
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><font color='cornflowerblue'>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</font></li>
</ul>
</li>
</ul>
</li>
<li>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</li>
<li>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li>
<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li>
<p>STW是JVM在<font color='cornflowerblue'>后台自动发起和自动完成</font>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li>
<p>开发中不要用<code>System.gc()</code> ，这会导致Stop-the-World的发生。</p>
</li>
</ul>
<p><strong>代码感受 Stop the World</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (list.size() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();    <span class="comment">// 会触发full gc，进而会出现STW事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    startTime = System.currentTimeMillis();</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭线程 w ，观察输出：基本是每隔1秒打印一次：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>开启线程 w ，观察输出：时间间隔明显大于1秒 ，可以明显感受到 Stop the World 的存在：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.2</span><br><span class="line">1.1</span><br><span class="line">1.4</span><br><span class="line">1.2</span><br></pre></td></tr></table></figure>
<h2 id="4-垃圾回收的并行与并发"><a class="markdownIt-Anchor" href="#4-垃圾回收的并行与并发"></a> 4、 垃圾回收的并行与并发</h2>
<h3 id="41-并发的概念"><a class="markdownIt-Anchor" href="#41-并发的概念"></a> 4.1 并发的概念</h3>
<ul>
<li>
<p>在操作系统中，是指<font color='cornflowerblue'>一个时间段</font>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
</li>
<li>
<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--24030180b40edfe5511b5b.png" alt="垃圾回收概述-并发-240301" /></p>
<h3 id="42-并行的概念"><a class="markdownIt-Anchor" href="#42-并行的概念"></a> 4.2 并行的概念</h3>
<ul>
<li>
<p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<font color='cornflowerblue'>同时</font>进行，我们称之为并行（Parallel）。</p>
</li>
<li>
<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
</li>
<li>
<p>适合科学计算，后台处理等弱交互场景。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301bfb6932cd7d29fbc.png" alt="垃圾回收概述-并行-240301" /></p>
<p><strong>并发与并行的对比</strong></p>
<ol>
<li>并发，指的是多个事情，<font color='red'>在同一时间段内同时发生了。</font></li>
<li>并行，指的是多个事情，<font color='red'>在同一时间点上（或者说同一时刻）同时发生了。</font></li>
<li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li>
</ol>
<h3 id="43-垃圾回收的并发与并行"><a class="markdownIt-Anchor" href="#43-垃圾回收的并发与并行"></a> 4.3 垃圾回收的并发与并行</h3>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ol>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
<ul>
<li>如ParNew、Parallel Scavenge、Parallel Old。</li>
</ul>
</li>
<li>串行（Serial）
<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）。</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-20-2403011f422600aef81d1a.png" alt="垃圾回收概述-20-240301" /></p>
<ol start="3">
<li>并发（Concurrent）：指<font color='cornflowerblue'>用户线程与垃圾收集线程同时执行</font>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。
<ul>
<li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上。</li>
<li>如CMS、G1。</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png" alt="垃圾回收概述-21-240301" /></p>
<h2 id="5-安全点与安全区域"><a class="markdownIt-Anchor" href="#5-安全点与安全区域"></a> 5、安全点与安全区域</h2>
<h3 id="51-安全点safe-point"><a class="markdownIt-Anchor" href="#51-安全点safe-point"></a> 5.1 安全点（Safe Point）</h3>
<ul>
<li>
<p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safe Point）”。</p>
</li>
<li>
<p>Safe Point的选择很重要，<font color='cornflowerblue'>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</font>。大部分指令的执行时间都非常短暂，通常会根据“<font color='red'>是否具有让程序长时间执行的特征</font>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<font color='cornflowerblue'>如方法调用、循环跳转和异常跳转等</font>。</p>
</li>
</ul>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p>
<ol>
<li>抢先式中断：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点，目前没有虚拟机采用了。</li>
<li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<font color='cornflowerblue'>主动轮询</font>这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ol>
<h3 id="52-安全区域safe-region"><a class="markdownIt-Anchor" href="#52-安全区域safe-region"></a> 5.2 安全区域（Safe Region）</h3>
<ul>
<li>
<p>Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
</li>
<li>
<p><font color='cornflowerblue'>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</font>。我们也可以把Safe Region看做是被扩展了的Safe Point。</p>
</li>
</ul>
<p><strong>安全区域的执行流程</strong></p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</li>
</ol>
<h2 id="6-再谈引用"><a class="markdownIt-Anchor" href="#6-再谈引用"></a> 6、再谈引用</h2>
<ul>
<li>
<p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
</li>
<li>
<p>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
</li>
<li>
<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p><font color='red'>这四种引用的强度依次减弱。</font></p>
</li>
<li>
<p>除强引用外，其他3种引用均可以在<code>java.lang.ref</code>包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
</li>
</ul>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。</p>
<ol>
<li>强引用（Strong Reference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj = new Object()</code>”这种引用关系。<font color='red'>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用。</font></li>
<li>软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行<font color='red'>第二次回收</font>。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<font color='red'>无论内存空间是否足够，都会回收掉被弱引用关联的对象。</font></li>
<li>虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<font color='red'>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</font></li>
</ol>
<h3 id="61-强引用"><a class="markdownIt-Anchor" href="#61-强引用"></a> 6.1 强引用</h3>
<p><strong>强引用（Strong Reference）：不回收</strong></p>
<ul>
<li>
<p>在Java程序中，最常见的引用类型是强引用<font color='cornflowerblue'>（普通系统99%以上都是强引用）</font>，也就是我们最常见的普通对象引用，<font color='cornflowerblue'>也是默认的引用类型</font>。</p>
</li>
<li>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
</li>
<li>
<p><font color='red'>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</font>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p>
</li>
<li>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<font color='cornflowerblue'>强引用是造成Java内存泄漏的主要原因之一。</font></p>
</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br><span class="line"></span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用。对应内存结构：</p>
<p><img src="https://img.picgo.net/2025/01/23/220af395fff51614a8.png" alt="垃圾回收概述-22-240301" /></p>
<p><strong>总结</strong></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ol>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ol>
<h3 id="62-软引用"><a class="markdownIt-Anchor" href="#62-软引用"></a> 6.2 软引用</h3>
<p><strong>软引用（Soft Reference）：内存不足即回收</strong></p>
<ul>
<li>
<p>软引用是用来描述一些还有用，但非必需的对象。<font color='cornflowerblue'>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</font>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象。</p>
</li>
<li>
<p>软引用通常用来实现内存敏感的缓存。比如：<font color='cornflowerblue'>高速缓存</font>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
</li>
<li>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</li>
<li>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象。</p>
</li>
<li>
<p>在JDK1.2之后提供了<code>SoftReference</code>类来实现软引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object();// 声明强引用</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = null; // 销毁强引用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SoftReference&lt;<span class="type">byte</span>[]&gt; b = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象，建立软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Gerrit&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">// 垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());  <span class="comment">// 由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让系统认为内存资源紧张、不够</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());  <span class="comment">// 内存不够时，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code></li>
</ul>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[id=1, name=Gerrit] </span><br><span class="line">---目前内存还不紧张---</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 781K-&gt;480K(2560K)] 5901K-&gt;5736K(9728K), 0.0005133 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 5256K-&gt;5641K(7168K)] 5736K-&gt;5641K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0037990 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">After GC:</span><br><span class="line">[id=1, name=Gerrit] </span><br><span class="line">---下面开始内存紧张了---</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 40K-&gt;64K(2560K)] 5682K-&gt;5705K(9728K), 0.0001904 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 64K-&gt;32K(2560K)] 5705K-&gt;5673K(9728K), 0.0002144 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 32K-&gt;0K(2560K)] [ParOldGen: 5641K-&gt;5641K(7168K)] 5673K-&gt;5641K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0015773 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5641K-&gt;5641K(9728K), 0.0002950 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5641K-&gt;509K(7168K)] 5641K-&gt;509K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0038927 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] </span><br><span class="line">null</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 41K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0a5a8,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 3581K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 49% used [0x00000000ff600000,0x00000000ff97f6f8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 2638K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到在JVM内存不足时，会回收软引用对象。</p>
<h3 id="63-弱引用"><a class="markdownIt-Anchor" href="#63-弱引用"></a> 6.3 弱引用</h3>
<p><strong>弱引用（Weak Reference）：发现即回收</strong></p>
<ul>
<li>
<p>弱引用也是用来描述那些非必需对象，<font color='cornflowerblue'>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</font>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
</li>
<li>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
</li>
<li>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li>
<p><font color='cornflowerblue'>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</font>如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
</li>
<li>
<p>在JDK1.2之后提供了<code>WeakReference</code>类来实现弱引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。<font color='cornflowerblue'>弱引用对象更容易、更快被GC回收。</font></p>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Gerrit&quot;</span>));</span><br><span class="line">        <span class="comment">// 从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">// 重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[id=1, name=Gerrit]</span><br><span class="line">After GC:</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>执行垃圾回收后，弱引用对象必定被回收。</p>
<h3 id="64-虚引用"><a class="markdownIt-Anchor" href="#64-虚引用"></a> 6.4 虚引用</h3>
<p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p>
<ul>
<li>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
</li>
<li>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</li>
<li>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的<code>get()</code>方法取得对象时，总是null 。<font color='cornflowerblue'>即通过虚引用无法获取到我们的数据。</font></p>
</li>
<li>
<p><font color='cornflowerblue'>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</font></p>
</li>
<li>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li>
<p><font color='cornflowerblue'>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</font></p>
</li>
<li>
<p>在JDK1.2之后提供了PhantomReference类来实现虚引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj; <span class="comment">// 当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;    <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">// finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);  <span class="comment">// 设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">// 构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;第 1 次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();    <span class="comment">// 一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第 1 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 2 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 null</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ol>
<li>
<p>第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收。</p>
</li>
<li>
<p>第二次调用GC的时候，因为finalize方法只能执行一次，所以将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p>
</li>
</ol>
<h3 id="65-终结器引用"><a class="markdownIt-Anchor" href="#65-终结器引用"></a> 6.5 终结器引用</h3>
<ul>
<li>
<p>它用于实现对象的<code>finalize()</code>方法，也可以称为终结器引用。</p>
</li>
<li>
<p>无需手动编码，其内部配合引用队列使用。</p>
</li>
<li>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的<code>finalize()</code>方法，第二次GC时才回收被引用的对象。</p>
</li>
</ul>
<h1 id="十五-垃圾回收器"><a class="markdownIt-Anchor" href="#十五-垃圾回收器"></a> 十五、垃圾回收器</h1>
<h2 id="1-gc-分类与性能指标"><a class="markdownIt-Anchor" href="#1-gc-分类与性能指标"></a> 1、GC 分类与性能指标</h2>
<h3 id="11-垃圾回收器概述"><a class="markdownIt-Anchor" href="#11-垃圾回收器概述"></a> 1.1 垃圾回收器概述</h3>
<ul>
<li>
<p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
</li>
<li>
<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>
</li>
<li>
<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
</li>
</ul>
<p><strong>Java不同版本新特性</strong></p>
<ol>
<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型等。</li>
<li>API层面：Stream API、新的日期时间、Optional、String、集合框架等。</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等。</li>
</ol>
<h3 id="12-垃圾回收器分类"><a class="markdownIt-Anchor" href="#12-垃圾回收器分类"></a> 1.2 垃圾回收器分类</h3>
<ol>
<li>按<font color='cornflowerblue'>线程数</font>分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-1-240301337a8c0cf7684c92.png" alt="垃圾回收器-1-240301" /></p>
<ul>
<li>
<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>
<p>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<font color='cornflowerblue'>串行回收默认被应用在客户端的Client模式下的JVM中。</font></p>
</li>
<li>
<p>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</p>
</li>
</ul>
</li>
<li>
<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
</li>
</ul>
<ol start="2">
<li>按照<font color='cornflowerblue'>工作模式</font>分，可以分为并发式垃圾回收器和独占式垃圾回收器。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png" alt="垃圾回收概述-21-240301" /></p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<ol start="3">
<li>按<font color='cornflowerblue'>碎片处理方式</font>分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</li>
</ol>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞。</li>
<li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表。</li>
</ul>
<ol start="4">
<li>按<font color='cornflowerblue'>工作的内存区间</font>分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</li>
</ol>
<h3 id="13-评估-gc-的性能指标"><a class="markdownIt-Anchor" href="#13-评估-gc-的性能指标"></a> 1.3 评估 GC 的性能指标</h3>
<p><strong>指标</strong></p>
<ul>
<li>
<p><font color='red'>吞吐量：运行用户代码的时间占总运行时间的比例。</font>（总运行时间 = 程序的运行时间 + 内存回收的时间）</p>
</li>
<li>
<p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p>
</li>
<li>
<p><font color='red'>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</font></p>
</li>
<li>
<p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>
</li>
<li>
<p><font color='red'>内存占用：Java堆区所占的内存大小。</font></p>
</li>
<li>
<p>快速：一个对象从诞生到被回收所经历的时间。</p>
</li>
</ul>
<ol>
<li>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ol>
<p><strong>吞吐量（through put）</strong></p>
<ul>
<li>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。</p>
<ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--2403017cd3bfd9fe59577a.jpeg" alt="垃圾回收器-吞吐量-240301" /></p>
<p><strong>暂停时间（pause time）</strong></p>
<ul>
<li>
<p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li>
<p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5，但是总的GC时间可能会长。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--2403010b04d784d983d834.jpeg" alt="垃圾回收器-暂停时间-240301" /></p>
<p><strong>吞吐量 VS 暂停时间</strong></p>
<ul>
<li>
<p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
</li>
<li>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<font color='cornflowerblue'>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</font>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<font color='cornflowerblue'>交互式应用程序</font>。</p>
</li>
<li>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<font color='cornflowerblue'>只能频繁地执行内存回收</font>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
</li>
<li>
<p>现在标准：<font color='red'>在最大吞吐量优先的情况下，降低停顿时间。</font></p>
</li>
</ul>
<h2 id="2-不同的垃圾回收器概述"><a class="markdownIt-Anchor" href="#2-不同的垃圾回收器概述"></a> 2、不同的垃圾回收器概述</h2>
<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。那么，Java常见的垃圾收集器有哪些？</p>
<h3 id="21-垃圾收集器发展史"><a class="markdownIt-Anchor" href="#21-垃圾收集器发展史"></a> 2.1 垃圾收集器发展史</h3>
<p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布。</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用。</li>
</ul>
<h3 id="22-七款经典的垃圾收集器"><a class="markdownIt-Anchor" href="#22-七款经典的垃圾收集器"></a> 2.2 七款经典的垃圾收集器</h3>
<ul>
<li>
<p>串行回收器：Serial、Serial Old</p>
</li>
<li>
<p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p>
</li>
<li>
<p>并发回收器：CMS、G1</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-2-24030114fc55bb5599096d.png" alt="垃圾回收器-2-240301" /></p>
<p><strong>7 种经典的垃圾收集器与垃圾分代之间的关系</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-3-2403010affe0ad2519cb72.jpeg" alt="垃圾回收器-3-240301" /></p>
<ul>
<li>新年代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS</li>
<li>整堆收集器：G1</li>
</ul>
<p><strong>垃圾收集器的组合关系</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-4-24030193ea0fb167eb35f1.jpeg" alt="垃圾回收器-4-240301" /></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。</li>
<li>其中 Serial Old 作为 CMS 出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serial Old GC 组合（JEP366）</li>
<li>（青色虚线）JDK14 中：删除 CMS 垃圾回收器（JEP363）。</li>
</ul>
<p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。<font color='cornflowerblue'>所以我们选择的只是对具体应用最合适的收集器。</font></p>
<h3 id="23-如何查看默认垃圾收集器"><a class="markdownIt-Anchor" href="#23-如何查看默认垃圾收集器"></a> 2.3 如何查看默认垃圾收集器</h3>
<p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程 ID</code></p>
<ul>
<li>
<p>JDK8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=265851776 -XX:MaxHeapSize=4253628416 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1ConcRefinementThreads=8 -XX:InitialHeapSize=265851776 -XX:MaxHeapSize=4253628416 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="24-serial-回收器串行回收"><a class="markdownIt-Anchor" href="#24-serial-回收器串行回收"></a> 2.4 Serial 回收器：串行回收</h3>
<ul>
<li>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li>
<li>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。</li>
<li><font color='cornflowerblue'>Serial收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</font></li>
<li>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<font color='cornflowerblue'>Serial Old收集器也采用了串行回收和“Stop-The-World”机制，只不过内存回收算法使用的是标记-压缩算法。</font></li>
<li>Serial Old 是运行在 Client 模式下默认的老年代垃圾回收器。</li>
<li>Serial Old 在 server 模式下主要由两个用途：
<ul>
<li>与新生代的 Parallel Scavenge 配合使用。</li>
<li>作为老年代 CMS 收集器的后备垃圾收集方案。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Serial-240301df3d3618327be114.jpeg" alt="垃圾回收器-Serial回收器-240301" /></p>
<ul>
<li>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<font color='cornflowerblue'>只会使用一个 CPU 或一条收集线程去完成垃圾收集工作</font>，更重要的是在<font color='cornflowerblue'>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</font>。</p>
</li>
<li>
<p>优势：<font color='cornflowerblue'>简单而高效（与其他收集器的单线程比）</font>，对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在 Client 模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
</li>
<li>
<p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。</p>
<ul>
<li>等价于新生代用 Serial GC，且老年代用 Serial old GC。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解即可，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h3 id="25-parnew-回收器并行回收"><a class="markdownIt-Anchor" href="#25-parnew-回收器并行回收"></a> 2.5 ParNew 回收器：并行回收</h3>
<ul>
<li>
<p>如果说 SerialGC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 serial 收集器的多线程版本。</p>
<ul>
<li>Par 是 Parallel 的缩写，New 表示只能处理的是新生代。</li>
</ul>
</li>
<li>
<p>ParNew 收集器除了采用<font color='cornflowerblue'>并行回收</font>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是<font color='cornflowerblue'>采用复制算法、&quot;Stop-The-World&quot;机制</font>。</p>
</li>
<li>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-ParNew-2403013ad52f9cfa15b139.jpeg" alt="垃圾回收器-ParNew回收器-240301" /></p>
<ul>
<li>
<p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li>
<p>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）。</p>
</li>
<li>
<p>在程序中，开发人员可以通过选项<code>-XX:+UseParNewGC</code>手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和 CPU 数量相同的线程数。</p>
</li>
</ul>
<p><strong>ParNew 回收器与 Serial 回收器比较</strong></p>
<p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
<p>A：不能</p>
<ol>
<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
<li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</li>
</ol>
<h3 id="26-parallel-回收器吞吐量优先"><a class="markdownIt-Anchor" href="#26-parallel-回收器吞吐量优先"></a> 2.6 Parallel 回收器：吞吐量优先</h3>
<ul>
<li>
<p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<font color='cornflowerblue'>复制算法、并行回收和&quot;Stop The World&quot;机制</font>。</p>
</li>
<li>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个<font color='cornflowerblue'>可控制的吞吐量（Throughput）</font>，它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
</li>
<li>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<font color='cornflowerblue'>适合在后台运算而不需要太多交互的任务</font>。因此，常见在服务器环境中使用。例如，那些<font color='cornflowerblue'>执行批量处理、订单处理、工资支付、科学计算的应用程序</font>。</p>
</li>
<li>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
</li>
<li>
<p>Parallel Old 收集器采用了<font color='cornflowerblue'>标记-压缩算法</font>，但同样也是基于<font color='cornflowerblue'>并行回收和&quot;Stop-The-World&quot;机制</font>。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Parallel-Scavenge-24030169e84e42515958d1.jpeg" alt="垃圾回收器-Parallel Scavenge回收器-240301" /></p>
<ul>
<li>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。<font color='cornflowerblue'>在 JDK8 中，默认是此垃圾收集器。</font></li>
</ul>
<p><strong>Parallel Scavenge回收器参数设置</strong></p>
<ol>
<li>
<p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
</li>
<li>
<p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>默认开启一个，另一个也会被开启。<font color='red'>（互相激活）</font></li>
</ul>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li>
<p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p>
</li>
<li>
<p>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [ ( 5 * CPU_Count ) / 8 ]</code>。（12核时ParallelGCThreads的值等于10）</p>
</li>
</ul>
</li>
<li>
<p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</p>
<ul>
<li>
<p>为了尽可能地把停顿时间控制在<code>MaxGCPauseMillis</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。</p>
</li>
<li>
<p>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</p>
</li>
<li>
<p><font color='red'>该参数使用需谨慎。</font></p>
</li>
</ul>
</li>
<li>
<p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例，即等于<code>1 / ( N + 1 )</code>，用于衡量吞吐量的大小。</p>
<ol>
<li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1%。</li>
<li>与前一个<code>MaxGCPauseMillis</code>参数有一定矛盾性，STW暂停时间越短，垃圾收集时间占总时间的比例就越容易超过设定值。</li>
</ol>
</li>
<li>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<font color='cornflowerblue'>自适应调节策略</font>。</p>
<ul>
<li>
<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p>
</li>
</ul>
</li>
</ol>
<h3 id="27-cms-回收器低延迟"><a class="markdownIt-Anchor" href="#27-cms-回收器低延迟"></a> 2.7 CMS 回收器：低延迟</h3>
<ul>
<li>
<p>在JDK1.5时期，Hotspot推出了一款在<font color='cornflowerblue'>强交互应用中（就是和用户打交道的应用）</font>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<font color='cornflowerblue'>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</font></p>
</li>
<li>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><font color='cornflowerblue'>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</font>，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li>
<p>CMS的垃圾收集算法采用<font color='cornflowerblue'>标记-清除</font>算法，并且也会&quot;Stop-the-World&quot;。</p>
</li>
<li>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
</li>
<li>
<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
</li>
</ul>
<p><strong>执行流程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-CMS-2403013af2c01918492649.jpeg" alt="垃圾回收器-CMS回收器-240301" /></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及 STW 的阶段主要是：初始标记 和 重新标记)</p>
<ul>
<li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为&quot;Stop-The-World&quot;机制而出现短暂的暂停，这个阶段的主要任务<font color='red'>仅仅只是标记GC Roots能直接关联到的对象</font>。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这个阶段<font color='red'>速度非常快</font>。</li>
<li>并发标记（Concurrent-Mark）阶段：从 GC Roots 的<font color='red'>直接关联对象开始遍历整个对象图的过程</font>，这个过程<font color='red'>耗时较长</font>但是<font color='red'>不需要停顿用户线程</font>，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<font color='red'>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（指可能有存活的对象没有标记）</font>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除（Concurrent-Sweep）阶段：此阶段<font color='red'>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</font>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>尽管CMS收集器采用的是并发回收（非独占式），<font color='cornflowerblue'>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</font>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li>
<li><font color='cornflowerblue'>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</font></li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，所以<font color='cornflowerblue'>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。</font>因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<font color='cornflowerblue'>而是当堆内存使用率达到某一阈值时，便开始进行回收</font>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<font color='cornflowerblue'>Concurrent Mode Failure</font>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<font color='cornflowerblue'>不可避免地将会产生一些内存碎片</font>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-6-240301593f0669f0910b69.jpeg" alt="垃圾回收器-6-240301" /></p>
<p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p>
<p>因为并发清除的时用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用。</p>
<p><strong>CMS 的优点与弊端</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>
<p>并发收集</p>
</li>
<li>
<p>低延迟</p>
</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li>
<p><font color='cornflowerblue'>会产生内存碎片</font>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p>
</li>
<li>
<p><font color='cornflowerblue'>CMS收集器对CPU资源非常敏感</font>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li>
<p><font color='cornflowerblue'>CMS收集器无法处理浮动垃圾</font>。可能出现“<font color='cornflowerblue'>Concurrent Mode Failure</font>&quot;失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<font color='cornflowerblue'>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</font>，从而只能在下一次执行GC时释放这些之前未被回收的CMS 参数配置</p>
</li>
</ul>
<p><strong>CMS 参数配置</strong></p>
<ul>
<li>
<p><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器执行内存回收任务。</p>
<ul>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old（Old区备选方案）的组合。</li>
</ul>
</li>
<li>
<p><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。<font color='cornflowerblue'>JDK6及以上版本默认值为92%。</font></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<font color='cornflowerblue'>因此通过该选项便可以有效降低Full GC的执行次数。</font></li>
</ul>
</li>
<li>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li>
<p><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次Full GC后对内存空间进行压缩整理。</p>
</li>
<li>
<p><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量。</p>
<ul>
<li>CMS默认启动的线程数是 <code>(ParallelGCThreads + 3) / 4</code>，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong></p>
<p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<ul>
<li>
<p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p>
</li>
<li>
<p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p>
</li>
<li>
<p>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p>
</li>
</ul>
<p><strong>JDK 后续版本中 CMS 的变化</strong></p>
<ul>
<li>
<p>JDK9新特性：CMS被标记为Deprecate了（JEP291）</p>
<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li>
</ul>
</li>
<li>
<p>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，</p>
<ul>
<li>如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM。</li>
</ul>
</li>
</ul>
<h3 id="28-g1-回收器区域化分代式"><a class="markdownIt-Anchor" href="#28-g1-回收器区域化分代式"></a> 2.8 G1 回收器：区域化分代式</h3>
<p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p>
<ul>
<li>
<p>原因就在于应用程序所应对的<font color='cornflowerblue'>业务越来越庞大、复杂，用户越来越多</font>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
</li>
<li>
<p>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
</li>
<li>
<p>与此同时，<font color='cornflowerblue'>为了适应现在不断扩大的内存和不断增加的处理器数量</font>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
</li>
<li>
<p><font color='cornflowerblue'>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</font></p>
</li>
</ul>
<p><strong>为什么名字叫Garbage First(G1)呢？</strong></p>
<ul>
<li>
<p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
</li>
<li>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color='cornflowerblue'>每次根据允许的收集时间，优先回收价值最大的Region</font>。</p>
</li>
<li>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>
</li>
<li>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<font color='cornflowerblue'>主要针对配备多核CPU及大容量内存的机器</font>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
</li>
<li>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，<font color='cornflowerblue'>是JDK9以后的默认垃圾回收器</font>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为<font color='cornflowerblue'>“全功能的垃圾收集器”</font>。</p>
</li>
<li>
<p>与此同时，CMS已经在JDK9中被标记为废弃（Deprecated）。<font color='cornflowerblue'>G1在JDK8中还不是默认的垃圾回收器</font>，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
</li>
</ul>
<p><strong>G1 回收器的优势</strong></p>
<p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<ol>
<li>
<p>并行与并发兼备</p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li>
<p>分代收集</p>
<ul>
<li>
<p>从分代上看，<font color='cornflowerblue'>G1依然属于分代型垃圾回收器</font>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li>
<p><font color='cornflowerblue'>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</font></p>
</li>
<li>
<p>和之前的各类回收器不同，它同时<font color='cornflowerblue'>兼顾年轻代和老年代</font>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</p>
<p>G1的分代，已经不是下面这样的了：</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-7-240301c632f4c6e8592878.jpeg" alt="垃圾回收器-7-240301" /></p>
<p>​			而是如下图这样的一个区域：</p>
<p><img src="https://img.picgo.net/2025/01/20/-8-240301cdd02a36e1b0bf92.jpeg" alt="垃圾回收器-8-240301" /></p>
<ol start="3">
<li>
<p>空间整合</p>
<ul>
<li>CMS：标记-清除算法，会产生内存碎片，若干次GC后进行一次碎片整理。</li>
<li>G1将内存划分为一个个的Region。内存的回收是以Region作为基本单位的。<font color='cornflowerblue'>Region之间是复制算法，但整体上实际可看作是标记-压缩算法</font>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li>
<p>可预测的停顿时间模型（即：软实时soft real-time）</p>
<ul>
<li>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color='cornflowerblue'>每次根据允许的收集时间，优先回收价值最大的Region</font>。保证了G1收集器在有限的时间内可以<font color='cornflowerblue'>获取尽可能高的收集效率</font>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>G1 回收器的缺点</strong></p>
<ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li>
</ol>
<p><strong>G1 参数设置</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务。</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms。</li>
<li><code>-XX:ParallelGCThread</code>：设置STW时GC线程数的值。最多设置为8。</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<p><strong>G1 收集器的常见操作步骤</strong></p>
<p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ol>
<li>开启G1垃圾收集器。</li>
<li>设置堆的最大内存。</li>
<li>设置最大的停顿时间。</li>
</ol>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p>
<p><strong>G1 的适用场景</strong></p>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是给需要低GC延迟，并具有大堆的应用程序提供解决方案。
<ul>
<li>如在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>
</ul>
</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：
<ul>
<li>超过50%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于0.5至1秒）。</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ul>
<h4 id="分区-region化整为零"><a class="markdownIt-Anchor" href="#分区-region化整为零"></a> 分区 Region：化整为零</h4>
<ul>
<li>
<p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<font color='cornflowerblue'>所有的Region大小相同，且在JVM生命周期内不会被改变。</font></p>
</li>
<li>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
</li>
<li>
<p>一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果<font color='red'>超过0.5个Region，就放到H</font>。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-region-240301b174a4c427cfe0f5.jpg" alt="垃圾回收器-region-240301" /></p>
<p><strong>设置 H 的原因</strong></p>
<p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<font color='cornflowerblue'>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。</font>为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p><strong>Region的细节</strong></p>
<ol>
<li>每个Region都是通过指针碰撞来分配空间。</li>
<li>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li>TLAB用来保证并发性。</li>
</ol>
<p><strong>G1 垃圾回收流程</strong></p>
<p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-9-24030171d8ab85e969f24e.png" alt="垃圾回收器-9-240301" /></p>
<ol>
<li>应用程序分配内存，<font color='cornflowerblue'>当年轻代的Eden区用尽时开始年轻代回收过程</font>；G1的年轻代收集阶段是一个<font color='cornflowerblue'>并行的独占式收集器</font>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<font color='cornflowerblue'>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能两个区间都会涉及。</font></li>
<li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。与G1的年轻代回收器和其他GC回收器不同，<font color='cornflowerblue'>G1的老年代回收器不需要回收整个老年代，一次只需要扫描/回收一小部分老年代的Region就可以了。</font>同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ol>
<p><strong>Remembered Set（记忆集）</strong></p>
<ul>
<li>
<p>一个对象被不同区域引用的问题。</p>
</li>
<li>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
</li>
<li>
<p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）。</p>
</li>
<li>
<p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率。</p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描。</p>
</li>
<li>
<p><font color='cornflowerblue'>每个Region都有一个对应的Remembered Set。</font></p>
</li>
<li>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作。</p>
</li>
<li>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）。</p>
</li>
<li>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中。</p>
</li>
<li>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-10-240301996aa998a81c6702.png" alt="垃圾回收器-10-240301" /></p>
<h4 id="g1回收过程一年轻代-gc"><a class="markdownIt-Anchor" href="#g1回收过程一年轻代-gc"></a> G1回收过程一：年轻代 GC</h4>
<ol>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li>年轻代回收只回收Eden区和Survivor区。</li>
<li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-11-24030145e8e40fa2eeee6a.png" alt="垃圾回收器-11-240301" /></p>
<blockquote>
<p>复制算法（S、E–&gt;空闲区相当于To区）（S–&gt;寻找新的空闲区作为老年代）</p>
</blockquote>
<p><strong>然后开始如下回收过程：</strong></p>
<p><font color='red'>第一阶段，扫描根。</font></p>
<p>​	根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p><font color='red'>第二阶段，更新RSet。</font></p>
<p>​	处理dirty card queue中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。</p>
<ul>
<li>dirty card queue：对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>
<li>在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
<p><font color='red'>第三阶段，处理RSet。</font></p>
<p>​	识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p><font color='red'>第四阶段，复制对象。</font></p>
<p>​	此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p><font color='red'>第五阶段，处理引用。</font></p>
<p>​	处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h4 id="g1回收过程二并发标记过程"><a class="markdownIt-Anchor" href="#g1回收过程二并发标记过程"></a> G1回收过程二：并发标记过程</h4>
<ol>
<li><font color='red'>初始标记阶段</font>：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li>
<li><font color='red'>根区域扫描（Root Region Scanning）</font>：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li>
<li><font color='red'>并发标记（Concurrent Marking）</font>：
<ul>
<li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li>
<li><font color='cornflowerblue'>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</font></li>
<li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
</ul>
</li>
<li><font color='red'>再次标记（Remark）</font>：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li>
<li><font color='red'>独占清理（cleanup，STW）</font>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。
<ul>
<li>这个阶段并不会实际上去做垃圾的收集。</li>
</ul>
</li>
<li><font color='red'>并发清理阶段</font>：识别并清理完全空闲的区域。</li>
</ol>
<h4 id="g1回收过程三混合回收过程"><a class="markdownIt-Anchor" href="#g1回收过程三混合回收过程"></a> G1回收过程三：混合回收过程</h4>
<p>​	当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="https://img.picgo.net/2025/01/20/-12-2403016721689d39f2bf1c.png" alt="垃圾回收器-12-240301" /></p>
<p><strong>混合回收的细节</strong></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收。（意思就是一个Region会被分为8个内存段）</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<font color='cornflowerblue'>垃圾占内存分段比例越高的，越会被先回收。</font>并且有一个阈值会决定内存分段是否被回收。<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<h4 id="g1回收可选的过程四full-gc"><a class="markdownIt-Anchor" href="#g1回收可选的过程四full-gc"></a> G1回收可选的过程四：Full GC</h4>
<ul>
<li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<font color='cornflowerblue'>单线程</font>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
</ul>
<p>导致G1 Full GC的原因可能有两个：</p>
<ol>
<li>回收阶段没有足够的to-space来存放晋升的对象。</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h4>
<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而<font color='cornflowerblue'>选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中</font>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p><strong>G1 回收器的优化建议</strong></p>
<ol>
<li>年轻代大小
<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整。</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛
<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ol>
<h3 id="29-垃圾回收器总结"><a class="markdownIt-Anchor" href="#29-垃圾回收器总结"></a> 2.9 垃圾回收器总结</h3>
<p><strong>7 种垃圾回收器的比较</strong></p>
<p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="https://img.picgo.net/2025/01/20/-13-240301978b96b59371bcf1.jpeg" alt="垃圾回收器-13-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-14-240301cdd6f227e6f12a2d.png" alt="垃圾回收器-14-240301" /></p>
<p><strong>怎么选择垃圾回收器</strong></p>
<p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器。</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，使用串行收集器。</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择。</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器。</li>
<li>官方推荐G1，性能高。<font color='cornflowerblue'>现在互联网的项目，基本都是使用G1。</font></li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集算法。</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。</li>
</ol>
<p><strong>面试</strong></p>
<ol>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li>
<li>这里较通用、基础性的部分如下：
<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</li>
</ol>
<h2 id="3-gc-日志分析"><a class="markdownIt-Anchor" href="#3-gc-日志分析"></a> 3、GC 日志分析</h2>
<h3 id="31-常用参数配置"><a class="markdownIt-Anchor" href="#31-常用参数配置"></a> 3.1 常用参数配置</h3>
<p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p>
<p>内存分配与垃圾回收的参数列表</p>
<ol>
<li><code>-XX:+PrintGC</code>：输出GC日志。类似：<code>-verbose:gc</code></li>
<li><code>-XX:+PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出GC的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li>
<li><code>-XX:+PrintHeapAtGC</code>：在进行GC的前后打印出堆的信息</li>
<li>-<code>Xloggc:…/logs/gc.log</code>：日志文件的输出路径</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-Xms60m -Xmx60m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">            list.add(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGC/-verbose:gc</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  15324K-&gt;15322K(58880K), 0.0031346 secs]</span><br><span class="line">[GC (Allocation Failure)  30682K-&gt;30468K(58880K), 0.0037461 secs]</span><br><span class="line">[Full GC (Ergonomics)  30468K-&gt;30325K(58880K), 0.0053327 secs]</span><br><span class="line">[Full GC (Ergonomics)  45685K-&gt;45528K(58880K), 0.0039465 secs]</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGCDetails</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 15324K-&gt;2556K(17920K)] 15324K-&gt;15274K(58880K), 0.0041477 secs] [Times: user=0.00 sys=0.13, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 17916K-&gt;2532K(17920K)] 30634K-&gt;30460K(58880K), 0.0041784 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2532K-&gt;0K(17920K)] [ParOldGen: 27928K-&gt;30325K(40960K)] 30460K-&gt;30325K(58880K), [Metaspace: 2625K-&gt;2625K(1056768K)], 0.0064628 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 15360K-&gt;5000K(17920K)] [ParOldGen: 30325K-&gt;40527K(40960K)] 45685K-&gt;45528K(58880K), [Metaspace: 2625K-&gt;2625K(1056768K)], 0.0037207 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 17920K, used 10633K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 15360K, 69% used [0x00000000fec00000,0x00000000ff6625c8,0x00000000ffb00000)</span><br><span class="line">  from space 2560K, 0% used [0x00000000ffd80000,0x00000000ffd80000,0x0000000100000000)</span><br><span class="line">  to   space 2560K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffd80000)</span><br><span class="line"> ParOldGen       total 40960K, used 40527K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)</span><br><span class="line">  object space 40960K, 98% used [0x00000000fc400000,0x00000000feb93e98,0x00000000fec00000)</span><br><span class="line"> Metaspace       used 2632K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2021-10-08T20:43:11.758+0800: 0.072: [GC (Allocation Failure)  15324K-&gt;15322K(58880K), 0.0033766 secs]</span><br><span class="line">2021-10-08T20:43:11.763+0800: 0.076: [GC (Allocation Failure)  30682K-&gt;30580K(58880K), 0.0040002 secs]</span><br><span class="line">2021-10-08T20:43:11.766+0800: 0.080: [Full GC (Ergonomics)  30580K-&gt;30325K(58880K), 0.0053498 secs]</span><br><span class="line">2021-10-08T20:43:11.772+0800: 0.086: [Full GC (Ergonomics)  45685K-&gt;45528K(58880K), 0.0039231 secs]</span><br></pre></td></tr></table></figure>
<h3 id="32-gc-日志补充说明"><a class="markdownIt-Anchor" href="#32-gc-日志补充说明"></a> 3.2 GC 日志补充说明</h3>
<ol>
<li>“GC&quot;和”Full GC&quot;说明了这次垃圾收集的停顿类型，如果是&quot;Full GC&quot;则说明发生了&quot;Stop The World&quot;。</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是&quot;DefNew&quot;。</li>
<li>使用ParNew收集器在新生代的名字会变成&quot;ParNew&quot;，意思是&quot;Parallel New Generation&quot;。</li>
<li>使用Parallel Scavenge收集器在新生代的名字是”PSYoungGen&quot;。</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的。</li>
<li>使用G1收集器的话，会显示为&quot;garbage-first heap&quot;。</li>
<li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li><code>[PSYoungGen: 15324K-&gt;2556K(17920K)] 15324K-&gt;15274K(58880K)</code>
<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间。</li>
</ol>
<p><strong>GC</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-15-240301605cefc98cc10f0c.jpeg" alt="垃圾回收器-15-240301" /></p>
<p><strong>Full GC</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-16-240301be13001555ebb8cf.jpeg" alt="垃圾回收器-16-240301" /></p>
<h3 id="33-gc-日志分析"><a class="markdownIt-Anchor" href="#33-gc-日志分析"></a> 3.3 GC 日志分析</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 6967K-&gt;520K(9216K), 0.0029979 secs] 6967K-&gt;6664K(19456K), 0.0030609 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4781K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290e0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000000ff500000, 0x00000000ff5823b8, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2629K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<ol>
<li>首先将3个2M的对象存放到Eden区，后面4M的对象来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次YGC，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-17-24030136ec53cf80809d13.png" alt="垃圾回收器-17-240301" /></p>
<ol start="2">
<li>腾出空间后，将4M对象存入到Eden区中。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-18-240301bee93226f609ec1a.png" alt="垃圾回收器-18-240301" /></p>
<h3 id="34-常用日志分析工具"><a class="markdownIt-Anchor" href="#34-常用日志分析工具"></a> 3.4 常用日志分析工具</h3>
<p><strong>保存日志文件</strong></p>
<p><strong>JVM参数</strong>：<code>-Xloggc:./logs/gc.log</code>， ./ 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录。</p>
<p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p>
<p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</p>
<p><strong>推荐：GCeasy</strong></p>
<p>在线分析网址：<span class="exturl" data-url="aHR0cDovL2djZWFzeS5pbw==">gceasy.io<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://img.picgo.net/2025/01/20/-19-24030115db9abfa4850cd2.png" alt="垃圾回收器-19-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-20-240301638d167fc2188db5.png" alt="垃圾回收器-20-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-21-240301e2614e7cde73528d.png" alt="垃圾回收器-21-240301" /></p>
<h2 id="4-垃圾回收器的新发展"><a class="markdownIt-Anchor" href="#4-垃圾回收器的新发展"></a> 4、垃圾回收器的新发展</h2>
<p>​	GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，FullGC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p>
<p>​	即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<font color='cornflowerblue'>在Serverless等新的应用场景下，Serial GC找到了新的舞台。</font></p>
<p>​	比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p>
<p>​	现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</p>
<h3 id="41-open-jdk12的shenandoash-gc低停顿时间的gc实验性"><a class="markdownIt-Anchor" href="#41-open-jdk12的shenandoash-gc低停顿时间的gc实验性"></a> 4.1 Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</h3>
<ul>
<li>
<p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li>
<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<font color='cornflowerblue'>旨在针对JVM上的内存回收实现低停顿的需求</font>。在2014年贡献给OpenJDK。</p>
</li>
<li>
<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
</li>
<li>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Shenandoah-2403014156181d344db4af.png" alt="垃圾回收器-Shenandoah-240301" /></p>
<p>总结</p>
<ol>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
</ol>
<h3 id="42-令人震惊-革命性的-zgcjdk14-新特性"><a class="markdownIt-Anchor" href="#42-令人震惊-革命性的-zgcjdk14-新特性"></a> 4.2 <strong>令人震惊、革命性的 ZGC（JDK14 新特性）</strong></h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTIvZ2N0dW5pbmcv">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>ZGC与Shenandoah目标高度相似，在<font color='cornflowerblue'>尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</font></li>
<li>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<font color='cornflowerblue'>可并发的标记-压缩算法</font>的，以<font color='cornflowerblue'>低延迟为首要目标</font>的一款垃圾收集器。</li>
<li>ZGC的工作过程可以分为4个阶段：<font color='cornflowerblue'>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</font>等。</li>
<li>ZGC几乎在所有地方并发执行的，除了<font color='cornflowerblue'>初始标记的是STW的</font>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li>
</ul>
<p><strong>吞吐量</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC1-240301adf6d068206269f3.png" alt="垃圾回收器-ZGC1-240301" /></p>
<ul>
<li>
<p>max-JOPS：以低延迟为首要前提下的数据</p>
</li>
<li>
<p>critical-JOPS：不考虑低延迟下的数据</p>
</li>
</ul>
<p><strong>暂停时间</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC2-2403013dd0918acc912d1a.png" alt="垃圾回收器-ZGC2-240301" /></p>
<ul>
<li>
<p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p>
</li>
<li>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC3-2403010c250759cfcd1ce1.png" alt="垃圾回收器-ZGC3-240301" /></p>
<ul>
<li>
<p>JDK14之前，ZGC仅Linux才支持。</p>
</li>
<li>
<p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p>
</li>
<li>
<p>现在mac或Windows上也能使用ZGC了，示例如下：</p>
<p><code>-XX:+UnlockExperimentalVMOptions -XX：+UseZGC</code></p>
</li>
</ul>
<h3 id="43-其他垃圾回收器aligc"><a class="markdownIt-Anchor" href="#43-其他垃圾回收器aligc"></a> 4.3 其他垃圾回收器：AliGC</h3>
<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://img.picgo.net/2025/01/20/-AliGC-240301968f08e3f45a3398.png" alt="垃圾回收器-AliGC-240301" /></p>
<blockquote>
<p>当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC，Zing，有兴趣可以参考提供的链接。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL2FydGljbGVzL2F6dWxfZ2NfaW5fZGV0YWls">https://www.infoq.com/articles/azul_gc_in_detail<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>原作者： </strong>Gerrit1999
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/" title="JVM 笔记">https://gerrit1999.github.io/2024/JVM笔记/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%E5%90%8EMySQL%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/" rel="prev" title="记一次服务器宕机后MySQL无法启动的解决过程">
                  <i class="fa fa-angle-left"></i> 记一次服务器宕机后MySQL无法启动的解决过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E8%A7%A3%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/" rel="next" title="从协议到算法：解读分布式一致性的核心机制">
                  从协议到算法：解读分布式一致性的核心机制 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Gerrit1999</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <style>
  .moe_icp a {
    all: unset; /* 重置所有默认样式 */
    text-decoration: none;
  }

  .moe_icp a:hover {
    filter: brightness(1.2);
  }
</style>

<div class="moe_icp" style="display: flex; justify-content: center; align-items: center; gap: 10px;">
  <a href="https://icp.gov.moe/?keyword=20248869" target="_blank">
    <img src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%8720248869%E5%8F%B7-e22b84" alt="萌ICP备20248869号">
  </a>

  <a style="color:#e77c8e; display: inline-flex; align-items: center;" 
     href="https://travel.moe/go.html" 
     title="异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！" 
     target="_blank">
    <img src="https://travel.moe/images/icon/icon64pink.png" style="width:24px;height:24px; margin-right: 4px;">
    异次元之旅
  </a>
</div>

  <div id="site-runtime">
  <span class="post-meta-item-icon">
    <i class="fa fa-clock-o"></i>
  </span>
  <span id="runtime"></span>
</div>

<script language="javascript">
  function isPC() {
    var userAgentInfo = navigator.userAgent;
    var agents = ["Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod"];
    for (var i = 0; i < agents.length; i++) {
      if (userAgentInfo.indexOf(agents[i]) > 0) {
        return false;
      }
    }
    return true;
  }

  function siteTime(openOnPC, start) {
    window.setTimeout("siteTime(openOnPC, start)", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
      start = new Date("2024-11-18 09:00:00 +0800");
    var now = new Date();
    var year = now.getFullYear();
    var month = now.getMonth() + 1;
    var date = now.getDate();
    var hour = now.getHours();
    var minute = now.getMinutes();
    var second = now.getSeconds();
    var diff = now - start;

    var diffYears = Math.floor(diff / years);
    var diffDays = Math.floor((diff / days) - diffYears * 365);
    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);

    if (openOnPC) {
      document.getElementById("runtime").innerHTML = "本站已运行: " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分 " + diffSeconds + " 秒";
    } else {
      document.getElementById("runtime").innerHTML = "本站已运行: " + diffYears + "年 " + diffDays + "天 " + diffHours + "小时 " + diffMinutes + "分 " + diffSeconds + "秒";
    }
  }

  var showOnMobile = true;
  var openOnPC = isPC();
  var start = new Date();
  siteTime(openOnPC, start);

  if (!openOnPC && !showOnMobile) {
    document.getElementById('site-runtime').style.display = 'none';
  }
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL0dlcnJpdDE5OTk=" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script><script src="/js/clicklove.js"></script>
  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  <script src="https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://gerrit1999.github.io/2024/JVM%E7%AC%94%E8%AE%B0/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline.gerrit2025.xyz","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":true,"comment_count":true,"requiredFields":[],"libUrl":"https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/waline/2.15.8/waline.js","dark":"body.darkmode--activated","el":"#waline","comment":true,"path":"/2024/JVM%E7%AC%94%E8%AE%B0/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://cdn.staticfile.org/Darkmode.js/1.5.7/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item">
      <i class='fas fa-chevron-down'></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item">
      <i class='fas fa-chevron-up'></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"></circle>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"></circle>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class='fas fa-ellipsis-v'></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
</body>
</html>
