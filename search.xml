<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 实现代码折叠功能</title>
    <url>/2024/Hexo%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%8A%98%E5%8F%A0%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h1>
<p>博主在使用 next 主题过程中，没有发现代码折叠相关的配置，于是开始动手折腾。</p>
<span id="more"></span>
<p><strong>本博客环境</strong></p>
<p><img src="https://img.picgo.net/2024/11/21/202411211704288ef4d5f4459faff5.png" alt="image.png" /></p>
<p><img src="https://img.picgo.net/2024/11/21/2024112117044221655a41a174e821.png" alt="image.png" /></p>
<h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1>
<p>由于博主的 next 主题是使用 npm安装的，所以下文中除了特殊说明以外的添加修改文件操作，均在 <code>node_modules/hexo-theme-next</code> 目录下进行。</p>
<p>如果是通过 git 部署的话，则在 <code>themes/next</code> 下进行。</p>
<h2 id="添加-code-unfoldjs"><a class="markdownIt-Anchor" href="#添加-code-unfoldjs"></a> 添加 code-unfold.js</h2>
<p><code>source/js/code-unfold.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">CODE_MAX_HEIGHT</span> = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> containers = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;.js_unfold_code_btn&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收起</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;.js_retract_code_btn&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $container = $(<span class="variable language_">this</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> winTop = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line">    <span class="keyword">var</span> offsetTop = $container.<span class="title function_">offset</span>().<span class="property">top</span>;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&#x27;top&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (winTop &gt; offsetTop) &#123;</span><br><span class="line">        <span class="comment">// 设置滚动条位置</span></span><br><span class="line">        $(<span class="string">&#x27;body, html&#x27;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">            <span class="attr">scrollTop</span>: $container.<span class="title function_">offset</span>().<span class="property">top</span> - <span class="variable constant_">CODE_MAX_HEIGHT</span></span><br><span class="line">        &#125;, <span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 滚动事件，触发动画效果</span></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; containers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = containers[i];</span><br><span class="line">        <span class="keyword">var</span> &#123; $container, height, $hide, hasHorizontalScrollbar &#125; = item;</span><br><span class="line">        <span class="keyword">if</span> ($container.<span class="title function_">closest</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 $container 元素已经不在页面上, 则删除该元素</span></span><br><span class="line">            <span class="comment">// 防止pjax页面跳转之后，元素未删除</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="title function_">push</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (!$container.<span class="title function_">hasClass</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> offsetTop = $container.<span class="title function_">offset</span>().<span class="property">top</span>;</span><br><span class="line">        <span class="keyword">var</span> hideBtnHeight = $hide.<span class="title function_">outerHeight</span>();</span><br><span class="line">        <span class="comment">// 减去按钮高度，减去底部滚动条高度</span></span><br><span class="line">        <span class="keyword">var</span> maxTop = <span class="built_in">parseInt</span>(height - (hasHorizontalScrollbar ? <span class="number">17</span> : <span class="number">0</span>) - hideBtnHeight);</span><br><span class="line">        <span class="keyword">let</span> top = <span class="built_in">parseInt</span>(</span><br><span class="line">            <span class="title class_">Math</span>.<span class="title function_">min</span>(</span><br><span class="line">                <span class="title class_">Math</span>.<span class="title function_">max</span>(scrollTop - offsetTop, <span class="number">0</span>), <span class="comment">// 如果小于 0 ，则取 0</span></span><br><span class="line">                maxTop,<span class="comment">// 如果大于 height ，则取 height</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 根据 sin 曲线设置&quot;收起代码&quot;位置</span></span><br><span class="line">        <span class="keyword">var</span> halfHeight = <span class="built_in">parseInt</span>($(<span class="variable language_">window</span>).<span class="title function_">height</span>() / <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">sin</span>((top / maxTop) * <span class="number">90</span> * (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">360</span>)));</span><br><span class="line">        $hide.<span class="title function_">css</span>(<span class="string">&#x27;top&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(top + halfHeight, maxTop));</span><br><span class="line">    &#125;</span><br><span class="line">    containers = temp;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加隐藏容器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addCodeWrap</span>(<span class="params">$node</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $container = $node.<span class="title function_">wrap</span>(<span class="string">&#x27;&lt;div class=&quot;js_highlight_container highlight-container&quot;&gt;&lt;div class=&quot;highlight-wrap&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部 &quot;展开代码&quot; 与 侧边栏 &quot;收起代码&quot;</span></span><br><span class="line">    <span class="keyword">var</span> $btn = $(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;highlight-footer&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a class=&quot;js_unfold_code_btn show-btn&quot; href=&quot;javascript:;&quot;&gt;展开代码&lt;i class=&quot;fa fa-angle-down&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;js_retract_code_btn hide-btn&quot; href=&quot;javascript:;&quot;&gt;&lt;i class=&quot;fa fa-angle-up&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;收起代码&lt;/a&gt;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line"></span><br><span class="line">    $container.<span class="title function_">append</span>($btn);</span><br><span class="line">    <span class="keyword">return</span> $container;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">codeUnfold</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.highlight&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 防止重复渲染</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">__render__</span> === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__render__</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> $this = $(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">var</span> height = $(<span class="variable language_">this</span>).<span class="title function_">outerHeight</span>();</span><br><span class="line">        <span class="keyword">if</span> (height &gt; <span class="variable constant_">CODE_MAX_HEIGHT</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加展开&amp;收起容器</span></span><br><span class="line">            <span class="keyword">var</span> $container = <span class="title function_">addCodeWrap</span>($this, height);</span><br><span class="line">            containers.<span class="title function_">push</span>(&#123;</span><br><span class="line">                $container,</span><br><span class="line">                height,</span><br><span class="line">                <span class="attr">$hide</span>: $container.<span class="title function_">find</span>(<span class="string">&#x27;.js_retract_code_btn&#x27;</span>),</span><br><span class="line">                <span class="attr">hasHorizontalScrollbar</span>: <span class="variable language_">this</span>.<span class="property">scrollWidth</span> &gt; <span class="variable language_">this</span>.<span class="property">offsetWidth</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="引用-js"><a class="markdownIt-Anchor" href="#引用-js"></a> 引用 js</h2>
<p>修改文件 <code>layout/_scripts/index.njk</code>，在最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- next_js(&#x27;code-unfold.js&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>修改文件 <code>layout/_scripts/vendors.njk</code>，在最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://awp-assets.meituan.net/thh/thh_feb_web_portal/js/jquery-3.6.0.min.js&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>修改文件 <code>source/js/next-boot.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">NexT</span>.<span class="property">boot</span>.<span class="property">refresh</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 添加一行代码</span></span><br><span class="line">  <span class="title function_">codeUnfold</span>()</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h2 id="添加样式"><a class="markdownIt-Anchor" href="#添加样式"></a> 添加样式</h2>
<p>参考 next 的<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL2FkdmFuY2VkLXNldHRpbmdzL2N1c3RvbS1maWxlcy5odG1sP2hpZ2hsaWdodD1jdXN0b20ranMjQ3VzdG9tLUZpbGUtU3VwcG9ydA==">自定义文件<i class="fa fa-external-link-alt"></i></span>方式，在 hexo 站点下创建或修改 <code>source/_data/styles.styl</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 展开收起效果</span><br><span class="line"><span class="selector-class">.highlight-container</span></span><br><span class="line">  <span class="attribute">position</span>: relative</span><br><span class="line">  background-color: highlight-background</span><br><span class="line">  &amp;.on</span><br><span class="line">    .highlight-footer</span><br><span class="line">      display: none</span><br><span class="line">    .hide-btn</span><br><span class="line">      display: flex</span><br><span class="line">    .highlight-wrap</span><br><span class="line">      max-height: none</span><br><span class="line">  .highlight-wrap</span><br><span class="line">    overflow: hidden</span><br><span class="line">    max-height: <span class="number">200px</span></span><br><span class="line">  .highlight-footer</span><br><span class="line">    position absolute</span><br><span class="line">    width: <span class="number">100%</span></span><br><span class="line">    left: <span class="number">0</span></span><br><span class="line">    bottom: <span class="number">0</span></span><br><span class="line">    height: <span class="number">60px</span></span><br><span class="line">    background-image: <span class="string">&#x27;linear-gradient(-180deg, rgba(255,255,255,0) 0%, %s 65%)&#x27;</span> % highlight-background;</span><br><span class="line">    <span class="attribute">text-align</span>: center</span><br><span class="line">  .show-btn</span><br><span class="line">    font-size: <span class="number">12px</span></span><br><span class="line">    color: <span class="number">#fff</span></span><br><span class="line">    position: absolute</span><br><span class="line">    left: <span class="number">50%</span></span><br><span class="line">    transform: <span class="built_in">translateX</span>(-<span class="number">50%</span>)</span><br><span class="line">    bottom: <span class="number">0</span></span><br><span class="line">    line-height: <span class="number">2em</span></span><br><span class="line">    text-decoration: none</span><br><span class="line">    padding: <span class="number">0</span> <span class="number">0.8em</span></span><br><span class="line">    text-align: center</span><br><span class="line">    border-radius: <span class="number">4px</span> <span class="number">4px</span> <span class="number">0</span></span><br><span class="line">    &amp;:hover</span><br><span class="line">      text-decoration: none</span><br><span class="line">  .hide-btn</span><br><span class="line">    color: <span class="number">#fff</span></span><br><span class="line">    font-size: <span class="number">12px</span></span><br><span class="line">    width: <span class="number">22px</span></span><br><span class="line">    position: absolute</span><br><span class="line">    left: -<span class="number">21px</span></span><br><span class="line">    top: <span class="number">0</span></span><br><span class="line">    line-height: <span class="number">1em</span></span><br><span class="line">    text-decoration: none</span><br><span class="line">    text-align: center</span><br><span class="line">    display: none</span><br><span class="line">    flex-direction: column</span><br><span class="line">    background-color: highlight-background</span><br><span class="line">    border-radius: <span class="number">4px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4px</span></span><br><span class="line">    padding: <span class="number">0.1em</span> <span class="number">0</span> <span class="number">0.6em</span></span><br><span class="line">    transition: top ease <span class="number">0.35s</span></span><br><span class="line">  .fa-angle-up,</span><br><span class="line">  .fa-angle-down</span><br><span class="line">    font-style: normal</span><br><span class="line">    color: <span class="number">#fff</span></span><br><span class="line">  .fa-angle-up:before</span><br><span class="line">    content:<span class="string">&quot;\f106&quot;</span></span><br><span class="line">  .fa-angle-down:before</span><br><span class="line">    content:<span class="string">&quot;\f107&quot;</span></span><br><span class="line">    margin-left: <span class="number">0.5em</span></span><br><span class="line">  .js_unfold_code_btn, .js_retract_code_btn</span><br><span class="line">    background: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">    border-bottom: none <span class="meta">!important</span></span><br><span class="line">    &amp;:hover</span><br><span class="line">      border-bottom-color: none <span class="meta">!important</span></span><br></pre></td></tr></table></figure>
<p><strong>记得去掉 <code>_config.next.yml</code> 中的注释</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<p>配置完成后，需要重新清理部署。</p>
<p>这样我们就完成了 hexo 的长代码折叠功能。上文代码块采用的方案即是这种。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9pbWMuY29tL2hleG8tdXNhZ2UtMi8=">hexo博客代码折叠功能 | 代码构建你的世界<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 笔记</title>
    <url>/2024/JVM%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一-初识jvm"><a class="markdownIt-Anchor" href="#一-初识jvm"></a> 一、初识JVM</h1>
<h2 id="1-jvm的架构模型"><a class="markdownIt-Anchor" href="#1-jvm的架构模型"></a> 1、JVM的架构模型</h2>
<p><font color='red'>Java编译器输入的指令流基本上是一种基于栈的指令集架构。</font></p>
<p>基于栈式架构的特点：</p>
<ol>
<li>
<p>设计和实现更简单，适用于资源受限的系统；</p>
</li>
<li>
<p>避开了寄存器的分配难题：使用零地址指令方式分配；</p>
</li>
<li>
<p>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈，指令集更小，编译器更容易实现；</p>
</li>
<li>
<p>不需要硬件支持，可移植性更好，更好实现跨平台。</p>
</li>
</ol>
<p>总结：由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现；缺点是性能下降，实现同样的功能需要更多的指令。</p>
<h2 id="2-jvm的生命周期"><a class="markdownIt-Anchor" href="#2-jvm的生命周期"></a> 2、JVM的生命周期</h2>
<ol>
<li>
<p>虚拟机的启动</p>
<p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建的一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
</li>
<li>
<p>虚拟机的执行</p>
<ul>
<li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。</li>
<li>程序开始执行它才运行，程序结束时它就停止。</li>
<li>执行一个所谓Java程序的时候，真真正正执行的是一个叫做Java虚拟机的进程。</li>
</ul>
</li>
<li>
<p>虚拟机的退出</p>
<p>有以下几种情况：</p>
<ul>
<li>程序正常执行结束。</li>
<li>程序在执行过程中遇到异常或错误而异常终止。</li>
<li>由于操作系统出现错误导致Java虚拟机进程终止。</li>
<li>某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</li>
</ul>
</li>
</ol>
<h2 id="3-jvm的发展历程"><a class="markdownIt-Anchor" href="#3-jvm的发展历程"></a> 3、JVM的发展历程</h2>
<ol>
<li>
<p>Sun Classic VM</p>
<p>是世界第一款商用Java虚拟机。JDK1.4时被完全淘汰。这款虚拟机内部只提供解释器，效率较低。现在HotSpot内置了此虚拟机。</p>
</li>
<li>
<p>Exact VM</p>
<ul>
<li>
<p>JDK1.2时，sun提供了此虚拟机。</p>
</li>
<li>
<p>Exact Memory Management：准确式内存管理</p>
<p>虚拟机可以知道内存中的某个位置的数据具体是什么类型。</p>
</li>
<li>
<p>具备现代高性能虚拟机的雏形</p>
<ul>
<li>热点探测</li>
<li>编译器与解释器混合工作模式</li>
</ul>
</li>
<li>
<p>只在Solaris平台短暂使用，其他平台还是Classic VM。</p>
</li>
</ul>
</li>
<li>
<p>HotSpot VM</p>
<p>JDK1.3时，HotSpot VM成为默认虚拟机。</p>
<ul>
<li>
<p>目前HotSpot占有绝对的市场定位。</p>
<p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot。</p>
</li>
<li>
<p>从服务器、桌面到移动端、嵌入式都有应用。</p>
</li>
<li>
<p>名称中的HotSpot指的就是它的热点代码探测技术。</p>
<ul>
<li>通过计数器找到最具编译价值的代码，触发即时编译或栈上替换。</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>JRockit</p>
<ul>
<li>专注于服务端应用
<ul>
<li>它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即使编译器编译后执行。</li>
</ul>
</li>
<li>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM。</li>
<li>优势：全面的Java运行时解决方案组合
<ul>
<li>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要。</li>
<li>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>J9</p>
<ul>
<li>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途JVM。</li>
<li>广泛用于IBM的各种Java产品。</li>
<li>目前，有影响力的三大商用虚拟机之一，已号称是世界上最快的Java虚拟机。</li>
</ul>
</li>
<li>
<p>KVM和CDC/CLDC HotSpot</p>
<ul>
<li>目前移动领域地位尴尬，智能手机被Android和IOS二分天下。</li>
<li>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场
<ul>
<li>智能控制器、传感器</li>
<li>老人手机、经济欠发达地区的功能手机</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Azul VM</p>
<ul>
<li>这里Azul VM和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机。</li>
<li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li>
</ul>
</li>
<li>
<p>Liquid VM</p>
<ul>
<li>Liquid VM即是现在的JRockit VE （Virtual Edition） ，Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</li>
</ul>
</li>
<li>
<p>Apache Harmony</p>
<ul>
<li>Apache也曾经推出过与JDK 1.5和JDK 1.6兼容的Java运行平台Apache Harmony。</li>
<li>它是IBM和Intel联合开发的开源JVM，受到同样开源的OpenJDK的压制，sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK。</li>
<li>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</li>
</ul>
</li>
<li>
<p>Microsoft JVM</p>
<ul>
<li>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</li>
<li>只能在window平台下运行。但确是当时windows下性能最好的Java VM。</li>
<li>1997年，sun以侵犯商标、不正当竞争罪名指控微软成功，赔了sun很多钱。微软在windows XP SP3中抹掉了其VM。现在windows上安装的JDK都是HotSpot。</li>
</ul>
</li>
<li>
<p>Taobao JVM</p>
<ul>
<li>
<p>由Ali JVM 团队发布，基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。|</p>
</li>
<li>
<p>基于OpenJDK HotSpot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p>
<ul>
<li>
<p>创新的GCIH (GC invisible heap ）技术实现了off-heap ，即将生命周期。较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</li>
<li>
<p>GCIH 中的对象还能够在多个Java虚拟机进程中实现共享。</p>
</li>
<li>
<p>使用crc32指令实现JVM intrinsic，降低JNI 的调用开销。</p>
</li>
<li>
<p>PMU hardware 的Java profiling tool 和诊断协助功能。</p>
</li>
<li>
<p>针对大数据场景的ZenGC。</p>
</li>
</ul>
</li>
<li>
<p>Taobao VM应用在阿里产品上性能高，硬件严重依赖intel的CPU，损失了兼容性，但提高了性能。</p>
<ul>
<li>目前已经在淘宝、天猫上线，把Oracle官方JVM版本全部替换了。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dalvik VM</p>
<ul>
<li>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</li>
<li><font color='red'> Dalvik VM只能称作虚拟机，而不能称作“Java 虚拟机”</font>，它没有遵循Java虚拟机规范。</li>
<li>不能直接执行Java 的 class 文件基于寄存器架构，不是JVM的栈架构。</li>
<li>执行的是编译以后的dex (Dalvik Executable）文件。执行效率比较高。</li>
</ul>
</li>
<li>
<p>Graal VM</p>
<ul>
<li>Graal VM在HotSpot VM的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。</li>
<li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件。</li>
<li>如果说HotSpot有一天真的被取代，Graal VM希望最大。但是Java的软件生态没有丝毫变化。</li>
</ul>
</li>
</ol>
<h1 id="二-类加载子系统"><a class="markdownIt-Anchor" href="#二-类加载子系统"></a> 二、类加载子系统</h1>
<h2 id="1-类加载器子系统作用"><a class="markdownIt-Anchor" href="#1-类加载器子系统作用"></a> 1、类加载器子系统作用</h2>
<ul>
<li>类加载器子系统负责从文件系统或网络中加载class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量。</li>
</ul>
<h2 id="2-类的加载过程"><a class="markdownIt-Anchor" href="#2-类的加载过程"></a> 2、类的加载过程</h2>
<h3 id="1加载"><a class="markdownIt-Anchor" href="#1加载"></a> 1）加载</h3>
<ol>
<li>通过一个类的全限定类名获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li><font color="red">在内存中生成一个代表这个类的java.lang.Class对象</font>，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="2链接"><a class="markdownIt-Anchor" href="#2链接"></a> 2）链接</h3>
<ol>
<li>
<p>验证（Verify）</p>
<ul>
<li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身的安全。</li>
<li>主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</li>
</ul>
</li>
<li>
<p>准备（Prepare）</p>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li><font color="red">这里不包含用final修饰的static类变量，因为final在编译的时候已经分配了，准备阶段会显示初始化</font>。</li>
<li><font color="red">这里不会为实例变量分配初始化</font>，类变量会分配到方法区中，而实例类变量会随着对象一起分配到Java堆中。</li>
</ul>
</li>
<li>
<p>解析（Resolve）</p>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再进行。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。</li>
</ul>
</li>
</ol>
<h3 id="3初始化"><a class="markdownIt-Anchor" href="#3初始化"></a> 3）初始化</h3>
<ul>
<li>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;</code>()的过程。</li>
<li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在原文件中出现的顺序执行。</li>
<li><code>&lt;clinit&gt;</code>()不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;</code>()）。</li>
<li>若该类有父类，JVM会保证在子类的<code>&lt;clinit&gt;</code>()执行前，父类的<code>&lt;clinit&gt;</code>()已经执行完毕。</li>
<li>虚拟机必须保证一个类的<code>&lt;clinit&gt;</code>()方法在多线程下被同步加锁。</li>
</ul>
<h2 id="3-类加载器的分类"><a class="markdownIt-Anchor" href="#3-类加载器的分类"></a> 3、类加载器的分类</h2>
<ul>
<li>JVM支持两种类型的类加载器，分别是引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</li>
<li>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</li>
<li>无论类加载器的类型如何区分，在程序中我们最常见的类加载器始终只有三个，如下所示：</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-240301594b5b782545715a.png" alt="常见的类加载器-240301" /></p>
<hr />
<h3 id="虚拟机自带的加载器"><a class="markdownIt-Anchor" href="#虚拟机自带的加载器"></a> 虚拟机自带的加载器</h3>
<ul>
<li>
<p>启动类加载器（引导类加载器，Bootstrap ClassLoader）</p>
<ul>
<li>这个类加载器是使用C/C++语言实现的，嵌套在JVM内部。</li>
<li>它用来加载Java的核心类库（JAVA_HOME/jre/lib/rt.jar、resources.jar或<code>sun.boot.class.path</code>路径下的内容），用于提供JVM自身需要的类。</li>
<li>并不继承java.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用类加载器，并指定它们的父类加载器。</li>
<li>处于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun开头的类。</li>
</ul>
</li>
<li>
<p>扩展类加载器（Extension ClassLoader）</p>
<ul>
<li>Java语言编写，由<code>sun.misc.Launcher$ExtClassLoader</code>实现。</li>
<li>派生于ClassLoader类。</li>
<li>父类加载器为启动类加载器。</li>
<li>从<code>java.ext.dirs</code>系统属性所指定的目录加载类库，或从JDK安装目录JAVA_HOME/jre/lib/ext子目录（扩展目录）下加载类库。<font color="red">如果用户创建的jar包放在此目录下，也会自动由扩展类加载器加载。</font></li>
</ul>
</li>
<li>
<p>应用类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li>Java语言编写，由<code>sun.misc.Launcher$AppClassLoader</code>实现。</li>
<li>派生于ClassLoader类。</li>
<li>父类加载器为扩展类加载器。</li>
<li>它负责加载环境变量classpath或环境属性<code>java.class.path</code>指定路径下的类库。</li>
<li><font color="red">该类加载器是程序中默认的类加载器。</font>一般来说，Java应用的类都是由它来完成加载。</li>
<li>通过<code>ClassLoader.getSystemClassLoader()</code>方法可以获取该类加载器。</li>
</ul>
</li>
</ul>
<h3 id="几种类加载器的使用体会"><a class="markdownIt-Anchor" href="#几种类加载器的使用体会"></a> 几种类加载器的使用体会</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;systemClassLoader = &quot;</span> + systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取其上层： 扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;extClassLoader = &quot;</span> + extClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取其上层：获取不到引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span> extClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrapClassLoader = &quot;</span> + bootstrapClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户自定义类的类加载：使用系统类加载器来加载</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String是使用引导类加载器加载的（Java的核心类库都是如此）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">stringClassLoader</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;stringClassLoader = &quot;</span> + stringClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemClassLoader = sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">extClassLoader = sun.misc.Launcher$ExtClassLoader@15db9742</span><br><span class="line">bootstrapClassLoader = null</span><br><span class="line">classLoader = sun.misc.Launcher$AppClassLoader@73d16e93</span><br><span class="line">stringClassLoader = null</span><br></pre></td></tr></table></figure>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====BootstrapClassLoader=====&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取BootstrapClassLoader能够加载的Api路径</span></span><br><span class="line">        URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">            System.out.println(urL.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上面位置中随意选择一个类，看看它的类加载器是什么：引导类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Provider.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=====ExtClassLoader=====&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">exitDirs</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String path : exitDirs.split(<span class="string">&quot;;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上面位置中随意选择一个类，看看它的类加载器是什么：扩展类加载器</span></span><br><span class="line">        classLoader = CurveDB.class.getClassLoader();</span><br><span class="line">        System.out.println(<span class="string">&quot;classLoader = &quot;</span> + classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=====BootstrapClassLoader=====</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/resources.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/rt.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/sunrsasign.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jsse.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jce.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/charsets.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/lib/jfr.jar</span><br><span class="line">file:/D:/java/jdk1.8.0_261/jre/classes</span><br><span class="line">classLoader = null</span><br><span class="line">=====ExtClassLoader=====</span><br><span class="line">D:\java\jdk1.8.0_261\jre\lib\ext</span><br><span class="line">C:\WINDOWS\Sun\Java\lib\ext</span><br><span class="line">classLoader = sun.misc.Launcher$ExtClassLoader@30f39991</span><br></pre></td></tr></table></figure>
<h3 id="用户自定义类加载器"><a class="markdownIt-Anchor" href="#用户自定义类加载器"></a> 用户自定义类加载器</h3>
<ul>
<li>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li>
<p>为什么要自定义类加载器</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
</li>
<li>
<p>用户自定义类加载器实现步骤：</p>
<ol>
<li>
<p>开发人员可以通过继承抽象类<code>java.lang.ClassLoader</code>类的方式，实现自己的类加载器，以满足一些特殊的需求。</p>
</li>
<li>
<p>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写<code>loadClass()</code>方法，从而实现自定义的类加载类。但是在JDK1.2之后已不建议用户去覆盖<code>loadClass()</code>方法，而是建议把自定义的类加载逻辑写在<code>findClass()</code>方法中。</p>
</li>
<li>
<p>在编写自定义类加载器时，如果没有太过复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写<code>findClass()</code>方法及其获取字节码流的方式，是自定义类加载器编写更加简洁。</p>
</li>
</ol>
</li>
</ul>
<h2 id="4-双亲委派机制"><a class="markdownIt-Anchor" href="#4-双亲委派机制"></a> 4、双亲委派机制</h2>
<p>Java虚拟机对class文件采用的是<font color="red">按需加载</font>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<font color="red">双亲委派</font>模式，即把请求交由父类处理。它是一种任务委派模式。</p>
<ul>
<li>
<p>工作原理</p>
<ol>
<li>如果一个类加载器收到了类加载请求，它并不会自己去加载，而是把这个请求委托给父类加载器去执行；</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终到达顶层的启动类加载器；</li>
<li>如果父类加载器可以完成类加载，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ol>
</li>
<li>
<p>优势</p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
</li>
</ul>
<h2 id="5-其他"><a class="markdownIt-Anchor" href="#5-其他"></a> 5、其他</h2>
<p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名一致，包括包名。</li>
<li>加载这两个类的ClassLoader（指ClassLoader实例对象）必须相同。</li>
</ul>
<p>换句话说，在JVM中，即使这两个类对象（class对象）来源于同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个对象也是不相等的。</p>
<hr />
<p>对类加载器的引用</p>
<ul>
<li>JVM必须知道一个类型是由启动类加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器所加载的，那么JVM<font color="red">会将这个类加载器的引用作为类型信息的一部分保存在方法区中。</font>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li>
</ul>
<hr />
<p>类的主动使用和被动使用</p>
<ul>
<li>主动使用，又分为七种情况：
<ul>
<li>创建类的实例</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（比如：<code>Class.forName()</code>）</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>JDK 7开始提供的动态语言支持：
<ul>
<li><code>java.lang.invoke.MethodHandle</code>实例的解析结果</li>
<li><code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</li>
</ul>
</li>
<li>除了以上七种情况，其他使用Java类的方式都被看作是<font color="red">对类的被动引用，都不会导致类的初始化。</font></li>
</ul>
</li>
</ul>
<h1 id="三-运行时数据区概述及线程"><a class="markdownIt-Anchor" href="#三-运行时数据区概述及线程"></a> 三、运行时数据区概述及线程</h1>
<h2 id="1-运行时数据区"><a class="markdownIt-Anchor" href="#1-运行时数据区"></a> 1、运行时数据区</h2>
<p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<font color="red">不同的JVM对于内存的划分方式和管理机制存在着部分差异。</font>结合JVM虚拟机规范，来探讨一下经典的VM内存布局。</p>
<blockquote>
<p>下图来自阿里巴巴手册JDK8</p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/JVM-240301cdc7c5feae0bf7a7.jpeg" alt="JVM运行时数据区划分-240301" /></p>
<hr />
<p><img src="https://img.picgo.net/2025/01/20/JVM-2-240301245de16c7f4cea78.png" alt="JVM运行时数据区划分 (2)-240301" /></p>
<p>Java虚拟机定义了若千种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<ul>
<li>灰色的为单独线程私有的，红色的为多个线程共享的。即：
<ul>
<li>每个线程：独立包括程序计数器、虚拟机栈、本地方法栈</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
</li>
</ul>
<h2 id="2-线程"><a class="markdownIt-Anchor" href="#2-线程"></a> 2、线程</h2>
<ul>
<li>
<p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行执行。</p>
</li>
<li>
<p>在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。</p>
<ul>
<li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也会同时创建。Java线程执行终止后，本地线程也会回收。</li>
</ul>
</li>
<li>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的<code>run()</code>方法。</p>
</li>
</ul>
<h1 id="四-程序计数器pc寄存器"><a class="markdownIt-Anchor" href="#四-程序计数器pc寄存器"></a> 四、程序计数器（PC寄存器）</h1>
<h2 id="1-程序计数器介绍"><a class="markdownIt-Anchor" href="#1-程序计数器介绍"></a> 1、程序计数器介绍</h2>
<p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。</p>
<p>这里并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也成为程序钩子），并且也不容易引起一些不必要的误会。<font color='red'>JVM中的PC寄存器是对物理寄存器的一种抽象模拟。</font></p>
<p>作用：</p>
<p>PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<hr />
<ul>
<li>
<p>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域。</p>
</li>
<li>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
</li>
<li>
<p>任何时间一个线程都只只一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined）。</p>
</li>
<li>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
</li>
<li>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
</li>
<li>
<p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
</li>
</ul>
<hr />
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCRegisterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>javap - v</code> 查看字节码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /F:/IdeaProjects/JVMDemo/target/classes/com/example/java/PCRegisterTest.class</span><br><span class="line">  Last modified 2021年9月13日; size 673 bytes</span><br><span class="line">  SHA-256 checksum 5e7afa6c22e208e5060ed0ea958666594fe013313113a3c4314f3d6fb6ca8b88</span><br><span class="line">  Compiled from &quot;PCRegisterTest.java&quot;</span><br><span class="line">public class com.example.java.PCRegisterTest</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #5                          // com/example/java/PCRegisterTest</span><br><span class="line">  super_class: #6                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#26         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #27            // str</span><br><span class="line">   #3 = Fieldref           #28.#29        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #4 = Methodref          #30.#31        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #5 = Class              #32            // com/example/java/PCRegisterTest</span><br><span class="line">   #6 = Class              #33            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/example/java/PCRegisterTest;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               i</span><br><span class="line">  #19 = Utf8               I</span><br><span class="line">  #20 = Utf8               j</span><br><span class="line">  #21 = Utf8               k</span><br><span class="line">  #22 = Utf8               s</span><br><span class="line">  #23 = Utf8               Ljava/lang/String;</span><br><span class="line">  #24 = Utf8               SourceFile</span><br><span class="line">  #25 = Utf8               PCRegisterTest.java</span><br><span class="line">  #26 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #27 = Utf8               str</span><br><span class="line">  #28 = Class              #34            // java/lang/System</span><br><span class="line">  #29 = NameAndType        #35:#36        // out:Ljava/io/PrintStream;</span><br><span class="line">  #30 = Class              #37            // java/io/PrintStream</span><br><span class="line">  #31 = NameAndType        #38:#39        // println:(I)V</span><br><span class="line">  #32 = Utf8               com/example/java/PCRegisterTest</span><br><span class="line">  #33 = Utf8               java/lang/Object</span><br><span class="line">  #34 = Utf8               java/lang/System</span><br><span class="line">  #35 = Utf8               out</span><br><span class="line">  #36 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #37 = Utf8               java/io/PrintStream</span><br><span class="line">  #38 = Utf8               println</span><br><span class="line">  #39 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.example.java.PCRegisterTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/example/java/PCRegisterTest;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=5, args_size=1</span><br><span class="line">         0: iconst_1</span><br><span class="line">         1: istore_1</span><br><span class="line">         2: iconst_2</span><br><span class="line">         3: istore_2</span><br><span class="line">         4: iload_1</span><br><span class="line">         5: iload_2</span><br><span class="line">         6: iadd</span><br><span class="line">         7: istore_3</span><br><span class="line">         8: ldc           #2                  // String str</span><br><span class="line">        10: astore        4</span><br><span class="line">        12: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        15: iload_1</span><br><span class="line">        16: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        19: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        22: iload_3</span><br><span class="line">        23: invokevirtual #4                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        26: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 2</span><br><span class="line">        line 14: 4</span><br><span class="line">        line 16: 8</span><br><span class="line">        line 17: 12</span><br><span class="line">        line 18: 19</span><br><span class="line">        line 19: 26</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      27     0  args   [Ljava/lang/String;</span><br><span class="line">            2      25     1     i   I</span><br><span class="line">            4      23     2     j   I</span><br><span class="line">            8      19     3     k   I</span><br><span class="line">           12      15     4     s   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;PCRegisterTest.java&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>左边的数字代表指令地址（指令偏移），即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/PC-2403012479a887ab9c9e6e.jpg" alt="PC寄存器的作用-240301" /></p>
<h2 id="2-两个常见面试题"><a class="markdownIt-Anchor" href="#2-两个常见面试题"></a> 2、两个常见面试题</h2>
<ol>
<li>
<p>使用PC寄存器存储字节码指令有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<blockquote>
<p>因为CPU需要不停的切换各个线程，切换回来以后，就得知道接着从哪里开始执行。</p>
<p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行的字节码指令。</p>
</blockquote>
</li>
<li>
<p>PC寄存器为什么会被设定为线程私有？</p>
<blockquote>
<p><font color="red">为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，</font>这样一来各个线程直接便可以进行独立计算，从而不会出现相互干扰的情况。</p>
</blockquote>
</li>
</ol>
<h2 id="3-cpu时间片"><a class="markdownIt-Anchor" href="#3-cpu时间片"></a> 3、CPU时间片</h2>
<ol>
<li>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</li>
<li>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</li>
<li>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</li>
</ol>
<h1 id="五-虚拟机栈"><a class="markdownIt-Anchor" href="#五-虚拟机栈"></a> 五、虚拟机栈</h1>
<h2 id="1-虚拟机栈的主要特点"><a class="markdownIt-Anchor" href="#1-虚拟机栈的主要特点"></a> 1、虚拟机栈的主要特点</h2>
<ul>
<li>
<p>虚拟机栈出现的背景</p>
<blockquote>
<p>由于跨平台的设计，Java的指令是根据栈来设计的。不同平台CPU架构不同，所以不能设计基于寄存器的。</p>
<p><font color="red">优点是跨平台，指令集小，编译器更容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</font></p>
</blockquote>
</li>
<li>
<p>内存中的栈和堆</p>
<blockquote>
<p><font color="red">栈是运行时单位，而堆是存储的单位。</font></p>
<p>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储问题，即数据怎么放、放在哪。</p>
</blockquote>
</li>
<li>
<p>虚拟机栈的基本内容</p>
<ul>
<li>
<p>Java虚拟机栈是什么？</p>
<blockquote>
<p>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。是线程私有的。</p>
</blockquote>
</li>
<li>
<p>生命周期</p>
<blockquote>
<p>生命周期与线程一致。</p>
</blockquote>
</li>
<li>
<p>作用</p>
<blockquote>
<p>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>栈的特点（优点）</p>
<ul>
<li>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li>
<p>JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着入栈</li>
<li>执行结束后的出栈工作</li>
</ul>
</li>
<li>
<p>对于栈来说不存在垃圾回收问题</p>
</li>
</ul>
</li>
</ul>
<hr />
<h3 id="面试题开发中遇到的异常有哪些"><a class="markdownIt-Anchor" href="#面试题开发中遇到的异常有哪些"></a> 面试题：开发中遇到的异常有哪些？</h3>
<p>栈中可能出现的异常</p>
<ul>
<li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
<ul>
<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个<font color="red">StackOverFlowError</font>异常。</li>
<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机会抛出一个<font color="red">OutOfMemoryError</font>异常。</li>
</ul>
</li>
</ul>
<p><em>PS：设置栈内存的大小</em></p>
<blockquote>
<p><em>我们可以使用参数<code>-Xss</code>来设置线程的最大栈空间。栈的大小直接决定了函数调用的最大可达深度。</em></p>
</blockquote>
<h2 id="2-栈的存储单位"><a class="markdownIt-Anchor" href="#2-栈的存储单位"></a> 2、栈的存储单位</h2>
<ol>
<li>
<p>栈中存储什么？</p>
<ul>
<li>
<p>每个线程都有自己的栈，栈里的数据都是以<font color="red">栈帧（Stack Frame）的格式存在。</font></p>
</li>
<li>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
</li>
<li>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
</li>
<li>
<p>栈运行原理</p>
<ul>
<li>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
</li>
<li>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<font color="red">当前栈帧（Current Frame）</font>，与当前栈帧相对应的方法就是<font color="red">当前方法（Current Method）</font>，定义这个方法的类就是<font color="red">当前类（Current Class）</font>。</p>
</li>
<li>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
</li>
<li>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈。</p>
</li>
<li>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
</li>
<li>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
</li>
<li>
<p>Java方法有两种返回函数的方式，<font color="red">一种是正常的函数返回，使用return指令；另一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</font></p>
</li>
</ul>
</li>
<li>
<p>栈的内部结构</p>
<p>每个栈帧存储着：</p>
<ul>
<li><font color="red">局部变量表（Local Variables）</font></li>
<li><font color="red">操作数栈（Operand Stack）（或表达式栈）</font></li>
<li>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
</li>
</ol>
<h2 id="3-局部变量表local-variables"><a class="markdownIt-Anchor" href="#3-局部变量表local-variables"></a> 3、局部变量表（Local Variables）</h2>
<ul>
<li>局部变量表也称之为局部变量数组或本地变量表</li>
<li><font color="red">定义一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</font>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</li>
<li>由于局部变量表示建立在线程的栈上，是线程的私有数据，因此<font color="red">不存在数据安全问题。</font></li>
<li><font color="red">局部变量表所需的容量大小是在编译期确定下来的</font>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</li>
<li><font color="red">方法嵌套调用的次数由栈的大小决定。</font>一般来说，<font color="red">栈越大，方法嵌套调用次数越多。</font>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li>
<li><font color="red">局部变量表中的变量只在当前方法调用中有效。</font>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<font color="red">当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</font></li>
</ul>
<h3 id="关于slot的理解"><a class="markdownIt-Anchor" href="#关于slot的理解"></a> 关于Slot的理解</h3>
<ul>
<li>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</li>
<li>局部变量表，<font color="red">最基本的存储单元是Slot（变量槽）。</font></li>
<li>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li>
<li>在局部变量表里，<font color="red">32位以内的类型只占用一个Slot（包括returnAddress类型），64位的类型（long和double）占用两个Slot。</font>
<ul>
<li>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。</li>
</ul>
</li>
<li>JVM会为局部变量表中的每一个Slot分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。</li>
<li>当一个实例方法被调用的时候，它的方法参数和方法内部定义的局部变量将会<font color="red">按照顺序</font>被复制到局部变量表中的每一个Slot上。</li>
<li>如果需要访问局部变量表中一个64bit的局部变量值时，<font color="red">只需要使用前一个索引即可</font>。（比如访问long和double类型变量）</li>
<li>如果当前帧是由构造方法或者实例方法创建的，那么<font color="red">该对象引用this将会存放在index0的Slot处</font>，其余参数按照参数表顺序继续排列。</li>
</ul>
<p><em>Slot的重复利用</em></p>
<blockquote>
<p><em><font color="red">栈帧中的局部变量表的槽位是可以重用的</font>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能复用过期局部变量的槽位，从而<font color="red">达到节省资源的目的。</font></em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 c 会复用 b 的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充说明：</p>
<ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li>
<li><font color="red">局部变量表中的对象也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></li>
</ul>
<h2 id="4-操作数栈operand-stack"><a class="markdownIt-Anchor" href="#4-操作数栈operand-stack"></a> 4、操作数栈（Operand Stack）</h2>
<ul>
<li>
<p>每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出的操作数栈，也可以称之为表达式栈。（Expression Stack）。</p>
</li>
<li>
<p><font color="red">在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）/出栈（pop）。</font></p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余字节码指令将操作数取出栈。使用它们后再把结果压入栈。</li>
<li>比如：执行复制、交换、求和等操作。</li>
</ul>
</li>
<li>
<p>操作数栈，<font color="red">主要用于保存计算过程的中间结果，同时作为计算过程变量临时的存储空间。</font></p>
</li>
<li>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<font color="red">这个方法的操作数栈是空的。</font></p>
</li>
<li>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<code>max_stack</code>的值。</p>
</li>
<li>
<p>栈中的任何一个元素可以是任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度。</li>
<li>64bit的类型占用两个栈单位深度。</li>
</ul>
</li>
<li>
<p>操作数栈<font color="red">并非采用索引的方式来进行数据访问的，</font>而是只能通过标准的入栈和出栈操作来完成一次数据访问。</p>
</li>
<li>
<p><font color="red">如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</font>并更新PC寄存器中下一条需要执行的字节码指令。</p>
</li>
<li>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
</li>
<li>
<p>另外，我们说Java虚拟机的<font color="red">执行引擎是基于栈的执行引擎，</font>其中的栈指的就是操作数栈。</p>
</li>
</ul>
<p><strong>栈顶缓存（Top-of-Stack-Cashing）技术</strong></p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</p>
<h2 id="5-动态链接dynamic-linking"><a class="markdownIt-Anchor" href="#5-动态链接dynamic-linking"></a> 5、动态链接（Dynamic Linking）</h2>
<ul>
<li>每一个栈帧内部都包含一个指向运行时常量池中<font color="red">该栈帧所属方法的引用</font>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如：<code>invokedynamic</code>指令。</li>
<li>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在Class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向的方法符号引用来表示的，那么<font color="red">动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</font></li>
</ul>
<p><em>为什么需要常量池呢？</em></p>
<blockquote>
<p><em>常量池的作用，就是为了提供一些符号和常量，便于指令的识别。</em></p>
</blockquote>
<h3 id="方法的调用"><a class="markdownIt-Anchor" href="#方法的调用"></a> 方法的调用</h3>
<p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关。</p>
<ul>
<li>
<p>静态链接：</p>
<blockquote>
<p>当一个字节码文件被装载到JVM内部时，如果被调用的<font color="red">目标方法在编译期可知，</font>且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程成为静态链接。</p>
</blockquote>
</li>
<li>
<p>动态链接：</p>
<blockquote>
<p>如果<font color="red">被调用的方法在编译期无法确定下来，</font>也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接。</p>
</blockquote>
</li>
</ul>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<font color="red">绑定是一个字段、方法或者类的符号引用被替换为直接引用的过程，这仅仅发生一次。</font></p>
<p>1）方法的绑定机制</p>
<ul>
<li>
<p>早期绑定：</p>
<blockquote>
<p>早期绑定就是指被调用的<font color="red">目标方法如果在编译期可知，且运行期保持不变</font>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</blockquote>
</li>
<li>
<p>晚期绑定：</p>
<blockquote>
<p>如果<font color="red">被调用的方法在编译期无法确认下来，只能够在程序运行期间根据实际的类型绑定相关的方法</font>，这种绑定方式称为晚期绑定。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><em>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<font color="red">这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</font></em></p>
<p><em>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C<ins>语言中的虚函数（C</ins>中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字<code>final</code>来标记这个方法。</em></p>
</blockquote>
<p>2）虚方法和非虚方法</p>
<p>非虚方法：</p>
<ul>
<li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li>
<li>静态方法、私有方法、final方法、实例构造器、父类（super）方法都是非虚方法。</li>
<li>其他方法为虚方法。</li>
</ul>
<p>虚拟机中提供了以下几条方法调用指令：</p>
<ul>
<li>普通调用指令：
<ol>
<li><strong><code>invokestatic</code>：调用静态方法，解析阶段确定唯一方法版本</strong></li>
<li><strong><code>invokespecial</code>：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</strong></li>
<li><code>invokevirtual</code>：调用所有虚方法</li>
<li><code>invokeinterface</code>：调用接口方法</li>
</ol>
</li>
<li>动态调用指令：<br />
5. <code>invokedynamic</code>：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而<code>invokedynamic</code>指令则支持由用户确定方法版本。其中<code>invokestatic</code>指令和<code>invokespecial</code>指令调用的方法称为非虚方法，其余的（ final修饰的除外）称为虚方法。</p>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();    <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(); <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是重写的父类的静态方法，因为静态方法不能被重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法是非虚方法</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic();  <span class="comment">// invokestatic</span></span><br><span class="line">        showStatic();  <span class="comment">// invokestatic</span></span><br><span class="line"></span><br><span class="line">        showPrivate();  <span class="comment">// invokespecial</span></span><br><span class="line">        <span class="comment">// 非private方法是虚方法</span></span><br><span class="line">        info(); <span class="comment">// invokevirtual</span></span><br><span class="line">        display(<span class="built_in">this</span>);  <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.showCommon(); <span class="comment">// invokespecial</span></span><br><span class="line">        <span class="comment">// 没有显示加super，是虚方法</span></span><br><span class="line">        showCommon();   <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虽然显示为invokevirtual，但此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        showFinal();    <span class="comment">// invokevirtual</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        in.methodA();   <span class="comment">// invokeinterface</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>show()</code>方法的字节码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 invokestatic #4 &lt;Father.showStatic : ()V&gt;</span><br><span class="line"> 3 invokestatic #5 &lt;Son.showStatic : ()V&gt;</span><br><span class="line"> 6 aload_0</span><br><span class="line"> 7 invokespecial #6 &lt;Son.showPrivate : ()V&gt;</span><br><span class="line">10 aload_0</span><br><span class="line">11 invokevirtual #7 &lt;Son.info : ()V&gt;</span><br><span class="line">14 aload_0</span><br><span class="line">15 aload_0</span><br><span class="line">16 invokevirtual #8 &lt;Son.display : (LFather;)V&gt;</span><br><span class="line">19 aload_0</span><br><span class="line">20 invokespecial #3 &lt;Father.showCommon : ()V&gt;</span><br><span class="line">23 aload_0</span><br><span class="line">24 invokevirtual #9 &lt;Son.showCommon : ()V&gt;</span><br><span class="line">27 aload_0</span><br><span class="line">28 invokevirtual #10 &lt;Son.showFinal : ()V&gt;</span><br><span class="line">31 aconst_null</span><br><span class="line">32 astore_1</span><br><span class="line">33 aload_1</span><br><span class="line">34 invokeinterface #11 &lt;Son$MethodInterface.methodA : ()V&gt; count 1</span><br><span class="line">39 return</span><br></pre></td></tr></table></figure>
<p>3）关于invokedynamic指令</p>
<ul>
<li>
<p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个<code>invokedynamic</code>指令，这是<font color="red">Java为了实现『动态类型语言』支持而做的一种改进。</font></p>
</li>
<li>
<p>但是在Java7中并没有提供直接生成<code>invokedynamic</code>指令的方法，需要借助ASM这种底层字节码工具来产生<code>invokedynamic</code>指令。<font color="red">直到Java8的Lambda表达式的出现，<code>invokedynamic</code>指令的生成，在Java中才有了直接的生成方式。</font></p>
</li>
<li>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InvokedynamicTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">IPrint</span> <span class="variable">i</span> <span class="operator">=</span> str -&gt; &#123;</span><br><span class="line">            str += <span class="string">&quot;！&quot;</span>;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPrint</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 invokedynamic #2 &lt;fun, BootstrapMethods #0&gt;</span><br><span class="line">5 astore_1</span><br><span class="line">6 return</span><br></pre></td></tr></table></figure>
<p>4）动态语言和静态语言</p>
<ol>
<li>动态类型语言和静态类型语言两者的区别就在于<font color="red">对类型的检查是在编译期还是在运行期</font>，满足前者就是静态类型语言，反之是动态类型语言。</li>
<li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li>
</ol>
<blockquote>
<p>Java：<code>String info = &quot;hello world&quot;;</code> （Java是静态类型语言，会先编译就进行类型检查）</p>
<p>JS：<code>var info = &quot;hello world&quot;; var info = 10;</code> （运行时才进行检查）</p>
</blockquote>
<p>5）方法重写的本质</p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。
<ul>
<li>如果通过，则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回<code>java.lang.IllegalAccessError</code> 异常</li>
</ul>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果最终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<blockquote>
<p>以上的过程成为动态分派。</p>
</blockquote>
<p><strong><code>IllegalAccessError</code>介绍</strong></p>
<ol>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突。</li>
</ol>
<p>6）虚方法表</p>
<ul>
<li>
<p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，<font color="red">为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引来代替查找。</font></p>
</li>
<li>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
</li>
<li>
<p>那么虚方法表什么时候被创建？</p>
<blockquote>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成后，JVM会把该类的方法表也初始化完毕。</p>
</blockquote>
</li>
</ul>
<h2 id="6-方法返回地址return-address"><a class="markdownIt-Anchor" href="#6-方法返回地址return-address"></a> 6、方法返回地址（Return Address）</h2>
<ul>
<li>
<p>存放调用该方法的PC寄存器的值。</p>
</li>
<li>
<p>一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li>
<p>无论通过哪种方式退出，在方法退出后都返回该方法被调用的位置。方法正常退出时，<font color="red">调用者的PC寄存器计数的值作为返回地址，即调用该方法的指令的下一条指令的地址。</font>而异常退出的方法，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
</li>
<li>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
</li>
<li>
<p><font color="red">正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值。</font></p>
</li>
</ul>
<h3 id="方法退出的两种方式"><a class="markdownIt-Anchor" href="#方法退出的两种方式"></a> 方法退出的两种方式</h3>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<p><strong>正常退出</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<font color="red">正常完成出口</font>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：
<ul>
<li><code>ireturn</code>：当返回值是boolean，byte，char，short和int类型时使用</li>
<li><code>lreturn</code>：Long类型</li>
<li><code>freturn</code>：Float类型</li>
<li><code>dreturn</code>：Double类型</li>
<li><code>areturn</code>：引用类型</li>
<li><code>return</code>：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</li>
</ul>
</li>
</ol>
<p><strong>异常退出</strong></p>
<ol>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<font color="red">异常完成出口</font>。</li>
<li>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li>
</ol>
<h2 id="7-一些附加信息"><a class="markdownIt-Anchor" href="#7-一些附加信息"></a> 7、一些附加信息</h2>
<p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>
<h2 id="8-相关面试题"><a class="markdownIt-Anchor" href="#8-相关面试题"></a> 8、相关面试题</h2>
<ul>
<li>
<p>举例栈溢出的情况？（StackOverflowError）</p>
<blockquote>
<p>栈大小分为固定和动态变化。如果是固定的就可能出现<code>StackOverflowError</code>。如果是动态变化的，在申请内存时内存不足时就可能出现<code>OutOfMemoryError</code>。</p>
</blockquote>
</li>
<li>
<p>调整栈大小，就能保证不出现溢出么？</p>
<blockquote>
<p>不能保证不溢出，只能保证SOF出现的几率小。</p>
</blockquote>
</li>
<li>
<p>分配的栈内存越大越好么？</p>
<blockquote>
<p>不是，虽然一定程度内降低了SOF概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的。</p>
</blockquote>
</li>
<li>
<p>垃圾回收是否涉及到虚拟机栈？</p>
<blockquote>
<p>不会</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>是否会出现Error</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC计数器</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>堆</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>方法区</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
</blockquote>
</li>
<li>
<p>方法中定义的局部变量是否线程安全？</p>
<blockquote>
<p>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 何为线程安全？</span></span><br><span class="line"><span class="comment"> *    如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *    如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// s的声明方式是线程安全的（只在方法内部使用）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s的操作过程，是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder s)</span>&#123;</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// s的操作，是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s的操作：是线程安全的（s自己消亡了，最后返回的只是s.toString的一个新对象）</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h1 id="六-本地方法栈"><a class="markdownIt-Anchor" href="#六-本地方法栈"></a> 六、本地方法栈</h1>
<h2 id="1-什么是本地方法"><a class="markdownIt-Anchor" href="#1-什么是本地方法"></a> 1、什么是本地方法？</h2>
<p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其他的编程语言都有这一机制。</p>
<p><font color='red'>标识符native可以与所有其它的java标识符连用，但是abstract除外。</font></p>
<h2 id="2-为什么要使用本地方法"><a class="markdownIt-Anchor" href="#2-为什么要使用本地方法"></a> 2、为什么要使用本地方法？</h2>
<p>Java使用起来很方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>
<p>与Java环境外交互：</p>
<p><font color='red'>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。</font>你可以想想Java需要与一些底层系统，如操作系统或者某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用以外的繁琐的细节。</p>
</li>
<li>
<p>与操作系统的交互</p>
<ol>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li>
<li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li>
<li><font color='red'>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。</font></li>
<li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ol>
</li>
<li>
<p>Sun’s Java</p>
<ol>
<li><font color='red'>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</font>jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li>
<li>例如：类<code>java.lang.Thread</code>的<code>setPriority()</code>方法是用Java实现的，但是它实现调用的是该类里的本地方法<code>setPriority0()</code>。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 <code>setpriority()</code> API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li>
</ol>
</li>
</ul>
<h2 id="3-本地方法的现状"><a class="markdownIt-Anchor" href="#3-本地方法的现状"></a> 3、本地方法的现状</h2>
<p><font color='red'>目前该方法使用的越来越少了，除非是与硬件有关的应用，</font>比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p>
<h2 id="4-本地方法栈"><a class="markdownIt-Anchor" href="#4-本地方法栈"></a> 4、本地方法栈</h2>
<ol>
<li>
<p><font color='red'>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</font></p>
</li>
<li>
<p>本地方法栈，也是线程私有的。</p>
</li>
<li>
<p>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）</p>
<ul>
<li>
<p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</p>
</li>
<li>
<p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</p>
</li>
</ul>
</li>
<li>
<p>本地方法一般是使用C语言或C++语言实现的。</p>
</li>
<li>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p>
</li>
</ol>
<p><strong>PS：</strong></p>
<blockquote>
<ul>
<li>
<p><font color='red'>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</font></p>
<ul>
<li>本地方法可以通过本地方法接口来<font color='red'>访问虚拟机内部的运行时数据区。</font></li>
<li>它甚至可以直接使用本地处理器中的寄存器。</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li>
<p><font color='cornflowerblue'>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</font>如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
</li>
<li>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
</li>
</ul>
</blockquote>
<h1 id="七-堆"><a class="markdownIt-Anchor" href="#七-堆"></a> 七、堆</h1>
<h2 id="1-堆的核心概述"><a class="markdownIt-Anchor" href="#1-堆的核心概述"></a> 1、堆的核心概述</h2>
<ol>
<li>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</li>
<li>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</li>
<li>《Java虚拟机规范》规定，堆可以处于<font color='red'>物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</font></li>
<li>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</li>
<li>《Java虚拟机规范》中对Java堆的描述是：<font color='red'>所有的对象实例以及数组都应当在运行时分配在堆上。</font>（The heap is the run-time data area from which memory for all class instances and arrays is allocated）
<ul>
<li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li>
</ul>
</li>
<li>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</li>
<li>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
<ul>
<li>也就是触发了GC的时候，才会进行回收。</li>
<li>在垃圾回收过程中经常涉及到对对象的挪动，进而导致需要对对象引用进行更新。为了保证引用更新的正确性，Java将暂停所有其他的线程，这种情况被称为“Stop-The-World”，导致系统全局停顿，用户线程受到影响。</li>
</ul>
</li>
<li>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</li>
</ol>
<h2 id="2-堆的内存细分"><a class="markdownIt-Anchor" href="#2-堆的内存细分"></a> 2、堆的内存细分</h2>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ul>
<li>
<p>Java7及之前的堆内存逻辑上分为三部分：新生区+养老区+<font color='red'>永久区</font></p>
<ul>
<li>Young Generation Space 		新生区			Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space         养老区            Old/Tenure</li>
<li>Permanent Space                      永久区            Perm</li>
</ul>
</li>
<li>
<p>Java8及之后的堆内存逻辑上分为三部分：新生区+养老区+<font color='red'>元空间</font></p>
<ul>
<li>Young Generation Space 		新生区			Young/New
<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Tenure generation space         养老区            Old/Tenure</li>
<li>Meta Space                                 永久区            Meta</li>
</ul>
</li>
</ul>
<blockquote>
<p>约定：新生区&lt;=&gt;新生代&lt;=&gt;年轻代		养老区&lt;=&gt;老年区&lt;=&gt;老年代		永久区&lt;=&gt;永久代</p>
</blockquote>
<h2 id="3-堆空间大小的设置"><a class="markdownIt-Anchor" href="#3-堆空间大小的设置"></a> 3、堆空间大小的设置</h2>
<ul>
<li>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项<code>-Xms</code>和<code>-Xmx</code>来进行设置。
<ul>
<li><code>-Xms</code>用于表示堆区的起始内存，等价于<code>-XX:InitalHeapSize</code></li>
<li><code>-Xmx</code>用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li>
</ul>
</li>
<li>一旦堆区中的内存大小超过<code>-Xmx</code>所指定的最大内存时，将会抛出<code>OutOfMemoryError</code>异常。</li>
<li>通常会将<code>-Xms</code>和<code>-Xmx</code>两个配置相同的值，其<font color='red'>目的是为了能够在Java垃圾回收器机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</font></li>
<li>默认情况下，初始内存大小=物理内存大小/64，最大内存大小=物理内存大小/4。</li>
</ul>
<p><strong>JVisualVM可视化查看堆内存</strong></p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testOOM</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[random.nextInt(<span class="number">1024</span> * <span class="number">1024</span>)]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开jvisualvm查看Visual GC：</p>
<p><img src="https://img.picgo.net/2025/01/20/Visual_GC-240301c4ec1bb1944d5b97.jpg" alt="Visual_GC-240301" /></p>
<p>此时程序也报了OOM异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at HeapTest.testOOM(HeapTest.java:<span class="number">59</span>)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="4-年轻代和老年代"><a class="markdownIt-Anchor" href="#4-年轻代和老年代"></a> 4、年轻代和老年代</h2>
<ul>
<li>
<p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</li>
<li>另一类对象的生命周期却非常长，在某些极端的环境下还能够与JVM的生命周期保持一致。</li>
</ul>
</li>
<li>
<p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和年老代（OldGen）。</p>
</li>
<li>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。</p>
</li>
<li>
<p>配置新生代与老年代在堆结构的占比：</p>
<ul>
<li>默认<code>-XX:NewRatio=2</code>，表示新生代占1，老年代占2，新生代占整个堆的1/3。</li>
<li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占1，老年代占4，新生代占整个堆的1/5。</li>
</ul>
</li>
<li>
<p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1。</p>
</li>
<li>
<p>可以通过选项<code>-XX:SurvivorRatio</code>调整这个空间比例。比如<code>-XX:SurvivorRatio=6</code>表示6 : 1 : 1。</p>
</li>
<li>
<p><font color='red'>几乎所有</font>的Java对象都是在Eden区被new出来的。</p>
</li>
<li>
<p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p>
</li>
<li>
<p>可以使用选项<code>-Xmn</code>设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
</li>
</ul>
<h2 id="5-对象分配过程"><a class="markdownIt-Anchor" href="#5-对象分配过程"></a> 5、对象分配过程</h2>
<p>​	为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<ol>
<li>
<p>new的对象先放伊甸园区。此区有大小限制。</p>
</li>
<li>
<p>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</p>
</li>
<li>
<p>然后将伊甸园中的剩余对象移动到幸存者0区。</p>
</li>
<li>
<p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p>
</li>
<li>
<p>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p>
</li>
<li>
<p>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，</p>
<p>设置 JVM 参数：<code>-XX:MaxTenuringThreshold=N</code> 进行设置。</p>
</li>
<li>
<p>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p>
</li>
<li>
<p>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</p>
</li>
</ol>
<hr />
<p><strong>图解对象分配过程</strong></p>
<ul>
<li>我们创建的对象，一般都是存放在Eden区的，<font color='red'>当我们Eden区满了后，就会触发GC操作</font>，一般被称为 <code>YGC / Minor GC</code>操作</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC1-240301539459107f91fa1f.png" alt="Minor GC1-240301" /></p>
<ul>
<li>
<p>当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个<font color='red'>年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</font></p>
</li>
<li>
<p>同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个Minor GC操作，此时<font color='red'>GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To区，同时让存活的对象年龄 + 1。</font></p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC2-2403014b8cecb8c17dbb91.png" alt="Minor GC2-240301" /></p>
<ul>
<li>我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次<code>Promotion</code>晋升的操作，也就是将<font color='red'>年轻代中的对象晋升到老年代中。</font></li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/Minor-GC3-24030130268c288ab6d016.png" alt="Minor GC3-240301" /></p>
<p><strong>总结：</strong></p>
<ul>
<li>
<p>针对幸存者s0，s1区的总结：复制之后有交换，谁空谁是to。</p>
</li>
<li>
<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。</p>
</li>
</ul>
<p><strong>特殊情况说明：</strong></p>
<ol>
<li>
<p>特别注意，在Eden区满了的时候，才会触发Minor GC，<font color='red'>而幸存者区满了后，不会触发MinorGC操作</font>。</p>
</li>
<li>
<p>如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代。</p>
</li>
<li>
<p>如果来了一个新对象，先看看 Eden 是否放的下？</p>
<blockquote>
<p>如果 Eden 放得下，则直接放到 Eden 区。</p>
<p>如果 Eden 放不下，则触发 YGC ，执行垃圾回收之后再看看Eden还能不能放下？放得下就放。</p>
</blockquote>
</li>
<li>
<p>将对象放到老年区又有两种情况：</p>
<blockquote>
<p>如果 Eden 执行了 YGC 还是无法放不下该对象，那直接放老年代。<br />
万一老年代都放不下，则先触发Full GC ，Full GC后看老年代能不能放下，如果还是放不下，就报OOM错误。</p>
</blockquote>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-2403015e3e922afdeb44d7.png" alt="对象分配过程-240301" /></p>
<h2 id="6-常用调优工具"><a class="markdownIt-Anchor" href="#6-常用调优工具"></a> 6、常用调优工具</h2>
<ol>
<li>JDK命令行</li>
<li>Eclipse: Memory Analyzer Tool</li>
<li><font color='red'>Jconsole</font></li>
<li><font color='red'>Visual VM（实时监控）</font></li>
<li><font color='red'>Jprofiler</font></li>
<li><font color='red'>Java Flight Recorder（实时监控）</font></li>
<li>GCViewer</li>
<li>GCEasy</li>
</ol>
<h2 id="7-gc回收器"><a class="markdownIt-Anchor" href="#7-gc回收器"></a> 7、GC回收器</h2>
<h3 id="71-分代收集思想"><a class="markdownIt-Anchor" href="#71-分代收集思想"></a> 7.1 分代收集思想</h3>
<blockquote>
<ul>
<li>Minor GC: 只清除新生代的垃圾</li>
<li>Major GC: 只清除老年代的垃圾</li>
<li>Full GC: 对整个堆, 以及方法区的垃圾进行清除</li>
</ul>
</blockquote>
<ol>
<li>JVM的调优的一个环节，也就是垃圾收集，我们需要<font color='red'>尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上。</font></li>
<li>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）。</li>
</ol>
<p><strong>部分收集：</strong></p>
<p>不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的圾收集。
<ul>
<li>目前，只有CMS GC会有单独收集老年代的行为。</li>
<li><font color='red'>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></li>
</ul>
</li>
<li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。
<ul>
<li>目前，只有G1 GC会有这种行为。</li>
</ul>
</li>
</ul>
<p><strong>整堆收集：</strong></p>
<p>收集整个Java堆和方法区的垃圾收集。</p>
<h3 id="72-minor-gc"><a class="markdownIt-Anchor" href="#72-minor-gc"></a> 7.2 Minor GC</h3>
<p>年轻代（Minor GC）触发机制：</p>
<ul>
<li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会触发GC。<font color='red'>（当Eden满的时候, 会对Eden进行回收, 顺带也会回收Survivor区的垃圾）</font></li>
<li>因为Java对象<font color='red'>大多都具备朝生夕灭</font>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束后，用户线程才会恢复运行。</li>
</ul>
<h3 id="73-major-gc"><a class="markdownIt-Anchor" href="#73-major-gc"></a> 7.3 Major GC</h3>
<p>老年代（Major GC）触发机制：</p>
<ul>
<li>指发生在老年代的GC，对象从老年代消失时，我们说Major Gc或Full GC发生了。</li>
<li>出现了Major GC，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC。</li>
</ul>
</li>
<li>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</li>
<li>如果Major GC后，内存还不足，就报OOM了。</li>
</ul>
<h3 id="74-full-gc后面细讲"><a class="markdownIt-Anchor" href="#74-full-gc后面细讲"></a> 7.4 Full GC（后面细讲）</h3>
<p>触发Full GC执行的情况有如下五种：</p>
<ol>
<li>调用<code>System.gc()</code>时，系统建议执行Full GC，但不是必然执行。</li>
<li>老年代空间不足。</li>
<li>方法区空间不足。</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存。</li>
<li>由Eden区，Survivor space0（from space） 区向Survivor space1（to space）区复制时，对象大小大于to space可用内存，则把该对象转存到老年代，且老年代的可用内存大小小于该对象大小。</li>
</ol>
<p>说明：<font color='red'>Full GC是开发或调优中尽量要避免的，这样暂停时间会短一些。</font></p>
<h3 id="75-gc日志分析"><a class="markdownIt-Anchor" href="#75-gc日志分析"></a> 7.5 GC日志分析</h3>
<ul>
<li>JVM参数： <code>-Xms9m -Xmx9m -XX:+PrintGCDetails</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">GCtest</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; i++) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">            s = s + s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2048K-&gt;488K(2560K)] 2048K-&gt;789K(9728K), 0.0008126 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2536K-&gt;504K(2560K)] 2837K-&gt;1149K(9728K), 0.0012230 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2552K-&gt;504K(2560K)] 3197K-&gt;1430K(9728K), 0.0006978 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">...</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] 6374K-&gt;6374K(9216K), 0.0003482 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2048K)] [ParOldGen: 6374K-&gt;6172K(7168K)] 6374K-&gt;6172K(9216K), [Metaspace: 9269K-&gt;9244K(1058816K)], 0.0184342 secs] [Times: user=0.11 sys=0.00, real=0.02 secs] </span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	...</span><br><span class="line">遍历次数为：16</span><br></pre></td></tr></table></figure>
<ul>
<li>在 OOM 之前，一定会触发一次 Full GC ，因为只有在老年代空间不足时候，才会爆出OOM异常。</li>
<li>[PSYoungGen: 2048K-&gt;488K(2560K)]：年轻代总空间为 2560K ，回收前内存占用 2048K ，经过垃圾回收后内存占用 488K。</li>
<li>[ParOldGen: 6374K-&gt;6172K(7168K)]：老年代总空间为 7168K ，回收前内存占用 6374K ，经过垃圾回收后内存占用 6172K。</li>
<li>2048K-&gt;789K(9728K)：堆内存总空间为 9728K ，当前占用 2048K ，经过垃圾回收后内存占用 789K。</li>
<li>[Metaspace: 9269K-&gt;9244K(1058816K)]：元空间总空间为 1058816K，当前占用 9269K，经过垃圾回收后剩余 9244K。</li>
<li>0.0184342 secs ：垃圾回收用时。</li>
</ul>
<h2 id="8-堆空间分代思想"><a class="markdownIt-Anchor" href="#8-堆空间分代思想"></a> 8、堆空间分代思想</h2>
<p><font color='red'>为什么需要把Java堆分代？不分代就无法工作了吗？</font></p>
<blockquote>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：由Eden、两块大小相同的survivor（又称为from/to，s0/s1）构成。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p>其实不分代完全可以，分代的唯一理由就是 : 优化GC性能。如果没有分代，那所有的对象都在一块，GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
</blockquote>
<h2 id="9-内存分配策略"><a class="markdownIt-Anchor" href="#9-内存分配策略"></a> 9、内存分配策略</h2>
<p><strong>内存分配策略或对象提升（Promotion）规则</strong></p>
<p>​	如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每经过一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（默认为15，每个JVM、每个GC都有所不同）时，就会被晋升到老年代。<br />
​	对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置。</p>
<p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p>
<ol>
<li>优先分配到Eden
<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象大都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比Minor GC要更少，因此可能回收起来就会比较慢，就会长时间占用老年代的空间。</li>
</ul>
</li>
<li>大对象直接分配到老年代，尽量避免程序中出现过多的大对象。</li>
<li>长期存活的对象分配到老年代。</li>
<li>动态对象年龄判断
<ul>
<li>如果Survivor区中相同年龄的所有对象占用内存的总和大于Survivor内存容量的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>（年龄阈值）中要求的年龄。</li>
</ul>
</li>
<li>空间分配担保
<ul>
<li><code>-XX:HandlePromotionFailure</code></li>
</ul>
</li>
</ol>
<p><strong>代码示例：</strong></p>
<ul>
<li>JVM参数：<code>-Xms60m -Xmx60m -XX:SurvivorRatio=8 -XX:+PrintGCDetails</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整个过程并没有进行垃圾回收，并且 ParOldGen 区被占用了 20MB 的空间，说明大对象放到了老年代中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 18432K, used 2637K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 16384K, 16% used [0x00000000fec00000,0x00000000fee935c8,0x00000000ffc00000)</span><br><span class="line">  from space 2048K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x0000000100000000)</span><br><span class="line">  to   space 2048K, 0% used [0x00000000ffc00000,0x00000000ffc00000,0x00000000ffe00000)</span><br><span class="line"> ParOldGen       total 40960K, used 20480K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)</span><br><span class="line">  object space 40960K, 50% used [0x00000000fc400000,0x00000000fd800010,0x00000000fec00000)</span><br><span class="line"> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h2 id="10-为对象分配内存"><a class="markdownIt-Anchor" href="#10-为对象分配内存"></a> 10、为对象分配内存</h2>
<p><font color='red'>为什么有TLAB（Thread Local Allocation Buffer）？</font></p>
<ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区的共享数据。</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在<font color='red'>并发环境下从堆区中划分内存空间是线程不安全的。</font></li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li>
</ul>
<p><font color='red'>什么是TLAB？</font></p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<font color='red'>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</font></li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<font color='red'>快速分配策略</font>。</li>
<li>据我所知所有的OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><strong>TLAB的再说明</strong></p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<font color='red'>JVM确实是将TLAB作为内存分配的首选。</font></li>
<li>在程序中，开发人员可以通过选项<code>-XX:UseTLAB</code>设置是否开启TLAB空间。</li>
<li>默认情况下，TLAB空间的内存非常小，<font color='red'>仅占有整个Eden空间的1%</font>，当然我们可以通过选项<code>-XX:TLABWasteTargetPercent</code>设置TLAB空间所占用Eden空间的百分比大小。</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<font color='red'>使用加锁机制</font>确保数据操作的原子性，从而直接在Eden空间中分配内存。</li>
</ul>
<p><strong>TLAB分配过程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/TLAB-24030104a6334a50759597.png" alt="TLAB分配过程-240301" /></p>
<h2 id="11-堆空间参数设置"><a class="markdownIt-Anchor" href="#11-堆空间参数设置"></a> 11、堆空间参数设置</h2>
<h3 id="111-常用参数设置"><a class="markdownIt-Anchor" href="#111-常用参数设置"></a> 11.1 常用参数设置</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvdW5peC9qYXZhLmh0bWw=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li><code>-XX:+PrintFlagsInitial</code>：查看所有的参数的默认初始值</li>
<li><code>-XX:+PrintFlagsFinal</code>：查看所有的参数的最终值（可能会存在修改，不再是初始值）</li>
<li><code>-Xms</code>：初始堆空间内存（默认为物理内存的1/64）</li>
<li><code>-Xmx</code>：最大堆空间内存（默认为物理内存的1/4）</li>
<li><code>-Xmn</code>：设置新生代的大小（初始值及最大值）</li>
<li><code>-XX:NewRatio</code>：配置老年代与新生代在堆结构的占比</li>
<li><code>-XX:SurvivorRatio</code>：设置新生代中Eden和S0/S1空间的比例</li>
<li><code>-XX:MaxTenuringThreshold</code>：设置新生代垃圾的最大年龄，最大可设置为15</li>
<li><code>-XX:+PrintGCDetails</code>：输出详细的GC处理日志</li>
<li><code>-XX:+PrintGC</code>或<code>-verbose:gc</code>：打印GC简要信息</li>
<li><code>-XX:HandlePromotionFalilure</code>：是否设置空间分配担保，当Young GC后，Survivor区仍然满了，就将新对象直接存在老年代</li>
</ol>
<p><strong>PS：</strong></p>
<blockquote>
<p>查看某个参数的指令：</p>
<p><code>jps</code>：查看当前运行中的JVM进程。</p>
<p><code>jinfo -flag SurvivorRatio 进程id</code>：查看某个进程的<code>SurvivorRatio</code>的值。</p>
</blockquote>
<h3 id="112-空间分配担保"><a class="markdownIt-Anchor" href="#112-空间分配担保"></a> 11.2 空间分配担保</h3>
<p>在发生Minor GC之前，虚拟机会<font color='red'>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</font></p>
<ul>
<li>如果大于，则此次Minor GC是安全的。（因为最坏的情况，新生代的所有对象都不需要回收，且它们都达到了晋升老年代的要求，此时将它们都放入到老年代，老年代的内存足够存放它们。）</li>
<li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。
<ul>
<li>如果<code>HandlePromotionFailure=true</code>，那么会继续<font color='red'>检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</font>
<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的。</li>
<li>如果小于，则进行一次Full GC。</li>
</ul>
</li>
<li>如果<code>HandlePromotionFailure=false</code>，则进行一次Full GC。</li>
</ul>
</li>
</ul>
<p>在JDK6 Update 24之后，<code>HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了<code>HandlePromotionFailure</code>参数，但是在代码中已经不会再使用它。<font color='red'>JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。即 <code>HandlePromotionFailure=true</code>。</font></p>
<h2 id="12-堆是分配对象的唯一选择吗"><a class="markdownIt-Anchor" href="#12-堆是分配对象的唯一选择吗"></a> 12、堆是分配对象的唯一选择吗？</h2>
<blockquote>
<p>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</p>
<p>随着JIT编译期的发展与<font color='red'>逃逸分析技术</font>逐渐成熟，<font color='red'>栈上分配、标量替换优化技术</font>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<font color='red'>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</font>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的Taobao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</blockquote>
<h3 id="121-逃逸分析概述"><a class="markdownIt-Anchor" href="#121-逃逸分析概述"></a> 12.1 逃逸分析概述</h3>
<ul>
<li>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li>
<p>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
</li>
<li>
<p>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
</li>
<li>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，对象只能在方法内部使用，则认为没有发生逃逸。</li>
<li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他方法中。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如何快速的判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	对象的作用域仅在当前方法中有效，没有发生逃逸. 方法结束后, 该对象的引用就销毁了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">// getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逃逸分析参数设置</strong></p>
<ul>
<li>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析。</li>
<li>如果使用的是较早的版本，开发人员则可以通过：
<ul>
<li>选项<code>-XX:+DoEscapeAnalysis</code>显式开启逃逸分析。</li>
<li>选项<code>-XX:+PrintEscapeAnalysis</code>查看逃逸分析的筛选结果。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong></p>
<p>开发中能使用局部变量的，就不要在方法外定义变量。（因为成员变量，可能会被多个线程使用，只能放在堆中，可能需要GC。如果是局部变量，存储在虚拟机栈中，是线程私有的，没有线程安全问题，也不需要GC）</p>
<p><strong>逃逸分析代码优化</strong></p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配。</li>
<li>同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<h3 id="122-栈上分配"><a class="markdownIt-Anchor" href="#122-栈上分配"></a> 12.2 栈上分配</h3>
<ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li>
<li>常见的对象逃逸的场景：
<ul>
<li>在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
</li>
</ul>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StackAllocationTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看执行时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// 未发生逃逸</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx1g -Xms1g -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</code>，未开启逃逸分析。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 57 ms</span><br></pre></td></tr></table></figure>
<p>内存占用</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301ac4cf47384d7a2c3.jpg" alt="未开启逃逸分析时的内存占用-240301" /></p>
<ul>
<li>JVM参数：<code>-Xmx1g -Xms1g -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</code>，开启逃逸分析。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 5 ms</span><br></pre></td></tr></table></figure>
<p>内存占用</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301a32e0ccf462adb3a.jpg" alt="开启逃逸分析时的内存占用-240301" /></p>
<h3 id="123-同步省略"><a class="markdownIt-Anchor" href="#123-同步省略"></a> 12.3 同步省略</h3>
<ol>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<font color='red'>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</font>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<font color='red'>锁消除</font>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码中对<code>obj</code>这个对象加锁，但是<code>obj</code>对象的生命周期只在<code>f()</code>方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void f() &#123;</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="124-标量替换"><a class="markdownIt-Anchor" href="#124-标量替换"></a> 12.4 标量替换</h3>
<p><font color='red'>标量（Scalar）</font>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。<br />
相对的，那些还可以分解的数据叫做<font color='red'>聚合量（Aggregate）</font>，Java中的对象就是聚合量，因为它可以分解成其他聚合量和标量。<br />
在JIT编译阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<font color='red'>标量替换</font>。</p>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ScalarReplace</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();    <span class="comment">//未发生逃逸</span></span><br><span class="line">    u.id = <span class="number">5</span>;</span><br><span class="line">    u.name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx128m -Xms128m -XX:+PrintGC -XX:-EliminateAllocations</code>，未开启标量替换。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  33280K-&gt;4175K(125952K), 0.0031847 secs]</span><br><span class="line">[GC (Allocation Failure)  37455K-&gt;2368K(125952K), 0.0013988 secs]</span><br><span class="line">[GC (Allocation Failure)  35648K-&gt;2392K(125952K), 0.0013342 secs]</span><br><span class="line">[GC (Allocation Failure)  35672K-&gt;2352K(125952K), 0.0013205 secs]</span><br><span class="line">[GC (Allocation Failure)  35632K-&gt;2328K(125952K), 0.0013186 secs]</span><br><span class="line">[GC (Allocation Failure)  35608K-&gt;2336K(126976K), 0.0015186 secs]</span><br><span class="line">[GC (Allocation Failure)  37152K-&gt;2277K(126464K), 0.0015978 secs]</span><br><span class="line">花费的时间为： 48 ms</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xmx128m -Xms128m -XX:+PrintGC -XX:+EliminateAllocations</code>，开启标量替换。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花费的时间为： 4 ms</span><br></pre></td></tr></table></figure>
<h3 id="125-逃逸分析的不足"><a class="markdownIt-Anchor" href="#125-逃逸分析的不足"></a> 12.5 逃逸分析的不足</h3>
<ul>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<font color='red'>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</font></li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也<font color='red'>是即时编译器优化技术中一个十分重要的手段。</font></li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<font color='red'>对象实例都是分配在堆上。</font></li>
</ul>
<h2 id="13-小结"><a class="markdownIt-Anchor" href="#13-小结"></a> 13、小结</h2>
<ol>
<li>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</li>
<li>老年代放置长生命周期的对象，通常都是从Survivor区域筛选（年龄计数器为15的对象）拷贝过来的Java对象。</li>
<li>当然，也有特殊情况，我们知道<font color='red'>普通的对象可能会被分配在TLAB上</font>；</li>
<li>如果对象较大，无法分配在TLAB上，则JVM会试图直接分配在Eden其他位置上。</li>
<li>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</li>
<li><font color='red'>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</font></li>
<li><font color='red'>当GC发生在老年代时则被称为Major GC或者Full GC。</font></li>
<li>一般的，Minor GC的发生频率要比Major GC高很多，即<font color='red'>老年代中垃圾回收发生的频率将大大低于年轻代。</font>（因为new的对象一般都分配在新生代，新生代的对象大都是朝生夕死的，所以GC的频率很高）</li>
</ol>
<h1 id="八-方法区"><a class="markdownIt-Anchor" href="#八-方法区"></a> 八、方法区</h1>
<h2 id="1-栈-堆-方法区的交互关系"><a class="markdownIt-Anchor" href="#1-栈-堆-方法区的交互关系"></a> 1、栈、堆、方法区的交互关系</h2>
<p><strong>从内存结构来看</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-240301e9c4a2165f489612.jpg" alt="方法区在运行时数据区的位置-240301" /></p>
<p><strong>从线程共享与否的角度来看</strong></p>
<blockquote>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型应用就是数据库连接管理，以及独立会话管理</p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/-24030155755c1800bb4ec0.jpg" alt="从线程共享与否的角度来看-240301" /></p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<ol>
<li>Person类的.class信息存放在方法区中；</li>
<li>person变量存放在Java栈的局部变量表中；</li>
<li>真正的person对象存放在Java堆中；</li>
<li>在person对象中，有个指针指向方法区中的Person类型数据，表明这个person对象是用方法区中的Person类new出来的。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-240301308aaa7ea4814fd3.jpg" alt="对象的访问定位-240301" /></p>
<h2 id="2-方法区的理解"><a class="markdownIt-Anchor" href="#2-方法区的理解"></a> 2、方法区的理解</h2>
<h3 id="21-方法区的位置"><a class="markdownIt-Anchor" href="#21-方法区的位置"></a> 2.1 方法区的位置</h3>
<p>​	《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言， 方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以，<font color='red'> 方法区可以看作是一块独立于Java堆的内存空间。</font></p>
<h3 id="22-方法区的基本理解"><a class="markdownIt-Anchor" href="#22-方法区的基本理解"></a> 2.2 方法区的基本理解</h3>
<ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。（多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即<font color='red'>类只能加载一次</font>）</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code>。
<ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存。</li>
</ol>
<h3 id="23-方法区的演进"><a class="markdownIt-Anchor" href="#23-方法区的演进"></a> 2.3 方法区的演进</h3>
<p><strong>Hotspot 方法区的演进过程</strong></p>
<ol>
<li>在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。</li>
<li>JDK 1.8后，元空间存放在堆外内存中，我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。
<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过<code>-XX:MaxPermsize</code>上限）</li>
</ul>
</li>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于： <font color='red'>元空间不在虚拟机设置的内存中，而是使用本地内存。</font></li>
<li>永久代、元空间二者并不只是名字变了， 内部结构也调整了。</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。</li>
</ol>
<h2 id="3-设置方法区大小与oom"><a class="markdownIt-Anchor" href="#3-设置方法区大小与oom"></a> 3、设置方法区大小与OOM</h2>
<p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<p><strong>JDK7 之前版本设置永久代大小</strong></p>
<ol>
<li>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是20.75M</li>
<li><code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li>
<li>当JVM加载的类信息容量超过了这个值，会报异常<code>OutofMemoryError:PermGen space</code>。</li>
</ol>
<p><strong>JDK8 版本设置元空间大小</strong></p>
<ol>
<li>元数据区大小可以使用参数<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>指定。</li>
<li>默认值依赖于平台，<font color='cornflowerblue'>Windows下，<code>-XX:MetaspaceSize</code>约为21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，即没有限制。</font></li>
<li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code>。</li>
<li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个64位的服务器端 JVM来说，其默认的<code>-XX:MetaspaceSize</code>值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。
<ul>
<li>如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。</li>
<li>如果释放空间过多，则适当降低该值。</li>
</ul>
</li>
<li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li>
</ol>
<p><strong>代码测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">OOMTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&gt; clazz = ClassLoader.class;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">defineClass</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        defineClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; <span class="number">10000</span>; i++) &#123;    <span class="comment">// 不断生成并加载类</span></span><br><span class="line">            <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">            classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">            defineClass.invoke(<span class="built_in">this</span>, <span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认的 JVM 参数，元空间不设置上限</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM 参数：<code>-XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</code>，设置元空间大小上限为10MB。</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at MethodAreaTest.OOMTest(MethodAreaTest.java:36)</span><br><span class="line">	at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="line">	at java.util.ArrayList.forEach(ArrayList.java:1259)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">	at MethodAreaTest.OOMTest(MethodAreaTest.java:36)</span><br><span class="line">991</span><br></pre></td></tr></table></figure>
<p><strong>如何解决OOM</strong></p>
<ol>
<li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。
<ul>
<li>内存泄漏就是有大量的引用指向某些对象，这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象不会被回收，这就是内存泄漏问题。</li>
</ul>
</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h2 id="4-方法区的内部结构"><a class="markdownIt-Anchor" href="#4-方法区的内部结构"></a> 4、方法区的内部结构</h2>
<h3 id="41-方法区结构"><a class="markdownIt-Anchor" href="#41-方法区结构"></a> 4.1 方法区结构</h3>
<p><img src="https://img.picgo.net/2025/01/20/-2403015da642e992d0b2fb.jpg" alt="方法区结构-240301" /></p>
<p><strong>方法区（Method Area）存储什么？</strong></p>
<blockquote>
<p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机<font color='red'>加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</font></p>
</blockquote>
<p><img src="https://img.picgo.net/2025/01/20/-240301eab8558f1de88aca.jpg" alt="方法区存储什么-240301" /></p>
<p><strong>类型信息</strong></p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于<code>interface</code>或是<code>java.lang.Object</code>，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<p><strong>域（Field）信息</strong></p>
<ol>
<li>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序</li>
<li>域的相关信息包括：
<ul>
<li>域名称</li>
<li>域类型</li>
<li>域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</li>
</ul>
</li>
</ol>
<p><strong>方法（Method）信息</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（包括void返回类型），void在Java中对应的类为<code>void.class</code></li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStructTest</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>反编译字节码文件，并输出值文本文件中，便于查看</li>
<li>参数 -p 确保能查看 private 权限类型的字段或方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javap -v -p MethodInnerStructTest.class &gt; text.txt</span><br></pre></td></tr></table></figure>
<p><strong>类型信息</strong></p>
<ul>
<li>
<p>在方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类。</p>
</li>
<li>
<p>从反编译文件可以看出，字节码文件记录了 <code>MethodInnerStructTest</code> 继承了哪些类，实现了哪些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class com.example.java.MethodInnerStructTest extends java.lang.Object implements java.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>域信息</strong></p>
<ol>
<li>descriptor： I表示字段类型为 Integer</li>
<li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int num;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: (0x0001) ACC_PUBLIC</span><br><span class="line">private static java.lang.String str;</span><br><span class="line">  descriptor: Ljava/lang/String;</span><br><span class="line">  flags: (0x000a) ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>
<p><strong>方法信息</strong></p>
<ol>
<li>descriptor：<code>()V</code> 表示方法返回值类型为 void</li>
<li>flags: <code>ACC_PUBLIC</code> 表示方法权限修饰符为 public</li>
<li><code>stack=3</code> 表示操作数栈深度为 3</li>
<li><code>locals=2</code> 表示局部变量个数为 2 个（实例方法包含 this）</li>
<li><code>test1()</code> 方法虽然没有参数，但是其 <code>args_size</code>=1 ，这时因为将 this 作为了参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: bipush        20</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: new           #4                  // class java/lang/StringBuilder</span><br><span class="line">         9: dup</span><br><span class="line">        10: invokespecial #5                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        13: ldc           #6                  // String count =</span><br><span class="line">        15: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        18: iload_1</span><br><span class="line">        19: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        22: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        28: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 18: 0</span><br><span class="line">        line 19: 3</span><br><span class="line">        line 20: 28</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      29     0  this   Lcom/example/java/MethodInnerStructTest;</span><br><span class="line">            3      26     1 count   I</span><br></pre></td></tr></table></figure>
<h3 id="42-域信息特殊情况"><a class="markdownIt-Anchor" href="#42-域信息特殊情况"></a> 4.2 域信息特殊情况</h3>
<p><strong>non-final 类型的类变量</strong></p>
<ul>
<li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。</li>
<li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它。</li>
</ul>
<p><strong>代码示例</strong></p>
<ol>
<li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常。</li>
<li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodAreaTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    order.hello();</span><br><span class="line">    System.out.println(order.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>全局常量：static final</strong></p>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
<ul>
<li>
<p>反编译查看字节码指令，可以发现 number 的值已经写在字节码文件中了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int count;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">public static final int number;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: int 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="43-运行时常量池"><a class="markdownIt-Anchor" href="#43-运行时常量池"></a> 4.3 运行时常量池</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2p2bXMvc2U4L2h0bWwvanZtcy00Lmh0bWw=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>方法区内部包含了运行时常量池。</li>
<li>字节码文件内部包含了常量池。</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/JVM-24030141a7fd39b3fe63b6.jpg" alt="JVM运行时内存结构-240301" /></p>
<p><strong>常量池</strong></p>
<p>​	一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是常量池表（ Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。</p>
<p><img src="https://img.picgo.net/2025/01/20/class-2403014dfd28a2382f258d.jpg" alt="常量池在class文件中的位置-240301" /></p>
<p><strong>为什么需要常量池？</strong></p>
<ol>
<li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池</li>
<li>这个字节码包含了指向常量池的引用，在动态链接的时候会用到运行时常量池。</li>
</ol>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>虽然上述代码只有194字节，但是里面却使用了<code>String</code>、<code>System</code>、<code>PrintStream</code>及<code>Object</code>等结构。</li>
<li>如果不使用常量池，就需要将用到的类信息、方法信息等记录在当前的字节码文件中，造成文件臃肿</li>
<li>所以我们将所需用到的结构信息记录在常量池中，并通过引用的方式来加载、调用所需的结构。</li>
</ol>
<p><strong>常量池中有什么？</strong></p>
<ol>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ol>
<p><strong>小结：</strong></p>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<hr />
<p><strong>运行时常量池</strong></p>
<ol>
<li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li>
<li>常量池表（Constant Pool Table）是Class字节码文件的一部分，<font color='red'>用于存放编译期生成的各种字面量与符号引用</font>，<font color='cornflowerblue'>这部分内容将在类加载后存放到方法区的运行时常量池中。</font></li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li><font color='red'>JVM为每个已加载的类型（类或接口）都维护一个常量池。</font>池中的数据项像数组项一样，是通过<font color='cornflowerblue'>索引访问</font>的。</li>
<li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。 此时不再是常量池中的符号地址了，这里换为真实地址。</li>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<font color='red'>具备动态性</font>。</li>
<li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li>
<li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛<code>OutOfMemoryError</code>异常。</li>
</ol>
<h2 id="5-方法区图解示例"><a class="markdownIt-Anchor" href="#5-方法区图解示例"></a> 5、方法区图解示例</h2>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图解字节码指令执行流程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-2403014cf6511a1dd334fd.gif" alt="字节码指令执行流程-240301" /></p>
<p><strong>关于【符号引用 --&gt; 直接引用】的理解</strong></p>
<ol>
<li>上面代码调用<code>System.out.println()</code>方法时，首先需要看看<code>System</code>类有没有加载，再看看<code>PrintStream</code>类有没有加载</li>
<li>如果没有加载，则执行加载，<font color='red'>执行时，将常量池中的符号引用（字面量）转换为直接引用（真正的地址值）。</font></li>
</ol>
<p><strong>关于程序计数器的说明</strong></p>
<p>​	程序计数器始终计算的都是当前代码运行的位置，目的是为了方法调用后能够正常返回，或者是进行了CPU切换后，也能回来到原来的代码进行执行。</p>
<h2 id="6-方法区的演进"><a class="markdownIt-Anchor" href="#6-方法区的演进"></a> 6、方法区的演进</h2>
<h3 id="61-永久代演进过程"><a class="markdownIt-Anchor" href="#61-永久代演进过程"></a> 6.1 永久代演进过程</h3>
<ol>
<li>
<p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
</li>
<li>
<p>Hotspot中方法区的变化：</p>
<table>
<thead>
<tr>
<th style="text-align:center">JDK1.6及以前</th>
<th style="text-align:center">有永久代（permanent generation），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>JDK1.7</strong></td>
<td style="text-align:center"><strong>有永久代，但已经逐步 “去永久代”， 字符串常量池、静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>JDK1.8及以后</strong></td>
<td style="text-align:center"><strong>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中</strong></td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="62-元空间出现原因"><a class="markdownIt-Anchor" href="#62-元空间出现原因"></a> 6.2 元空间出现原因</h3>
<ul>
<li>
<p>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<font color='red'>与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</font></p>
</li>
<li>
<p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p>
</li>
<li>
<p>这项改动是很有必要的，原因有：</p>
<ol>
<li>
<p>为永久代设置空间大小是很难确定的。</p>
<p>​	在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p>
<blockquote>
<p><code>Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space</code></p>
</blockquote>
<p>​	而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p>
</li>
<li>
<p>对永久代进行调优是很困难的。</p>
<p>​	有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
<p>​	方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低Full GC。一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
</ol>
</li>
</ul>
<h3 id="63-字符串常量池"><a class="markdownIt-Anchor" href="#63-字符串常量池"></a> 6.3 字符串常量池</h3>
<p><strong>字符串常量池StringTable为什么要调整位置？</strong></p>
<ol>
<li>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</li>
<li>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。 放到堆里，能及时回收内存。</li>
</ol>
<h3 id="64-静态变量位置"><a class="markdownIt-Anchor" href="#64-静态变量位置"></a> 6.4 静态变量位置</h3>
<p><strong>静态变量存放在那里？</strong></p>
<p><strong>代码示例 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>运行环境：JDK8</p>
</li>
<li>
<p>JVM参数：<code>-Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</code></p>
</li>
</ul>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 59904K, used 5171K [0x00000000fbd80000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 51712K, 10% used [0x00000000fbd80000,0x00000000fc28ceb0,0x00000000ff000000)</span><br><span class="line">  from space 8192K, 0% used [0x00000000ff800000,0x00000000ff800000,0x0000000100000000)</span><br><span class="line">  to   space 8192K, 0% used [0x00000000ff000000,0x00000000ff000000,0x00000000ff800000)</span><br><span class="line"> ParOldGen       total 136704K, used 102400K [0x00000000f3800000, 0x00000000fbd80000, 0x00000000fbd80000)</span><br><span class="line">  object space 136704K, 74% used [0x00000000f3800000,0x00000000f9c00010,0x00000000fbd80000)</span><br><span class="line"> Metaspace       used 3473K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>通过 GC 日志可以看出： <font color='red'>静态变量引用对应的对象实体始终都存在堆空间</font></p>
<p><strong>代码示例 2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用jhsdb进行分析（在JDK9后才有此工具）。</p>
</li>
<li>
<p>分析：<code>staticObj</code>随着<code>Test</code>的类型信息存放在方法区，<code>instanceObj</code>随着<code>Test</code>的对象实例存放在Java堆，<code>localObject</code>则是存放在<code>foo()</code>方法栈帧的局部变量表中。（指引用）</p>
</li>
<li>
<p>测试发现：三个对象的数据（指对象本身）在内存中的地址都落在Eden区范围内，所以结论： <font color='red'>只要是对象实例必然会在Java堆中分配</font>。</p>
</li>
<li>
<p>接着，找到了一个引用该<code>staticObj</code>对象的地方，是在一个<code>java.lang.Class</code>的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个<code>java.lang.Class</code>类型的对象实例，里面有一个名为<code>staticObj</code>的实例字段：</p>
<p><img src="https://img.picgo.net/2025/01/20/staticObj-24030138613beab926ed6c.jpg" alt="staticObj的地址-240301" /></p>
</li>
<li>
<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量<font color='red'>与类型在Java语言一端的映射Class对象存放在一起， 存储于Java堆之中</font>，从我们的实验中也明确验证了这一点</p>
</li>
</ul>
<h2 id="7-方法区的垃圾收集"><a class="markdownIt-Anchor" href="#7-方法区的垃圾收集"></a> 7、方法区的垃圾收集</h2>
<p><strong>方法区常量的回收</strong>（关于常量的回收比较简单，重点是类的回收）</p>
<ol>
<li>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用
<ul>
<li>字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等</li>
<li>而符号引用则属于编译原理方面的概念，包括下面三类常量：
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
</li>
<li>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li>
<li>回收废弃常量与回收Java堆中的对象非常类似。</li>
</ol>
<p><strong>方法区类的回收</strong></p>
<ul>
<li>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于”不再被使用的类“的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其<font color='cornflowerblue'>任何派生子类的实例</font>。</li>
<li><font color='cornflowerblue'>加载该类的类加载器已经被回收</font>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，<font color='cornflowerblue'>无法在任何地方通过反射访问该类的方法</font>。</li>
</ol>
</li>
<li>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是&quot;被允许&quot;，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及 <code>-XX:+TraceClass-Loading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</p>
</li>
<li>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<font color='cornflowerblue'>通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</font></p>
</li>
</ul>
<h2 id="8-运行时数据区总结"><a class="markdownIt-Anchor" href="#8-运行时数据区总结"></a> 8、运行时数据区总结</h2>
<ul>
<li>线程私有结构：程序计数器、虚拟机栈、本地方法栈</li>
<li>每个虚拟机栈由具体的栈帧组成，在栈帧的动态链接中，保存了对方法的引用</li>
<li>方法区在JDK7之前，使用永久代实现，在 JDK8 之后，使用元空间实现</li>
<li>Minor GC针对于新生区，Major GC针对于老年区，Full GC针对于整个堆空间和方法区</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/JVM-2403012360f44f709ef021.jpg" alt="JVM运行时数据区-240301" /></p>
<h2 id="9-大厂面试题"><a class="markdownIt-Anchor" href="#9-大厂面试题"></a> 9、大厂面试题</h2>
<ol>
<li>百度
<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：
<ul>
<li>JDK8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个Survivor区？</li>
<li>二面：Eden和Survior的比例分配</li>
</ul>
</li>
<li>小米：
<ul>
<li>JVM内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
<li>字节跳动：
<ul>
<li>二面：JVM的内存分区</li>
<li>二面：讲讲JVM运行时数据区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：
<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</li>
</ul>
</li>
<li>天猫：
<ul>
<li>一面：JVM内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：
<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：
<ul>
<li>JVM内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：JVM内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
<h1 id="九-对象的实例化内存布局与访问定位"><a class="markdownIt-Anchor" href="#九-对象的实例化内存布局与访问定位"></a> 九、对象的实例化内存布局与访问定位</h1>
<h2 id="1-对象的实例化"><a class="markdownIt-Anchor" href="#1-对象的实例化"></a> 1、对象的实例化</h2>
<p><strong>大厂面试题</strong></p>
<p>美团：</p>
<ol>
<li>对象在<code>JVM</code>中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
</ol>
<p>蚂蚁金服：</p>
<ol>
<li>二面：<code>java</code>对象头里有什么？</li>
</ol>
<hr />
<p><img src="https://img.picgo.net/2025/01/20/-2403017c2f6cf428469f43.png" alt="对象的实例化-240301" /></p>
<h3 id="11-对象创建的方式"><a class="markdownIt-Anchor" href="#11-对象创建的方式"></a> 1.1 对象创建的方式</h3>
<ol>
<li><code>new</code>：最常见的方式。或者是单例模式中调用静态类方法，xxxBuilder/xxxFactory的静态方法。</li>
<li><code>Class</code>的<code>newInstance()</code>方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为public。</li>
<li><code>Constructor</code>的<code>newInstance()</code>：反射的方式，可以调用空参的，或者带参的构造器。</li>
<li>使用<code>clone()</code>：不调用任何的构造器，要求当前的类需要实现<code>Cloneable</code>接口中的<code>clone()</code>方法。</li>
<li>使用序列化：从文件中、网络中获取一个对象的二进制流，进行序列化。一般用于Socket的网络传输。</li>
<li>第三方库<code>Objenesis</code>。</li>
</ol>
<h3 id="12-对象创建的步骤"><a class="markdownIt-Anchor" href="#12-对象创建的步骤"></a> 1.2 对象创建的步骤</h3>
<ol>
<li>
<p>判断对象对应的类是否加载、链接、初始化</p>
<ul>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</li>
<li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出<code>ClassNotFoundException</code>异常，如果找到，则进行类加载，并生成对应的Class对象。</li>
</ul>
</li>
<li>
<p>为对象分配内存</p>
<ul>
<li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。</li>
<li>如果内存规整：采用指针碰撞分配内存
<ul>
<li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存时只需把指针往空闲内存那边挪动一段与对象大小相等的距离。</li>
<li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域。</li>
</ul>
</li>
<li>如果内存不规整
<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li>
<li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为 “空闲列表（Free List）”。</li>
</ul>
</li>
<li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li>
</ul>
</li>
<li>
<p>处理并发问题</p>
<ol>
<li>采用CAS+失败重试保证更新的原子性。</li>
<li>每个线程预先分配TLAB——通过<code>-XX:+UseTLAB</code>参数来设置（区域加锁机制）。</li>
</ol>
</li>
<li>
<p>初始化分配到的空间</p>
<ul>
<li>
<p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p>
</li>
<li>
<p>给对象属性赋值的顺序：</p>
<ul>
<li>属性的默认值初始化</li>
<li>显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li>
<li>构造器初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>设置对象的对象头</p>
<p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p>
</li>
<li>
<p>执行init方法进行初始化</p>
<ul>
<li>
<p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p>
</li>
<li>
<p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-对象的内存布局"><a class="markdownIt-Anchor" href="#2-对象的内存布局"></a> 2、对象的内存布局</h2>
<p><img src="https://img.picgo.net/2025/01/20/-2403019d666a1114f82943.png" alt="对象内存布局-240301" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.picgo.net/2025/01/20/-2403018f1173d87a7c56cd.png" alt="图示对象的内存布局-240301" /></p>
<h2 id="3-对象的访问定位"><a class="markdownIt-Anchor" href="#3-对象的访问定位"></a> 3、对象的访问定位</h2>
<p><img src="https://img.picgo.net/2025/01/20/-240301d2704155bd449f06.png" alt="对象的访问定位-240301" /></p>
<p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p>定位，通过栈上reference访问</p>
<p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p>
<ol>
<li>
<p>句柄访问</p>
<p><img src="https://img.picgo.net/2025/01/20/-24030163501f61b4addc0c.png" alt="对象的句柄访问-240301" /></p>
<ul>
<li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。</li>
<li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低。</li>
</ul>
</li>
<li>
<p>直接指针</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301373543359a9945f1.png" alt="对象的直接指针-240301" /></p>
<ul>
<li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据。</li>
<li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值。</li>
</ul>
</li>
</ol>
<h1 id="十-直接内存"><a class="markdownIt-Anchor" href="#十-直接内存"></a> 十、直接内存</h1>
<h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1、概述</h2>
<ul>
<li>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</li>
<li>直接内存是在Java堆外的、直接向系统申请的内存区间。</li>
<li>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。</li>
<li>通常，访问直接内存的速度会优于Java堆。即读写性能高。
<ul>
<li>因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。</li>
</ul>
</li>
</ul>
<p>代码测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BufferTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 直接分配本地内存空间</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存申请完毕！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;直接内存开始释放&quot;</span>);</span><br><span class="line">    byteBuffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过jps和任务管理器观察到对应Java进程内存发生的变化。</p>
<h2 id="2-数据缓冲区"><a class="markdownIt-Anchor" href="#2-数据缓冲区"></a> 2、数据缓冲区</h2>
<p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如下图的操作。这里需要两份内存存储重复数据，效率低。</p>
<p><img src="https://img.picgo.net/2025/01/20/-2403015e6247d506b2fe8e.png" alt="非直接缓冲区-240301" /></p>
<p>使用NIO时，如下图，操作系统划出的直接缓冲区可以被Java代码直接访问，只有一份。NIO适合对大文件的读写操作。</p>
<p><img src="https://img.picgo.net/2025/01/20/-240301052ee57f9be95572.png" alt="直接缓冲区-240301" /></p>
<h2 id="3-其他"><a class="markdownIt-Anchor" href="#3-其他"></a> 3、其他</h2>
<ul>
<li>也可能导致<code>OutOfMemoryError</code>异常（<code>java.lang.OutOfMemoryError: Direct buffer memory</code>）。</li>
<li>由于直接内存在Java堆外，因此它的大小不会直接受限于<code>-Xmx</code>指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>缺点：
<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。</li>
<li>如果不指定，默认与堆的最大值<code>-Xmx</code>参数值一致。</li>
</ul>
<h1 id="十一-执行引擎"><a class="markdownIt-Anchor" href="#十一-执行引擎"></a> 十一、执行引擎</h1>
<h2 id="1-执行引擎概述"><a class="markdownIt-Anchor" href="#1-执行引擎概述"></a> 1、执行引擎概述</h2>
<ol>
<li>执行引擎是Java虚拟机核心的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<font color='red'>虚拟机的执行引擎则是由软件自行实现的</font>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<font color='red'>能够执行那些不被硬件直接支持的指令集格式</font>。</li>
<li>JVM的主要任务是负责<font color='red'>装载字节码到其内部</font>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<font color='red'>将字节码指令解释/编译为对应平台上的本地机器指令才可以</font>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-1-2403013b064f6c436f0072.png" alt="执行引擎-1-240301" /></p>
<ul>
<li>
<p>前端编译：从Java文件-字节码文件的这个过程叫前端编译。</p>
</li>
<li>
<p>执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p>
</li>
</ul>
<h2 id="2-执行引擎工作过程"><a class="markdownIt-Anchor" href="#2-执行引擎工作过程"></a> 2、执行引擎工作过程</h2>
<ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
<li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/--2403018ab9eb91fcdb4237.png" alt="执行引擎-执行引擎工作过程-240301" /></p>
<h2 id="3-java代码编译和执行的过程"><a class="markdownIt-Anchor" href="#3-java代码编译和执行的过程"></a> 3、Java代码编译和执行的过程</h2>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p>
<p><img src="https://img.picgo.net/2025/01/20/--2403010fc6fd3a1be18e90.png" alt="执行引擎-编译和执行过程-240301" /></p>
<ul>
<li>前面橙色部分是生成字节码文件的过程，和JVM无关</li>
<li>后面蓝色和绿色才是JVM需要考虑的过程</li>
</ul>
<p>Java代码编译是由Java源码编译器来完成，流程图如下所示：</p>
<p><img src="https://img.picgo.net/2025/01/20/-Java-2403011a5ebcf8d4544d06.png" alt="执行引擎-Java源码编译器执行流程-240301" /></p>
<p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p>
<p><img src="https://img.picgo.net/2025/01/20/-Java-2403016bf66852ca819c92.png" alt="执行引擎-Java字节码执行流程-240301" /></p>
<p><strong>什么是解释器？</strong></p>
<p>解释器（Interpreter）：当Java虚拟机启动时会根据预定义的规范<font color='cornflowerblue'>对字节码采用逐行解释的方式执行</font>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p><strong>什么是JIT编译器？</strong></p>
<p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<p><strong>为什么Java是半编译半解释型语言？</strong></p>
<ul>
<li>
<p>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</p>
</li>
<li>
<p>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
</li>
</ul>
<p>结合下图可以更好理解解释器与编译器：</p>
<p><img src="https://img.picgo.net/2025/01/20/-2-2403010beefd56c75d6f7c.png" alt="执行引擎-2-240301" /></p>
<h2 id="4-机器码-指令-汇编语言"><a class="markdownIt-Anchor" href="#4-机器码-指令-汇编语言"></a> 4、机器码、指令、汇编语言</h2>
<h3 id="41-机器码"><a class="markdownIt-Anchor" href="#41-机器码"></a> 4.1 机器码</h3>
<ul>
<li>各种用二进制编码方式表示的指令，叫做<font color='cornflowerblue'>机器指令码</font>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h3 id="42-指令"><a class="markdownIt-Anchor" href="#42-指令"></a> 4.2 指令</h3>
<ul>
<li>由于机器码是有0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好。</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>
</ul>
<p><strong>指令集</strong></p>
<p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。<br />
如常见的：</p>
<ul>
<li>x86指令集，对应的是x86架构的平台。</li>
<li>ARM指令集，对应的是ARM架构的平台。</li>
</ul>
<h3 id="43-语言"><a class="markdownIt-Anchor" href="#43-语言"></a> 4.3 语言</h3>
<p><strong>汇编语言</strong></p>
<ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<font color='cornflowerblue'>助记符</font>（Mnemonics）<font color='cornflowerblue'>代替机器指令的操作码</font>，用地址符号（Symbol）或标号（Label）代替<font color='cornflowerblue'>指令或操作数的地址</font>。</li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。
<ul>
<li>由于计算机只认识指令码，所以用<font color='cornflowerblue'>汇编语言编写的程序还必须翻译成机器指令码</font>，计算机才能识别和执行。</li>
</ul>
</li>
</ul>
<p><strong>高级语言</strong></p>
<ul>
<li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<font color='cornflowerblue'>更接近人的语言</font>。</li>
<li>当计算机执行高级语言编写的程序时，<font color='cornflowerblue'>仍然需要把程序解释和编译成机器的指令码</font>。完成这个过程的程序就叫做解释程序或编译程序。</li>
<li>高级语言不是直接翻译成机器指令，而是编译成汇编语言，再汇编成机器指令。编译过程又可以分成两个阶段：编译和汇编。
<ul>
<li>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码。</li>
<li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</li>
</ul>
</li>
</ul>
<h3 id="44-字节码"><a class="markdownIt-Anchor" href="#44-字节码"></a> 4.4 字节码</h3>
<ul>
<li>字节码是一种<font color='cornflowerblue'>中间状态（中间码）的二进制代码（文件）</font>，它比机器码更抽象，需要直译器转译后才能成为机器码。</li>
<li>字节码主要为了实现特定软件运行和软件环境、<font color='cornflowerblue'>与硬件环境无关</font>。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。
<ul>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
</li>
</ul>
<h2 id="5-解释器"><a class="markdownIt-Anchor" href="#5-解释器"></a> 5、解释器</h2>
<p>JVM设计者们的初衷仅仅只是单纯地<font color='red'>为了满足Java程序实现跨平台特性</font>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<blockquote>
<p>为什么Java源文件不直接翻译成JVM，而是翻译成字节码文件？</p>
<ol>
<li>class 文件内容设计的更加紧凑，方便 JVM 执行，也方便网络传输（最初 JAVA 的一个重要应用就是 applet，在当年网络不是很放大的年代，程序的体积还是要挺重要的）。</li>
<li>方便其它语言执行。现在 JVM 上就有除了 Java 外大量的第三方语言，比如 scala，Clojure 等等。其它语言只要编译成 class 文件即可像 Java 一样在 JVM 上执行。</li>
</ol>
</blockquote>
<p><strong>解释器的工作机制（工作任务）</strong></p>
<ul>
<li>
<p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
</li>
<li>
<p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
</li>
</ul>
<p><strong>解释器的分类</strong></p>
<p>在Java的发展历史里，一共有两套解释执行器，即古老的<font color='red'>字节码解释器</font>、现在普遍使用的<font color='red'>模板解释器</font>。</p>
<ul>
<li>
<p>字节码解释器在执行时通过<font color='cornflowerblue'>纯软件代码</font>模拟字节码的执行，效率非常低下。</p>
</li>
<li>
<p>而模板解释器将<font color='cornflowerblue'>每一条字节码和一个模板函数相关联</font>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</p>
<ul>
<li>
<p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p>
<ul>
<li>
<p>Interpreter模块：实现了解释器的核心功能</p>
</li>
<li>
<p>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>现状</strong></p>
<ul>
<li>
<p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby等。但是在今天，<font color='red'>基于解释器执行已经沦落为低效的代名词</font>，并且时常被一些C/C++程序员所调侃。</p>
</li>
<li>
<p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<font color='red'>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码</font>即可，这种方式可以使执行效率大幅度提升。</p>
</li>
<li>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
</li>
</ul>
<h2 id="6-编译器"><a class="markdownIt-Anchor" href="#6-编译器"></a> 6、编译器</h2>
<h3 id="61-java代码的执行分类"><a class="markdownIt-Anchor" href="#61-java代码的执行分类"></a> 6.1 Java代码的执行分类</h3>
<ul>
<li>
<p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行。</p>
</li>
<li>
<p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行。</p>
</li>
<li>
<p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。它<font color='cornflowerblue'>采用解释器与即时编译器并存的架构</font>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
</li>
<li>
<p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。</p>
</li>
</ul>
<p><strong>问题来了</strong></p>
<p>有些开发人员会感觉到诧异，<font color='cornflowerblue'>既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</font>比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确：<br />
当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br />
编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以：<br />
尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<font color='red'>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</font></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="62-hotspot-jvm执行方式"><a class="markdownIt-Anchor" href="#62-hotspot-jvm执行方式"></a> 6.2 HotSpot JVM执行方式</h3>
<p>当虚拟机启动的时候，<font color='cornflowerblue'>解释器可以首先发挥作用</font>，而不必等待即时编译器全部编译完成再执行，这样可以<font color='cornflowerblue'>省去许多不必要的编译时间</font>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据<font color='cornflowerblue'>热点探测</font>功能，将<font color='cornflowerblue'>有价值的字节码编译为本地机器指令</font>，以换取更高的程序执行效率。</p>
<p><strong>案例</strong></p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<font color='cornflowerblue'>机器在热机状态可以承受的负载要大于冷机状态</font>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<blockquote>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。——阿里团队</p>
</blockquote>
<h3 id="63-概念解释"><a class="markdownIt-Anchor" href="#63-概念解释"></a> 6.3 概念解释</h3>
<ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<font color='cornflowerblue'>前端编译器</font>（其实叫“编译器的前端”更准确一些）把<code>.java</code>文件转变成<code>.class</code>文件的过程。</li>
<li>也可能是指虚拟机的<font color='cornflowerblue'>后端运行期编译器</font>（JIT编译器，Just In Time Compiler），把字节码转变成机器码的过程。</li>
<li>还可能是指使用<font color='cornflowerblue'>静态提前编译器</font>（AOT编译器，Ahead of Time Compiler）直接把<code>.java</code>文件编译成本地机器代码的过程。</li>
</ul>
<blockquote>
<p>前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）。</p>
<p>JIT编译器：HotSpot VM的C1、C2编译器。</p>
<p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
</blockquote>
<h3 id="64-热点代码及探测方式"><a class="markdownIt-Anchor" href="#64-热点代码及探测方式"></a> 6.4 热点代码及探测方式</h3>
<p>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<font color='red'>执行的频率</font>而定。关于那些需要被编译为本地代码的字节码，也被称之为<font color='red'>“热点代码”</font>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<font color='red'>深度优化</font>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</p>
<ul>
<li>
<p><font color='cornflowerblue'>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</font>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<font color='red'>OSR（On Stack Replacement）编译</font>。</p>
</li>
<li>
<p>一个方法究竟<font color='cornflowerblue'>要被调用多少次</font>，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<font color='red'>热点探测功能</font>。</p>
</li>
<li>
<p><font color='red'>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。</font></p>
</li>
<li>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<p><strong>方法调用计数器</strong></p>
<ul>
<li>
<p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p>
</li>
<li>
<p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 来人为设定。</p>
</li>
<li>
<p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断<font color='cornflowerblue'>方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值</font>。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301f67b1854906ee9a5.png" alt="执行引擎-方法调用计数器-240301" /></p>
<p><strong>热点衰减</strong></p>
<ul>
<li>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<font color='cornflowerblue'>一段时间之内方法被调用的次数</font>。当超过<font color='red'>一定的时间限度</font>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<font color='red'>减少一半</font>，这个过程称为方法调用计数器热度的<font color='red'>衰减</font>（Counter Decay），而这段时间就称为此方法统计的<font color='red'>半衰周期</font>（Counter Half Life Time）。</p>
</li>
<li>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
</li>
<li>
<p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p>
</li>
</ul>
<p><strong>回边计数器</strong></p>
<p>它的作用是统计一个方法中<font color='cornflowerblue'>循环体代码执行的次数</font>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p>
<p><img src="https://img.picgo.net/2025/01/20/--240301638e9dd044ec299f.png" alt="执行引擎-回边计数器-240301" /></p>
<p><strong>HotSpotVM可以设置程序执行方法</strong></p>
<p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是<font color='cornflowerblue'>完全采用解释器</font>执行，还是<font color='cornflowerblue'>完全采用即时编译器</font>执行。如下所示：</p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行程序。</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 5335ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 684ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 696ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">IntCompTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 计算100以内的质数</span></span><br><span class="line">        label:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= <span class="number">100</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>; k &lt;= Math.sqrt(j); k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j % k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> label;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="65-jit分类"><a class="markdownIt-Anchor" href="#65-jit分类"></a> 6.5 JIT分类</h3>
<p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><code>-client</code>：指定Java虚拟机运行在Client模式下，并使用C1编译器；
<ul>
<li>C1编译器会对字节码进行<font color='red'>简单和可靠的优化，耗时短</font>。以达到更快的编译速度。</li>
</ul>
</li>
<li><code>-server</code>：指定Java虚拟机运行在server模式下，并使用C2编译器。
<ul>
<li>C2进行<font color='red'>耗时较长的优化，以及激进优化</font>。但优化的代码执行效率更高（使用C++）。</li>
</ul>
</li>
</ul>
<p><strong>C1 和 C2编译器不同的优化策略</strong></p>
<p>在不同的编译器上有不同的优化策略：</p>
<ul>
<li>
<p>C1编译器上主要有方法内联，去虚拟化、元余消除。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程。</li>
<li>去虚拟化：对唯一的实现类进行内联。</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉。</li>
</ul>
</li>
<li>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<ul>
<li>标量替换：用标量值代替聚合对象的属性值。</li>
<li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆。</li>
<li>同步消除：清除同步操作，通常指synchronized。</li>
</ul>
</li>
</ul>
<p><strong>分层编译策略</strong></p>
<p><font color='red'>分层编译（Tiered Compilation）策略</font>：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p>
<p>不过在JDK7版本之后，一旦开发人员在程序中显式指定命令“-server&quot;时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p>
<p><strong>总结</strong></p>
<ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器高。</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器。</li>
</ul>
<h3 id="66-aot编译器"><a class="markdownIt-Anchor" href="#66-aot编译器"></a> 6.6 AOT编译器</h3>
<p>JDK9引入了AOT编译器（静态提前编译器，Ahead of Time Compiler）。Java 9还引入了实验性AOT编译工具aotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<font color='cornflowerblue'>在程序运行之前，便将字节码转换为机器码</font>的过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</span><br></pre></td></tr></table></figure>
<p>最大的好处：Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验。</p>
<p>缺点：</p>
<ul>
<li>破坏了Java“一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包。</li>
<li><font color='cornflowerblue'>降低了Java链接过程的动态性</font>，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux x64 Java base。</li>
</ul>
<p><strong>写到最后</strong></p>
<ul>
<li>自JDK10起，HotSpot又加入了一个全新的及时编译器：Graal编译器。</li>
<li>编译效果短短几年时间就追评了C2编译器，未来可期。</li>
<li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用。</li>
</ul>
<h1 id="十二-stringtable"><a class="markdownIt-Anchor" href="#十二-stringtable"></a> 十二、StringTable</h1>
<h2 id="1-string的基本特性"><a class="markdownIt-Anchor" href="#1-string的基本特性"></a> 1、String的基本特性</h2>
<ol>
<li>String：字符串，使用一对 “” 引起来表示</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> ;   			  <span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure>
<ol>
<li>String被声明为final的，不可被继承。</li>
<li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小。</li>
<li>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code>。</li>
</ol>
<p><strong>为什么 JDK9 改变了 String 的结构</strong></p>
<p><span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8yNTQ=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li>
<li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（<code>Latin-1</code>）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li>
<li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组外加一个编码标识存储。该编码表示如果字符集编码是<code>ISO-8859-1</code>或者<code>Latin-1</code>，那么只需要一个字节存。如果是其它编码，比如UTF-8，仍然需要用两个字节存。</li>
<li>结论：String再也不用<code>char[]</code>来存储了，改成了<code>byte []</code>加上编码标记，节约了一些空间。</li>
<li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改。</li>
</ol>
<p><strong>String 的基本特性</strong></p>
<ul>
<li>
<p>String：代表不可变的字符序列。简称：不可变性。</p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ul>
</li>
<li>
<p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
<li>
<p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);	<span class="comment">// good</span></span><br><span class="line">        System.out.println(ex.ch);	<span class="comment">// best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容。</p>
<h2 id="2-string的底层结构"><a class="markdownIt-Anchor" href="#2-string的底层结构"></a> 2、String的底层结构</h2>
<p><font color='red'>字符串常量池是不会存储相同内容的字符串的。</font></p>
<ol>
<li>
<p>String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String的<code>intern()</code>方法时性能会大幅下降。</p>
</li>
<li>
<p>使用<code>-XX:StringTablesize</code>可设置StringTable的长度。</p>
<ul>
<li>
<p>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，<code>StringTablesize</code>设置没有要求。</p>
</li>
<li>
<p>在JDK7中，StringTable的长度默认值是60013，<code>StringTablesize</code>设置没有要求。</p>
</li>
<li>
<p>在JDK8中，StringTable的长度默认值是60013，<code>StringTablesize</code>可以设置的最小值为1009。</p>
</li>
</ul>
</li>
</ol>
<p>2、String的内存分配</p>
<ul>
<li>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</li>
<li>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种：
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;hello Gerrit&quot;;</code></li>
<li>如果不是用双引号声明的String对象，可以使用String提供的<code>intern()</code>方法。这个后面重点谈。</li>
</ul>
</li>
<li>JDK6及以前，字符串常量池存放在永久代。</li>
<li>JDK7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内。
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以在进行调优应用时仅需调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在JDK7中使用<code>String.intern()</code>。</li>
</ul>
</li>
<li>JDK8元空间，字符串常量在堆。</li>
</ul>
<p><strong>StringTable 为什么要调整？</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvamRrNy1yZWxub3Rlcy5odG1sI2pkazdjaGFuZ2Vz">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>为什么要调整位置？
<ul>
<li><font color='red'>永久代的默认空间大小比较小；</font></li>
<li><font color='red'>永久代垃圾回收频率低</font>，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM；</li>
<li><font color='red'>堆中空间足够大，字符串可被及时回收。</font></li>
</ul>
</li>
<li>在JDK7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li>
<li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li>
</ol>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m -Xms10m -Xmx10m</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -Xms10m -Xmx10m -XX:-UseGCOverheadLimit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        set.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<ul>
<li>
<p>JDK6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-string的基本操作"><a class="markdownIt-Anchor" href="#3-string的基本操作"></a> 3、String的基本操作</h2>
<p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串常量池中的String对象个数</span></span><br><span class="line">        System.out.println();		<span class="comment">// 2293</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);	<span class="comment">// 2294</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);	<span class="comment">// 2303</span></span><br><span class="line">        <span class="comment">// 如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);	<span class="comment">// 2304</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>官方实例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">        mem.foo(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析运行时内存</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-1-240301c3378f8f41e1978b.png" alt="StringTable-1-240301" /></p>
<h2 id="4-string拼接操作"><a class="markdownIt-Anchor" href="#4-string拼接操作"></a> 4、String拼接操作</h2>
<p><strong>先说结论</strong></p>
<ol>
<li>常量与常量的拼接结果在常量池，原理是编译期优化。</li>
<li>常量池中不会存在相同内容的变量。</li>
<li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。</li>
<li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：
<ul>
<li>如果存在，则返回字符串在常量池中的地址</li>
<li>如果不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li>
</ul>
</li>
</ol>
<p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong>。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;	<span class="comment">// 编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;	<span class="comment">// &quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">     * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     * String s2 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(s1 == s2);		<span class="comment">// true</span></span><br><span class="line">    System.out.println(s1.equals(s2));	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 ldc #2 &lt;abc&gt;</span><br><span class="line">2 astore_1</span><br><span class="line">3 ldc #2 &lt;abc&gt;</span><br><span class="line">5 astore_2</span><br><span class="line">6 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line">9 aload_1</span><br><span class="line">10 aload_2</span><br><span class="line">11 if_acmpne 18 (+7)</span><br><span class="line">14 iconst_1</span><br><span class="line">15 goto 19 (+4)</span><br><span class="line">18 iconst_0</span><br><span class="line">19 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">22 getstatic #3 &lt;java/lang/System.out&gt;</span><br><span class="line">25 aload_1</span><br><span class="line">26 aload_2</span><br><span class="line">27 invokevirtual #5 &lt;java/lang/String.equals&gt;</span><br><span class="line">30 invokevirtual #4 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">33 return</span><br></pre></td></tr></table></figure>
<p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中。调用<code>intern()</code>方法，则主动将字符串对象存入字符串常量池中，并将其地址返回。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;	<span class="comment">// 编译期优化</span></span><br><span class="line">    <span class="comment">// 如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7);	<span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7);	<span class="comment">// false</span></span><br><span class="line">    <span class="comment">// intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">// 如果不存在，则在常量池中加载一份javaEEhadoop，并返回该对象的地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、字符串拼接的底层细节</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如下的s1 + s2 的执行细节：</span></span><br><span class="line"><span class="comment">    ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    ② s.append(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">    ③ s.append(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">    ④ s.toString();  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">   如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);	<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、拼接操作与 append 操作的效率对比</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    method1(<span class="number">100000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;method1: &quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    start = System.currentTimeMillis();</span><br><span class="line">    method2(<span class="number">100000</span>);</span><br><span class="line">    end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;method1: &quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">method1</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        s += <span class="string">&quot;a&quot;</span>;   <span class="comment">// 每次循环都会创建一个StringBuilder、String对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">method2</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要创建一个StringBuilder对象</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">method1: 8406</span><br><span class="line">method1: 3</span><br></pre></td></tr></table></figure>
<p>结论：通过StringBuilder的<code>append()</code>的方式添加字符串的效率要远高于使用String的字符串拼接方式。</p>
<p>原因：</p>
<ol>
<li>StringBuilder的<code>append()</code>的方式：自始至终中只创建过一个StringBuilder的对象。</li>
<li>使用String的字符串拼接方式：
<ul>
<li>创建过多个StringBuilder和String（调的toString方法）对象，内存占用更大；</li>
<li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li>
</ul>
</li>
</ol>
<p>改进的空间：</p>
<ul>
<li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化，可以避免频繁扩容：<code>StringBuilder s = new StringBuilder(highLevel);	// new char[highLevel]</code></li>
</ul>
<h2 id="5-new-string的说明"><a class="markdownIt-Anchor" href="#5-new-string的说明"></a> 5、new String()的说明</h2>
<p><strong>new String(“ab”)会创建几个对象？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/String&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 ldc #3 &lt;ab&gt;</span><br><span class="line">6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">9 astore_1</span><br><span class="line">10 return</span><br></pre></td></tr></table></figure>
<p><code>new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象。</p>
<p><code>ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）。</p>
<p>所以答案是1或2个。</p>
<p><strong>new String(“a”) + new String(“b”) 会创建几个对象？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，不会在字符串常量池中生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 new #2 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">3 dup</span><br><span class="line">4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">7 new #4 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 return</span><br></pre></td></tr></table></figure>
<p>答案是4个或5个或6个</p>
<h2 id="6-intern"><a class="markdownIt-Anchor" href="#6-intern"></a> 6、intern</h2>
<h3 id="61-intern的说明"><a class="markdownIt-Anchor" href="#61-intern的说明"></a> 6.1 intern()的说明</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public native String intern();</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>intern是一个native方法，调用的是底层C的方法。</p>
</li>
<li>
<p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由<code>equals(object)</code>方法确定的与该字符串内容相等的字符串，则<font color='red'>返回池中的字符串地址</font>。否则，<font color='red'>该字符串对象将被添加到池中，并返回该字符串对象的地址</font>。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">&quot;I love u&quot;</span>).intern();</span><br></pre></td></tr></table></figure>
<p>intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中，并返回池中的字符串地址。</p>
</li>
<li>
<p>也就是说，如果在任意字符串上调用intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>).intern() == <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）。</p>
</li>
</ol>
<p><strong>有点难的面试题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();	<span class="comment">// 调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);	<span class="comment">// jdk6：false   jdk7/8：false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span></span><br><span class="line"><span class="comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span></span><br><span class="line"><span class="comment">           中存的是new String（&quot;11&quot;）在堆中的地址。</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);	<span class="comment">// pos_1</span></span><br><span class="line">        s3.intern();	<span class="comment">// 调用此方法前，字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;   <span class="comment">// s4变量记录的地址是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);   <span class="comment">// jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内存分析</strong></p>
<p>JDK6</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-2-24030182cc8d2063732221.png" alt="StringTable-2-240301" /></p>
<p>JDK7后</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-3-240301be03c9a8ed7bd239.png" alt="StringTable-3-240301" /></p>
<p><strong>拓展</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);	<span class="comment">// != new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">// 在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line">        System.out.println(s3 == s4);	<span class="comment">// false</span></span><br><span class="line">        System.out.println(s5 == s4);	<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">// 在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;。</span></span><br><span class="line"><span class="comment">        2、jdk7/8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向s的地址，将此引用返回。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:true  jdk7/8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:false  jdk7/8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    	<span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:true  jdk7/8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);	<span class="comment">// jdk6:false  jdk7/8:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<p>字符串对象调用intern方法时：</p>
<ul>
<li>jdk1.6中：
<ul>
<li>如果字符串常量池中有，不会放入，返回已有的字符串常量池中该字符串对象的地址。</li>
<li>如果没有，会把此字符串放入字符串常量池，并返回字符串常量池中该字符串对象的地址。</li>
</ul>
</li>
<li>Jdk1.7后：
<ul>
<li>如果字符串常量池中有，不会放入。返回已有的字符串常量池中该字符串对象的地址。</li>
<li>如果没有，会把<font color='red'>对象的引用地址复制一份</font>，放入字符串常量池，并返回<font color='red'>该引用地址</font>。</li>
</ul>
</li>
</ul>
<h3 id="62-intern的效率测试空间角度"><a class="markdownIt-Anchor" href="#62-intern的效率测试空间角度"></a> 6.2 intern()的效率测试（空间角度）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line">    Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">        arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.DAYS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存占用对比</p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-4-240301ec35ae503cddb503.png" alt="StringTable-4-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-5-2403016ef5ab0a9f006641.png" alt="StringTable-5-240301" /></p>
<p><strong>结论</strong></p>
<ul>
<li>
<p>直接new String ：由于每个String对象都在堆分配内存，所以程序需要维护大量存放在堆空间中的String实例，程序内存占用也会变高。</p>
</li>
<li>
<p>使用<code>intern()</code>方法：由于数组中字符串的引用都<font color='red'>指向字符串常量池中的字符串</font>，所以程序需要维护的String对象更少，内存占用也更低。</p>
</li>
<li>
<p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用<code>intern()</code>方法能够节省很大的内存空间。</p>
</li>
<li>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用<code>intern()</code>方法，就会很明显降低内存的大小。</p>
</li>
</ul>
<h2 id="7-stringtable的垃圾回收"><a class="markdownIt-Anchor" href="#7-stringtable的垃圾回收"></a> 7、StringTable的垃圾回收</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<ul>
<li>在PSYoungGen区发生了垃圾回收。</li>
<li>Number of entries 和 Number of literals 明显没有增加100000。</li>
<li>以上两点均说明 StringTable 区发生了垃圾回收。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/StringTable-StringTable-240301eb4c852331a3e830.png" alt="StringTable-StringTable的垃圾回收-240301" /></p>
<h2 id="8-g1中的string去重操作"><a class="markdownIt-Anchor" href="#8-g1中的string去重操作"></a> 8、G1中的String去重操作</h2>
<p><span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvamVwcy8xOTI=">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p>暂时了解一下，后面会详解垃圾回收器</p>
<p><strong>String去重操作的背景</strong></p>
<blockquote>
<p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p>
</blockquote>
<ol>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：
<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<font color='cornflowerblue'>Java堆中存活的数据集合差不多25%是String对象</font>。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。<font color='cornflowerblue'>堆上存在重复的String对象必然是一种内存的浪费。</font>这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
</ol>
<p><strong>String 去重的的实现</strong></p>
<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<font color='cornflowerblue'>对每一个访问的对象都会检查是否是候选的要去重的String对象。</font></li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
<p><strong>命令行选项</strong></p>
<ol>
<li>UseStringDeduplication(bool) ：开启String去重，<font color='red'>默认是不开启的，需要手动开启。</font></li>
<li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息。</li>
<li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象。</li>
</ol>
<h1 id="十二-垃圾回收概述"><a class="markdownIt-Anchor" href="#十二-垃圾回收概述"></a> 十二、垃圾回收概述</h1>
<p><img src="https://img.picgo.net/2025/01/20/-1-240301ac54b076a6ad0594.png" alt="垃圾回收概述-1-240301" /></p>
<ol>
<li>Java 和 C<ins>语言的区别，就在于垃圾收集技术和内存动态分配上，C</ins>语言没有垃圾收集技术，需要程序员手动的收集。</li>
<li>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</li>
<li>关于垃圾收集有三个经典问题：
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li>垃圾收集机制是Java的招牌能力，<font color='cornflowerblue'>极大地提高了开发效率</font>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是<font color='cornflowerblue'>面试的热点</font>。</li>
</ol>
<h2 id="1-大厂面试题"><a class="markdownIt-Anchor" href="#1-大厂面试题"></a> 1、大厂面试题</h2>
<p><strong>蚂蚁金服</strong></p>
<ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点。</li>
</ol>
<p><strong>百度</strong></p>
<ol>
<li>说一下GC算法，分代回收说下。</li>
<li>垃圾收集策略和算法。</li>
</ol>
<p><strong>天猫</strong></p>
<ol>
<li>JVM GC原理，JVM怎么回收内存。</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<p><strong>滴滴</strong></p>
<ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的。</li>
</ol>
<p><strong>京东</strong></p>
<ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1。</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理。</li>
</ol>
<p><strong>阿里</strong></p>
<ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<p><strong>字节跳动</strong></p>
<ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h2 id="2-什么是垃圾"><a class="markdownIt-Anchor" href="#2-什么是垃圾"></a> 2、什么是垃圾</h2>
<ol>
<li>
<p>垃圾是指<font color='red'>在运行程序中没有任何指针指向的对象</font>，这个对象就是需要被回收的垃圾。</p>
<p>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</p>
</li>
<li>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p>
</li>
</ol>
<h2 id="3-为什么需要gc"><a class="markdownIt-Anchor" href="#3-为什么需要gc"></a> 3、为什么需要GC？</h2>
<p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<font color='cornflowerblue'>内存迟早都会被消耗完</font>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li>
<li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<font color='cornflowerblue'>以便JVM将整理出的内存分配给新的对象</font>。</li>
<li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<font color='cornflowerblue'>没有GC就不能保证应用程序的正常进行</font>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
</ol>
<h2 id="4-早期垃圾回收"><a class="markdownIt-Anchor" href="#4-早期垃圾回收"></a> 4、早期垃圾回收</h2>
<ul>
<li>在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line"><span class="comment">// 如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>(pBridge-&gt;<span class="built_in">Register</span>(kDestroy) != NO ERROR)</span><br><span class="line">    <span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<font color='cornflowerblue'>频繁申请和释放内存的管理负担</font>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<font color='cornflowerblue'>内存泄漏</font>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<font color='cornflowerblue'>应用程序崩溃</font>.</p>
</li>
<li>
<p>有了垃圾回收机制后，上述代码极有可能变成这样：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>
<ul>
<li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li>
</ul>
<h2 id="5-java的垃圾回收机制"><a class="markdownIt-Anchor" href="#5-java的垃圾回收机制"></a> 5、Java的垃圾回收机制</h2>
<h3 id="51-自动内存管理"><a class="markdownIt-Anchor" href="#51-自动内存管理"></a> 5.1 自动内存管理</h3>
<blockquote>
<p><strong>官网介绍</strong>：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3ZtL2djdHVuaW5nL3RvYy5odG1s">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><strong>自动内存管理的优点</strong></p>
<ul>
<li>
<p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样能<font color='red'>降低内存泄漏和内存溢出的风险。</font></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
</li>
<li>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，<font color='red'>可以更专心地专注于业务开发。</font></p>
</li>
</ul>
<p><strong>关于自动内存管理的担忧</strong></p>
<ul>
<li>
<p>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<font color='cornflowerblue'>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</font></p>
</li>
<li>
<p>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见<code>OutofMemoryError</code>时，快速地根据错误异常日志定位问题和解决问题。</p>
</li>
<li>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<font color='cornflowerblue'>实施必要的监控和调节。</font></p>
</li>
</ul>
<h3 id="52-应该关心哪些区域的回收"><a class="markdownIt-Anchor" href="#52-应该关心哪些区域的回收"></a> 5.2 应该关心哪些区域的回收？</h3>
<p><img src="https://img.picgo.net/2025/01/20/-GC-240301c032c54b76675b43.png" alt="垃圾回收概述-GC的作用区域-240301" /></p>
<ul>
<li>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。</p>
<ul>
<li>其中，<font color='red'>Java堆是垃圾收集器的工作重点。</font></li>
</ul>
</li>
<li>
<p>从次数上讲：</p>
<ul>
<li><font color='red'>频繁收集Young区</font></li>
<li><font color='red'>较少收集Old区</font></li>
<li><font color='red'>基本不收集Perm区（元空间）</font></li>
</ul>
</li>
</ul>
<h1 id="十三-垃圾回收相关算法"><a class="markdownIt-Anchor" href="#十三-垃圾回收相关算法"></a> 十三、垃圾回收相关算法</h1>
<h2 id="1-标记阶段"><a class="markdownIt-Anchor" href="#1-标记阶段"></a> 1、标记阶段</h2>
<h3 id="11-标记阶段的目的"><a class="markdownIt-Anchor" href="#11-标记阶段的目的"></a> 1.1 标记阶段的目的</h3>
<p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p>
<ul>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<font color='cornflowerblue'>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</font>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<font color='cornflowerblue'>垃圾标记阶段</font>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：<font color='red'>引用计数算法</font>和<font color='red'>可达性分析算法</font>。</li>
</ul>
<h3 id="12-引用计数算法"><a class="markdownIt-Anchor" href="#12-引用计数算法"></a> 1.2 引用计数算法</h3>
<ul>
<li>
<p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<font color='red'>引用计数器属性，用于记录对象被引用的情况。</font></p>
</li>
<li>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
</li>
<li>
<p>优点：<font color='cornflowerblue'>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</font></p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<font color='cornflowerblue'>存储空间的开销</font>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<font color='cornflowerblue'>时间开销</font>。</li>
<li>引用计数器有一个严重的问题，即<font color='red'>无法处理循环引用</font>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--24030128740784a89f4b6e.png" alt="垃圾回收概述-循环引用-240301" /></p>
<p>当p的指针断开的时候，内部的引用形成一个循环，计数器都为1，无法被回收，这就是循环引用，从而造成内存泄漏。</p>
<p><strong>证明：java使用的不是引用计数算法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">// 这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];	<span class="comment">// 5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.picgo.net/2025/01/20/-2-240301e3f30ff5192ca9e6.png" alt="垃圾回收概述-2-240301" /></p>
<p><strong>执行结果</strong></p>
<ul>
<li>
<p>没有进行GC时（注释<code>System.gc()</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 12841K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 19% used [0x000000076b780000,0x000000076c40a578,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line"> ParOldGen       total 173568K, used 0K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2600000,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2629K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进行GC后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;672K(75776K)] 11540K-&gt;680K(249344K), 0.0348225 secs] [Times: user=0.00 sys=0.00, real=0.04 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 672K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;519K(173568K)] 680K-&gt;519K(249344K), [Metaspace: 2623K-&gt;2623K(1056768K)], 0.0038984 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 519K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2681ed8,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>结论</strong></p>
<ol>
<li>从打印日志就可以明显看出来，已经进行了GC。</li>
<li>如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</li>
</ol>
<p><strong>小结</strong></p>
<ol>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用？
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ol>
<h3 id="13-可达性分析算法"><a class="markdownIt-Anchor" href="#13-可达性分析算法"></a> 1.3 可达性分析算法</h3>
<p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p>
<ul>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决<font color='cornflowerblue'>在引用计数算法中循环引用的问题，防止内存泄漏的发生</font>。</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<font color='cornflowerblue'>追踪性垃圾收集</font>（Tracing Garbage Collection）</li>
</ul>
<p><strong>可达性分析实现思路</strong></p>
<ul>
<li>所谓&quot;GC Roots”根集合就是一组必须活跃的引用。</li>
<li>思路如下：
<ul>
<li>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上至下的方式<font color='cornflowerblue'>搜索被根对象集合所连接的目标对象是否可达</font>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<font color='cornflowerblue'>引用链</font>（Reference Chain）。</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301e0d32be041e67917.png" alt="垃圾回收概述-可达性分析算法-240301" /></p>
<p><strong>在Java语言中，GC Roots包括以下几类元素：</strong></p>
<ol>
<li>虚拟机栈中引用的对象。
<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象。</li>
<li>方法区中类静态属性引用的对象。
<ul>
<li>比如：Java类的引用类型静态变量。</li>
</ul>
</li>
<li>方法区中常量引用的对象。
<ul>
<li>比如：字符串常量池（StringTable）里的引用。</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象。</li>
<li>Java虚拟机内部的引用。
<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：<code>NullPointerException</code>、<code>OutofMemoryError</code>），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-3-24030164ed2335f156dc4c.png" alt="垃圾回收概述-3-240301" /></p>
<ul>
<li>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。</p>
<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
<li>
<p>小技巧</p>
<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ol>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<font color='red'>枚举根节点时也是必须要停顿的</font>。</li>
</ol>
<h3 id="14-对象的-finalization-机制"><a class="markdownIt-Anchor" href="#14-对象的-finalization-机制"></a> 1.4 对象的 finalization 机制</h3>
<p><strong>对象销毁前的回调函数：finalize()</strong></p>
<ol>
<li>
<p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<font color='cornflowerblue'>对象被销毁之前的自定义处理逻辑</font>。</p>
</li>
<li>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的<code>finalize()</code>方法。</p>
</li>
<li>
<p><code>finalize()</code>方法允许在子类中被重写，<font color='cornflowerblue'>用于在对象被回收时进行资源释放</font>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
<li>
<p>永远不要主动调用某个对象的<code>finalize()</code>方法，应该交给垃圾回收机制调用。理由包括下面三点：</p>
<ul>
<li>
<p>调用<code>finalize()</code>时可能会导致对象复活。</p>
</li>
<li>
<p><code>finalize()</code>方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则<code>finalize()</code>方法将没有执行机会。</p>
</li>
<li>
<p>一个糟糕的<code>finalize()</code>会严重影响GC的性能。比如finalize是个死循环。</p>
</li>
</ul>
</li>
<li>
<p>从功能上来说，finalize()方法与C<ins>中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以<code>finalize()</code>方法在本质上不同于C</ins>中的析构函数。</p>
</li>
<li>
<p><code>finalize()</code>方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收。</p>
</li>
</ol>
<p><strong>生存还是死亡？</strong></p>
<p>由于finalize()方法的存在，<font color='cornflowerblue'>虚拟机中的对象一般处于三种可能的状态</font>。</p>
<ul>
<li>
<p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<font color='red'>一个无法触及的对象有可能在某一个条件下“复活”自己</font>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><font color='red'>可触及的</font>：从根节点开始，可以到达这个对象。</li>
<li><font color='red'>可复活的</font>：对象的所有引用都被释放，但是对象有可能在<code>finalize()</code>中复活。</li>
<li><font color='red'>不可触及的</font>：对象的<code>finalize()</code>被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<font color='red'>因为<code>finalize()</code>只会被调用一次</font>。</li>
</ul>
</li>
<li>
<p>以上3种状态中，是由于<code>finalize()</code>方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</li>
</ul>
<p><strong>具体过程</strong></p>
<p>判定一个对象<code>objA</code>是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>
<p>如果对象<code>objA</code>到GC Roots没有引用链，则进行第一次标记。</p>
</li>
<li>
<p>进行筛选，判断此对象是否有必要执行<code>finalize()</code>方法：</p>
<ul>
<li>
<p>如果对象objA没有重写<code>finalize()</code>方法，或者<code>finalize()</code>方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，<code>objA</code>被判定为不可触及的。</p>
</li>
<li>
<p>如果对象<code>objA</code>重写了<code>finalize()</code>方法，且还未执行过，那么<code>objA</code>会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其<code>finalize()</code>方法执行。</p>
</li>
<li>
<p><font color='red'><code>finalize()</code>方法是对象逃脱死亡的最后机会</font>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果<code>objA</code>在<code>finalize()</code>方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，<code>objA</code>会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，<code>finalize()</code>方法不会被再次调用，对象会直接变成不可触及的状态。也就是说，一个对象的<code>finalize()</code>方法只会被调用一次。</p>
</li>
</ul>
</li>
</ol>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj; <span class="comment">// 类变量，属于 GC Roots</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;override finalize()&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>; <span class="comment">// 当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();    <span class="comment">// 调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;first gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为 Finalizer 线程优先级很低，暂停 2 秒，等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;second gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first gc</span><br><span class="line">override finalize()</span><br><span class="line">obj is still alive</span><br><span class="line">second gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>
<ul>
<li>如果不重写<code>finalize()</code>方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first gc</span><br><span class="line">obj is dead</span><br><span class="line">second gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>
<h3 id="15-使用mat查看gc-roots"><a class="markdownIt-Anchor" href="#15-使用mat查看gc-roots"></a> 1.5 使用MAT查看GC Roots</h3>
<p><strong>MAT介绍</strong></p>
<ol>
<li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li>
<li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li>
<li>可以在<span class="exturl" data-url="aHR0cDovL3d3dy5lY2xpcHNlLm9yZy9tYXQ=">http://www.eclipse.org/mat<i class="fa fa-external-link-alt"></i></span>下载并使用MAT。</li>
</ol>
<blockquote>
<p>虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些。</p>
<p>此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件。</p>
</blockquote>
<p><strong>获取dump文件方式</strong></p>
<p><strong>方式一：命令行使用 jmap</strong></p>
<p><code>jmap -dump:format=b,live,file=文件名 [pid]</code></p>
<p><img src="https://img.picgo.net/2025/01/20/-jmap-2403013709399f3fae8ec4.png" alt="垃圾回收概述-jmap-240301" /></p>
<p><strong>方式二：使用JVisualVM</strong></p>
<ol>
<li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。</li>
<li>可通过以下方法捕获heap dump：
<ul>
<li>在左侧“Application”(应用程序）子窗口中右击相应的应用程序，选择Heap Dump(堆Dump) 。</li>
<li>在Monitor(监视）子标签页中点击Heap Dump(堆Dump）按钮。</li>
</ul>
</li>
<li>本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application(应用程序）栏中对应一个含有时间戳的节点。右击这个节点选择save as（另存为）即可将heap dump保存到本地。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-4-240301744f286f6255b604.png" alt="垃圾回收概述-4-240301" /></p>
<p><strong>捕捉 dump 示例</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>numList</code>和<code>birth</code>在第一次捕捉内存快照的时候，为 GC Roots。</li>
<li>之后<code>numList</code>和<code>birth</code>置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots。</li>
</ul>
<p><strong>使用MAT查看GC Roots</strong></p>
<ol>
<li>使用MAT打开 dump文件；</li>
<li>查看GCRoots</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-5-2403013919c3aacd5efb86.png" alt="垃圾回收概述-5-240301" /></p>
<p>打开第一个dump文件，即第一次捕捉的内存快照，GC Roots 中包含参数<code>args</code>和定义的两个局部变量，类型分别为<code>ArrayList</code>和<code>Date</code>，Total entries = 21。</p>
<p><img src="https://img.picgo.net/2025/01/20/-6-2403013869e935a9a4f3db.png" alt="垃圾回收概述-6-240301" /></p>
<p>打开第二个dump文件，即第二次捕捉的内存快照，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total entries = 19 也可以看出（少了两个 GC Roots）。</p>
<p><img src="https://img.picgo.net/2025/01/20/-7-240301436c5959dafe79df.png" alt="垃圾回收概述-7-240301" /></p>
<h3 id="16-使用jprofiler进行gc-roots溯源"><a class="markdownIt-Anchor" href="#16-使用jprofiler进行gc-roots溯源"></a> 1.6 使用JProfiler进行GC Roots溯源</h3>
<p>在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<font color='cornflowerblue'>GC Roots溯源。</font></p>
<p><img src="https://img.picgo.net/2025/01/20/-8-2403011badc5e7b90e76a5.png" alt="垃圾回收概述-8-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-9-240301064a35724942d310.png" alt="垃圾回收概述-9-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-10-2403019249f018346ca410.png" alt="垃圾回收概述-10-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-11-240301fb33fb3b9eca609f.png" alt="垃圾回收概述-11-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-12-240301544cc76c448366ab.png" alt="垃圾回收概述-12-240301" /></p>
<h3 id="17-使用jprofiler监控oom"><a class="markdownIt-Anchor" href="#17-使用jprofiler监控oom"></a> 1.7 使用JProfiler监控OOM</h3>
<blockquote>
<p>这里是简单的讲一下，后面篇章会详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];	<span class="comment">// 1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用JProfiler打开生成的dump文件，并查看其中的最大对象。</p>
<p><img src="https://img.picgo.net/2025/01/20/-13-240301bb3131d5bfa9ac90.png" alt="垃圾回收概述-13-240301" /></p>
<p>可以看到，ArrayList 是超大对象，占据了内存 89%的空间。</p>
<p><img src="https://img.picgo.net/2025/01/20/-14-240301e9da4fb49e94651d.png" alt="垃圾回收概述-14-240301" /></p>
<p>选择左边的线程选项，还可以看到是哪个线程出现了问题，然后定位到代码的行数。</p>
<p><img src="https://img.picgo.net/2025/01/20/-15-240301ee2cd69eb4bd6c54.png" alt="垃圾回收概述-15-240301" /></p>
<h2 id="2-清除阶段"><a class="markdownIt-Anchor" href="#2-清除阶段"></a> 2、清除阶段</h2>
<h3 id="21-垃圾清除阶段"><a class="markdownIt-Anchor" href="#21-垃圾清除阶段"></a> 2.1 垃圾清除阶段</h3>
<p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是：</p>
<ul>
<li>
<p>标记-清除算法（Mark-Sweep）</p>
</li>
<li>
<p>复制算法（Copying）</p>
</li>
<li>
<p>标记-压缩算法（Mark-Compact）</p>
</li>
</ul>
<h3 id="22-标记-清除算法"><a class="markdownIt-Anchor" href="#22-标记-清除算法"></a> 2.2 标记-清除算法</h3>
<p><strong>背景</strong></p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p><strong>执行过程</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<ul>
<li>
<p><font color='cornflowerblue'>标记</font>：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。</p>
<ul>
<li>注意：<font color='red'>标记的是被引用的对象，也就是可达对象，并非即将被清除的垃圾对象。</font></li>
</ul>
</li>
<li>
<p><font color='cornflowerblue'>清除</font>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/---24030175e497cbf0609d3f.png" alt="垃圾回收概述-标记-清除算法-240301" /></p>
<p><strong>缺点</strong></p>
<ol>
<li>标记清除算法的效率不算高。</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差。</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片，需要维护一个空闲列表。</li>
</ol>
<p><strong>注意：何为清除？</strong></p>
<ul>
<li>
<p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p>
<blockquote>
<p>关于空闲列表是在为对象分配内存的时候提过：</p>
<p>如果内存规整：采用指针碰撞的方式进行内存分配。</p>
<p>如果内存不规整：虚拟机需要维护一个空闲列表，采用空闲列表分配内存。</p>
</blockquote>
</li>
</ul>
<h3 id="23-复制算法"><a class="markdownIt-Anchor" href="#23-复制算法"></a> 2.3 复制算法</h3>
<p><strong>背景</strong></p>
<p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器（CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</p>
<p><strong>核心思想</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/--240301f5469e2b20023571.png" alt="垃圾回收概述-复制算法-240301" /></p>
<p><strong>优点</strong></p>
<ul>
<li>没有标记和清除过程，实现简单，运行高效。</li>
<li>复制过去以后保证<font color='red'>空间的连续性</font>，不会出现“碎片”问题。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</li>
</ul>
<p><strong>特别的</strong></p>
<ul>
<li>如果系统中的垃圾对象很多，复制算法就不会很理想。复制算法适合<font color='red'>需要复制的存活对象数量不会太多</font>，或者说非常低才行。</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收 70%-90% 的内存空间，回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-16-2403014ac3d186f1564cb8.png" alt="垃圾回收概述-16-240301" /></p>
<h3 id="24-标记-压缩整理算法"><a class="markdownIt-Anchor" href="#24-标记-压缩整理算法"></a> 2.4 标记-压缩（整理）算法</h3>
<p><strong>背景</strong></p>
<p>​	复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<font color='red'>基于老年代垃圾回收的特性，需要使用其他的算法。</font></p>
<p>​	标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark - Compact）算法由此诞生。</p>
<p>​	1970年前后，G. L. steele 、C. J. Chene和D.S. Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<p><strong>执行过程</strong></p>
<ol>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象；</li>
<li>第二阶段将所有的存活对象压缩到内存的一段，按顺序排放；</li>
<li>之后，清理边界外所有的空间。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/---240301908b695495c8baa1.png" alt="垃圾回收概述-标记-压缩算法-240301" /></p>
<p><strong>标记-压缩算法与标记-清除算法的比较</strong></p>
<ol>
<li>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</li>
<li>二者的本质差异在于标记-清除算法是一种<font color='cornflowerblue'>非移动式的回收算法</font>，标记-压缩是<font color='cornflowerblue'>移动式</font>的。是否移动回收后的存活对象是一项优缺点并存的风险决策。</li>
<li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li>
</ol>
<p><strong>优点</strong></p>
<ul>
<li>
<p>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</p>
</li>
<li>
<p>消除了复制算法当中，内存减半的高额代价。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p>从效率上来说，标记-整理算法要低于复制算法。</p>
</li>
<li>
<p>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）。</p>
</li>
<li>
<p>移动过程中，需要全程暂停用户应用程序，即：STW。</p>
</li>
</ul>
<h3 id="25-小结三种算法对比"><a class="markdownIt-Anchor" href="#25-小结三种算法对比"></a> 2.5 小结（三种算法对比）</h3>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h3 id="26-分代收集算法"><a class="markdownIt-Anchor" href="#26-分代收集算法"></a> 2.6 分代收集算法</h3>
<p>​	前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>​	分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，<font color='cornflowerblue'>不同生命周期的对象可以采取不同的收集方式，以便提高回收效率</font>。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>​	在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<font color='cornflowerblue'>Http请求中的session对象、线程、socket连接</font>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如: String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><font color='cornflowerblue'>目前几乎所有的 GC 都是采用分代收集（Generational collecting）算法执行垃圾回收的。</font></p>
<p>在Hotspot中，基于分代的概念，cc所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ul>
<li>
<p>年轻代（Young Gen）</p>
<p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
</li>
<li>
<p>老年代（Tenured Gen）</p>
<p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark阶段的开销与存活对象的数量成正比。</li>
<li>Sweep阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact阶段的开销与存活对象的数据成正比。</li>
</ul>
</li>
</ul>
<p>​	以HotSpot中的 CMS 回收器为例，CMS 是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure时)，将采用 Serial Old执行Full GC 以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h3 id="27-增量收集算法"><a class="markdownIt-Anchor" href="#27-增量收集算法"></a> 2.7 增量收集算法</h3>
<p>​	上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<font color='cornflowerblue'>Stop the World</font>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，<font color='cornflowerblue'>将严重影响用户体验或者系统的稳定性。</font>为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p><strong>基本思想</strong></p>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<font color='cornflowerblue'>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</font></li>
<li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<font color='red'>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</font></li>
</ol>
<p><strong>缺点</strong></p>
<ul>
<li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<font color='cornflowerblue'>造成系统吞吐量的下降</font>。</li>
</ul>
<h3 id="28-分区算法"><a class="markdownIt-Anchor" href="#28-分区算法"></a> 2.8 分区算法</h3>
<p>​	一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>​	分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://img.picgo.net/2025/01/20/--24030103f7f06532fbe875.png" alt="垃圾回收概述-分区算法-240301" /></p>
<h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2>
<p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
<h1 id="十四-垃圾回收相关概念"><a class="markdownIt-Anchor" href="#十四-垃圾回收相关概念"></a> 十四、垃圾回收相关概念</h1>
<h2 id="1-systemgc-的理解"><a class="markdownIt-Anchor" href="#1-systemgc-的理解"></a> 1、System.gc() 的理解</h2>
<ul>
<li>
<p>在默认情况下，通过<code>System.gc()</code>者<code>Runtime.getRuntime().gc()</code>的调用，<font color='cornflowerblue'>会显式触发Full GC</font>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
</li>
<li>
<p>然而<code>System.gc()</code>调用附带一个免责声明，无法保证对垃圾收集器的调用（不能确保立即生效）。</p>
</li>
<li>
<p>JVM实现者可以通过<code>System.gc()</code>调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<font color='cornflowerblue'>无须手动触发，否则就太过于麻烦了</font>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用<code>System.gc()</code>。</p>
</li>
</ul>
<h3 id="11-代码示例手动执行-gc-操作"><a class="markdownIt-Anchor" href="#11-代码示例手动执行-gc-操作"></a> 1.1 代码示例：手动执行 GC 操作</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();    <span class="comment">// 提醒jvm的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生了GC，这个finalize()一定会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest finalize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果不确定：有时候会调用 finalize() 方法，有时候不会调用。</p>
<p>可以使用<code>System.runFinalization()</code>来强制调用失去引用对象的<code>finalize()</code>方法。</p>
<h3 id="12-手动-gc-理解不可达对象的回收行为"><a class="markdownIt-Anchor" href="#12-手动-gc-理解不可达对象的回收行为"></a> 1.2 手动 GC 理解不可达对象的回收行为</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localVarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        <span class="comment">// 通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        local.localVarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：-XX:+PrintGCDetails</li>
</ul>
<p><strong>调用<code>localVarGC1()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10736K(75776K)] 11540K-&gt;10904K(249344K), 0.0059694 secs] [Times: user=0.03 sys=0.02, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(75776K)] [ParOldGen: 168K-&gt;10760K(173568K)] 10904K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0041345 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 10760K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 6% used [0x00000006c2600000,0x00000006c3082250,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>执行<code>System.gc()</code>仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象并不会被回收。</p>
<p><strong>调用<code>localVarGC2()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;768K(75776K)] 11540K-&gt;776K(249344K), 0.0007120 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 768K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;520K(173568K)] 776K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0044018 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>由于 buffer 数组对象没有引用指向它，执行<code>System.gc()</code>将被回收。</p>
<p><strong>调用<code>localVarGC3()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10720K(75776K)] 11540K-&gt;10888K(249344K), 0.0056072 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10720K-&gt;0K(75776K)] [ParOldGen: 168K-&gt;10760K(173568K)] 10888K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0040429 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 10760K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 6% used [0x00000006c2600000,0x00000006c3082250,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收。</p>
<p>查看字节码：</p>
<p><img src="https://img.picgo.net/2025/01/20/-17-24030101d31e50e6761db7.png" alt="垃圾回收概述-17-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-18-2403016890fef7da6de304.png" alt="垃圾回收概述-18-240301" /></p>
<p>可以看到局部变量表的大小是 2，但是局部变量表里只有一个索引为0变量，那索引为1去哪了呢？实际上索引为1的位置是 buffer 的引用在占用着，所以没有进行GC。</p>
<p><strong>调用<code>localVarGC4()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;736K(75776K)] 11540K-&gt;744K(249344K), 0.0008649 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 736K-&gt;0K(75776K)] [ParOldGen: 8K-&gt;520K(173568K)] 744K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0038737 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line">  to   space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2630K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>这时 buffer 数组对象就被回收了。为什么多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p>
<p>因为局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行<code>System.gc()</code>时就会被回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/-19-24030182599a2921b13d29.png" alt="垃圾回收概述-19-240301" /></p>
<p><strong>调用<code>localVarGC5()</code>方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 11540K-&gt;10736K(75776K)] 11540K-&gt;10920K(249344K), 0.0054120 secs] [Times: user=0.11 sys=0.02, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 10736K-&gt;0K(75776K)] [ParOldGen: 184K-&gt;10760K(173568K)] 10920K-&gt;10760K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0060036 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(75776K)] 10760K-&gt;10760K(249344K), 0.0003260 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(75776K)] [ParOldGen: 10760K-&gt;520K(173568K)] 10760K-&gt;520K(249344K), [Metaspace: 2624K-&gt;2624K(1056768K)], 0.0040308 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 75776K, used 1300K [0x000000076b780000, 0x0000000770c00000, 0x00000007c0000000)</span><br><span class="line">  eden space 65024K, 2% used [0x000000076b780000,0x000000076b8c5360,0x000000076f700000)</span><br><span class="line">  from space 10752K, 0% used [0x0000000770180000,0x0000000770180000,0x0000000770c00000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f700000,0x000000076f700000,0x0000000770180000)</span><br><span class="line"> ParOldGen       total 173568K, used 520K [0x00000006c2600000, 0x00000006ccf80000, 0x000000076b780000)</span><br><span class="line">  object space 173568K, 0% used [0x00000006c2600000,0x00000006c2682240,0x00000006ccf80000)</span><br><span class="line"> Metaspace       used 2631K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>局部变量出了方法范围就失效了，堆中的 buffer 数组对象一定会被回收。</p>
<h2 id="2-内存溢出与内存泄漏"><a class="markdownIt-Anchor" href="#2-内存溢出与内存泄漏"></a> 2、内存溢出与内存泄漏</h2>
<h3 id="21-内存溢出oom"><a class="markdownIt-Anchor" href="#21-内存溢出oom"></a> 2.1 内存溢出（OOM）</h3>
<ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
<li>由于GC一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li>
<li>Javadoc中对<code>OutOfMemoryError</code>的解释是，<font color='cornflowerblue'>没有空闲内存，并且垃圾收集器也无法提供更多内存。</font></li>
<li>这里面隐含着一层意思是，在抛出<code>OutOfMemoryError</code>之前，通常垃圾收集器会被触发，尽其所能去清理出空间。
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试<font color='red'>回收软引用指向的对象</font>等。</li>
<li>在<code>java.nio.Bits.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li>
</ul>
</li>
<li>当然，也不是在任何情况下垃圾收集器都会被触发的。
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出<code>OutOfMemoryError</code>。</li>
</ul>
</li>
</ul>
<p><strong>内存溢出原因分析</strong></p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够。
<ul>
<li>可能存在内存泄漏问题，很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code>、<code>-Xmx</code>来调整。</li>
</ul>
</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）
<ul>
<li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现<code>OutOfMemoryError</code>也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：<code>java.lang.OutOfMemoryError:PermGen space</code>。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：<code>java.lang.OutofMemoryError:Metaspace</code>。直接内存不足，也会导致OOM。</li>
</ul>
</li>
</ol>
<h3 id="22-内存泄漏memory-leak"><a class="markdownIt-Anchor" href="#22-内存泄漏memory-leak"></a> 2.2 内存泄漏（Memory Leak）</h3>
<ul>
<li>
<p>也称作“存储渗漏”。严格来说，<font color='red'>只有对象不会再被程序用到了，但是GC又不能回收它们的情况，才叫内存泄漏。</font></p>
</li>
<li>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<font color='cornflowerblue'>宽泛意义上的“内存泄漏”</font>。</p>
</li>
<li>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现<code>OutOfMemory</code>异常，导致程序崩溃。</p>
</li>
<li>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
</li>
</ul>
<p><strong>内存泄露例子</strong></p>
<p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p>
<p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p>
<p><img src="https://img.picgo.net/2025/01/20/--2403012fb2e63f510090e7.png" alt="垃圾回收概述-内存泄漏-240301" /></p>
<p><strong>常见例子</strong></p>
<ol>
<li>单例模式
<ul>
<li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果<font color='red'>持有对外部对象的引用的话</font>，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li>
</ul>
</li>
<li>一些提供<code>close()</code>的资源未关闭导致内存泄漏
<ul>
<li>数据库连接<code>dataSourse.getConnection()</code>，网络连接socket和io连接必须手动close，否则是不能被回收的。</li>
</ul>
</li>
</ol>
<h2 id="3-stop-the-world"><a class="markdownIt-Anchor" href="#3-stop-the-world"></a> 3、Stop the World</h2>
<ul>
<li>
<p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<font color='cornflowerblue'>停顿产生时整个应用程序线程都会被暂停，没有任何响应</font>，有点像卡死的感觉，这个停顿称为STW。</p>
<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所Java执行线程呢？
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><font color='cornflowerblue'>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</font></li>
</ul>
</li>
</ul>
</li>
<li>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</li>
<li>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
</li>
<li>
<p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
</li>
<li>
<p>STW是JVM在<font color='cornflowerblue'>后台自动发起和自动完成</font>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
</li>
<li>
<p>开发中不要用<code>System.gc()</code> ，这会导致Stop-the-World的发生。</p>
</li>
</ul>
<p><strong>代码感受 Stop the World</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (list.size() &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();    <span class="comment">// 会触发full gc，进而会出现STW事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    startTime = System.currentTimeMillis();</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭线程 w ，观察输出：基本是每隔1秒打印一次：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>开启线程 w ，观察输出：时间间隔明显大于1秒 ，可以明显感受到 Stop the World 的存在：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0</span><br><span class="line">1.1</span><br><span class="line">1.1</span><br><span class="line">1.2</span><br><span class="line">1.1</span><br><span class="line">1.4</span><br><span class="line">1.2</span><br></pre></td></tr></table></figure>
<h2 id="4-垃圾回收的并行与并发"><a class="markdownIt-Anchor" href="#4-垃圾回收的并行与并发"></a> 4、 垃圾回收的并行与并发</h2>
<h3 id="41-并发的概念"><a class="markdownIt-Anchor" href="#41-并发的概念"></a> 4.1 并发的概念</h3>
<ul>
<li>
<p>在操作系统中，是指<font color='cornflowerblue'>一个时间段</font>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
</li>
<li>
<p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--24030180b40edfe5511b5b.png" alt="垃圾回收概述-并发-240301" /></p>
<h3 id="42-并行的概念"><a class="markdownIt-Anchor" href="#42-并行的概念"></a> 4.2 并行的概念</h3>
<ul>
<li>
<p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<font color='cornflowerblue'>同时</font>进行，我们称之为并行（Parallel）。</p>
</li>
<li>
<p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
</li>
<li>
<p>适合科学计算，后台处理等弱交互场景。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--240301bfb6932cd7d29fbc.png" alt="垃圾回收概述-并行-240301" /></p>
<p><strong>并发与并行的对比</strong></p>
<ol>
<li>并发，指的是多个事情，<font color='red'>在同一时间段内同时发生了。</font></li>
<li>并行，指的是多个事情，<font color='red'>在同一时间点上（或者说同一时刻）同时发生了。</font></li>
<li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li>
</ol>
<h3 id="43-垃圾回收的并发与并行"><a class="markdownIt-Anchor" href="#43-垃圾回收的并发与并行"></a> 4.3 垃圾回收的并发与并行</h3>
<p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ol>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
<ul>
<li>如ParNew、Parallel Scavenge、Parallel Old。</li>
</ul>
</li>
<li>串行（Serial）
<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）。</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-20-2403011f422600aef81d1a.png" alt="垃圾回收概述-20-240301" /></p>
<ol start="3">
<li>并发（Concurrent）：指<font color='cornflowerblue'>用户线程与垃圾收集线程同时执行</font>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。
<ul>
<li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上。</li>
<li>如CMS、G1。</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png" alt="垃圾回收概述-21-240301" /></p>
<h2 id="5-安全点与安全区域"><a class="markdownIt-Anchor" href="#5-安全点与安全区域"></a> 5、安全点与安全区域</h2>
<h3 id="51-安全点safe-point"><a class="markdownIt-Anchor" href="#51-安全点safe-point"></a> 5.1 安全点（Safe Point）</h3>
<ul>
<li>
<p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safe Point）”。</p>
</li>
<li>
<p>Safe Point的选择很重要，<font color='cornflowerblue'>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</font>。大部分指令的执行时间都非常短暂，通常会根据“<font color='red'>是否具有让程序长时间执行的特征</font>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<font color='cornflowerblue'>如方法调用、循环跳转和异常跳转等</font>。</p>
</li>
</ul>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p>
<ol>
<li>抢先式中断：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点，目前没有虚拟机采用了。</li>
<li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<font color='cornflowerblue'>主动轮询</font>这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ol>
<h3 id="52-安全区域safe-region"><a class="markdownIt-Anchor" href="#52-安全区域safe-region"></a> 5.2 安全区域（Safe Region）</h3>
<ul>
<li>
<p>Safe Point 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
</li>
<li>
<p><font color='cornflowerblue'>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</font>。我们也可以把Safe Region看做是被扩展了的Safe Point。</p>
</li>
</ul>
<p><strong>安全区域的执行流程</strong></p>
<ol>
<li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程。</li>
<li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</li>
</ol>
<h2 id="6-再谈引用"><a class="markdownIt-Anchor" href="#6-再谈引用"></a> 6、再谈引用</h2>
<ul>
<li>
<p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
</li>
<li>
<p>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
</li>
<li>
<p>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<p><font color='red'>这四种引用的强度依次减弱。</font></p>
</li>
<li>
<p>除强引用外，其他3种引用均可以在<code>java.lang.ref</code>包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
</li>
</ul>
<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用。</p>
<ol>
<li>强引用（Strong Reference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj = new Object()</code>”这种引用关系。<font color='red'>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用。</font></li>
<li>软引用（Soft Reference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行<font color='red'>第二次回收</font>。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用（Weak Reference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，<font color='red'>无论内存空间是否足够，都会回收掉被弱引用关联的对象。</font></li>
<li>虚引用（Phantom Reference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<font color='red'>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</font></li>
</ol>
<h3 id="61-强引用"><a class="markdownIt-Anchor" href="#61-强引用"></a> 6.1 强引用</h3>
<p><strong>强引用（Strong Reference）：不回收</strong></p>
<ul>
<li>
<p>在Java程序中，最常见的引用类型是强引用<font color='cornflowerblue'>（普通系统99%以上都是强引用）</font>，也就是我们最常见的普通对象引用，<font color='cornflowerblue'>也是默认的引用类型</font>。</p>
</li>
<li>
<p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
</li>
<li>
<p><font color='red'>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</font>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p>
</li>
<li>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<font color='cornflowerblue'>强引用是造成Java内存泄漏的主要原因之一。</font></p>
</li>
</ul>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br><span class="line"></span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>
<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用。对应内存结构：</p>
<p><img src="https://img.picgo.net/2025/01/23/220af395fff51614a8.png" alt="垃圾回收概述-22-240301" /></p>
<p><strong>总结</strong></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ol>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ol>
<h3 id="62-软引用"><a class="markdownIt-Anchor" href="#62-软引用"></a> 6.2 软引用</h3>
<p><strong>软引用（Soft Reference）：内存不足即回收</strong></p>
<ul>
<li>
<p>软引用是用来描述一些还有用，但非必需的对象。<font color='cornflowerblue'>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</font>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象。</p>
</li>
<li>
<p>软引用通常用来实现内存敏感的缓存。比如：<font color='cornflowerblue'>高速缓存</font>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
</li>
<li>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</li>
<li>
<p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象。</p>
</li>
<li>
<p>在JDK1.2之后提供了<code>SoftReference</code>类来实现软引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object();// 声明强引用</span><br><span class="line">SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = null; // 销毁强引用</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SoftReference&lt;<span class="type">byte</span>[]&gt; b = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建对象，建立软引用</span></span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Gerrit&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">// 垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());  <span class="comment">// 由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 让系统认为内存资源紧张、不够</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());  <span class="comment">// 内存不够时，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JVM参数：<code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code></li>
</ul>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[id=1, name=Gerrit] </span><br><span class="line">---目前内存还不紧张---</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 781K-&gt;480K(2560K)] 5901K-&gt;5736K(9728K), 0.0005133 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 480K-&gt;0K(2560K)] [ParOldGen: 5256K-&gt;5641K(7168K)] 5736K-&gt;5641K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0037990 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">After GC:</span><br><span class="line">[id=1, name=Gerrit] </span><br><span class="line">---下面开始内存紧张了---</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 40K-&gt;64K(2560K)] 5682K-&gt;5705K(9728K), 0.0001904 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 64K-&gt;32K(2560K)] 5705K-&gt;5673K(9728K), 0.0002144 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 32K-&gt;0K(2560K)] [ParOldGen: 5641K-&gt;5641K(7168K)] 5673K-&gt;5641K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0015773 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 5641K-&gt;5641K(9728K), 0.0002950 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 5641K-&gt;509K(7168K)] 5641K-&gt;509K(9728K), [Metaspace: 2631K-&gt;2631K(1056768K)], 0.0038927 secs] [Times: user=0.13 sys=0.00, real=0.00 secs] </span><br><span class="line">null</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 41K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0a5a8,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line"> ParOldGen       total 7168K, used 3581K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 49% used [0x00000000ff600000,0x00000000ff97f6f8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 2638K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 280K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>可以看到在JVM内存不足时，会回收软引用对象。</p>
<h3 id="63-弱引用"><a class="markdownIt-Anchor" href="#63-弱引用"></a> 6.3 弱引用</h3>
<p><strong>弱引用（Weak Reference）：发现即回收</strong></p>
<ul>
<li>
<p>弱引用也是用来描述那些非必需对象，<font color='cornflowerblue'>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。</font>在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
</li>
<li>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
</li>
<li>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li>
<p><font color='cornflowerblue'>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</font>如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
</li>
<li>
<p>在JDK1.2之后提供了<code>WeakReference</code>类来实现弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。<font color='cornflowerblue'>弱引用对象更容易、更快被GC回收。</font></p>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Gerrit&quot;</span>));</span><br><span class="line">        <span class="comment">// 从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">// 重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[id=1, name=Gerrit]</span><br><span class="line">After GC:</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>执行垃圾回收后，弱引用对象必定被回收。</p>
<h3 id="64-虚引用"><a class="markdownIt-Anchor" href="#64-虚引用"></a> 6.4 虚引用</h3>
<p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p>
<ul>
<li>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
</li>
<li>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</li>
<li>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的<code>get()</code>方法取得对象时，总是null 。<font color='cornflowerblue'>即通过虚引用无法获取到我们的数据。</font></p>
</li>
<li>
<p><font color='cornflowerblue'>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</font></p>
</li>
<li>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li>
<p><font color='cornflowerblue'>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</font></p>
</li>
<li>
<p>在JDK1.2之后提供了PhantomReference类来实现虚引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj; <span class="comment">// 当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;    <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">// finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);  <span class="comment">// 设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">// 构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;第 1 次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();    <span class="comment">// 一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第 1 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 2 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 null</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ol>
<li>
<p>第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收。</p>
</li>
<li>
<p>第二次调用GC的时候，因为finalize方法只能执行一次，所以将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p>
</li>
</ol>
<h3 id="65-终结器引用"><a class="markdownIt-Anchor" href="#65-终结器引用"></a> 6.5 终结器引用</h3>
<ul>
<li>
<p>它用于实现对象的<code>finalize()</code>方法，也可以称为终结器引用。</p>
</li>
<li>
<p>无需手动编码，其内部配合引用队列使用。</p>
</li>
<li>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的<code>finalize()</code>方法，第二次GC时才回收被引用的对象。</p>
</li>
</ul>
<h1 id="十五-垃圾回收器"><a class="markdownIt-Anchor" href="#十五-垃圾回收器"></a> 十五、垃圾回收器</h1>
<h2 id="1-gc-分类与性能指标"><a class="markdownIt-Anchor" href="#1-gc-分类与性能指标"></a> 1、GC 分类与性能指标</h2>
<h3 id="11-垃圾回收器概述"><a class="markdownIt-Anchor" href="#11-垃圾回收器概述"></a> 1.1 垃圾回收器概述</h3>
<ul>
<li>
<p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p>
</li>
<li>
<p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p>
</li>
<li>
<p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p>
</li>
</ul>
<p><strong>Java不同版本新特性</strong></p>
<ol>
<li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型等。</li>
<li>API层面：Stream API、新的日期时间、Optional、String、集合框架等。</li>
<li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等。</li>
</ol>
<h3 id="12-垃圾回收器分类"><a class="markdownIt-Anchor" href="#12-垃圾回收器分类"></a> 1.2 垃圾回收器分类</h3>
<ol>
<li>按<font color='cornflowerblue'>线程数</font>分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-1-240301337a8c0cf7684c92.png" alt="垃圾回收器-1-240301" /></p>
<ul>
<li>
<p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>
<p>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<font color='cornflowerblue'>串行回收默认被应用在客户端的Client模式下的JVM中。</font></p>
</li>
<li>
<p>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</p>
</li>
</ul>
</li>
<li>
<p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
</li>
</ul>
<ol start="2">
<li>按照<font color='cornflowerblue'>工作模式</font>分，可以分为并发式垃圾回收器和独占式垃圾回收器。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-21-24030151e513de4ba1fcbb.png" alt="垃圾回收概述-21-240301" /></p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<ol start="3">
<li>按<font color='cornflowerblue'>碎片处理方式</font>分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</li>
</ol>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞。</li>
<li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表。</li>
</ul>
<ol start="4">
<li>按<font color='cornflowerblue'>工作的内存区间</font>分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</li>
</ol>
<h3 id="13-评估-gc-的性能指标"><a class="markdownIt-Anchor" href="#13-评估-gc-的性能指标"></a> 1.3 评估 GC 的性能指标</h3>
<p><strong>指标</strong></p>
<ul>
<li>
<p><font color='red'>吞吐量：运行用户代码的时间占总运行时间的比例。</font>（总运行时间 = 程序的运行时间 + 内存回收的时间）</p>
</li>
<li>
<p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p>
</li>
<li>
<p><font color='red'>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</font></p>
</li>
<li>
<p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p>
</li>
<li>
<p><font color='red'>内存占用：Java堆区所占的内存大小。</font></p>
</li>
<li>
<p>快速：一个对象从诞生到被回收所经历的时间。</p>
</li>
</ul>
<ol>
<li>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：
<ul>
<li>吞吐量</li>
<li>暂停时间</li>
</ul>
</li>
</ol>
<p><strong>吞吐量（through put）</strong></p>
<ul>
<li>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。</p>
<ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>
</li>
<li>
<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--2403017cd3bfd9fe59577a.jpeg" alt="垃圾回收器-吞吐量-240301" /></p>
<p><strong>暂停时间（pause time）</strong></p>
<ul>
<li>
<p>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。</p>
<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</li>
</ul>
</li>
<li>
<p>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5，但是总的GC时间可能会长。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/--2403010b04d784d983d834.jpeg" alt="垃圾回收器-暂停时间-240301" /></p>
<p><strong>吞吐量 VS 暂停时间</strong></p>
<ul>
<li>
<p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
</li>
<li>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<font color='cornflowerblue'>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</font>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<font color='cornflowerblue'>交互式应用程序</font>。</p>
</li>
<li>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<font color='cornflowerblue'>只能频繁地执行内存回收</font>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
</li>
<li>
<p>现在标准：<font color='red'>在最大吞吐量优先的情况下，降低停顿时间。</font></p>
</li>
</ul>
<h2 id="2-不同的垃圾回收器概述"><a class="markdownIt-Anchor" href="#2-不同的垃圾回收器概述"></a> 2、不同的垃圾回收器概述</h2>
<p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。那么，Java常见的垃圾收集器有哪些？</p>
<h3 id="21-垃圾收集器发展史"><a class="markdownIt-Anchor" href="#21-垃圾收集器发展史"></a> 2.1 垃圾收集器发展史</h3>
<p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ul>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本。</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布。</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 &quot;No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）。</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用。</li>
</ul>
<h3 id="22-七款经典的垃圾收集器"><a class="markdownIt-Anchor" href="#22-七款经典的垃圾收集器"></a> 2.2 七款经典的垃圾收集器</h3>
<ul>
<li>
<p>串行回收器：Serial、Serial Old</p>
</li>
<li>
<p>并行回收器：ParNew、Parallel Scavenge、Parallel Old</p>
</li>
<li>
<p>并发回收器：CMS、G1</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-2-24030114fc55bb5599096d.png" alt="垃圾回收器-2-240301" /></p>
<p><strong>7 种经典的垃圾收集器与垃圾分代之间的关系</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-3-2403010affe0ad2519cb72.jpeg" alt="垃圾回收器-3-240301" /></p>
<ul>
<li>新年代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS</li>
<li>整堆收集器：G1</li>
</ul>
<p><strong>垃圾收集器的组合关系</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-4-24030193ea0fb167eb35f1.jpeg" alt="垃圾回收器-4-240301" /></p>
<ul>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1。</li>
<li>其中 Serial Old 作为 CMS 出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serial Old GC 组合（JEP366）</li>
<li>（青色虚线）JDK14 中：删除 CMS 垃圾回收器（JEP363）。</li>
</ul>
<p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。<font color='cornflowerblue'>所以我们选择的只是对具体应用最合适的收集器。</font></p>
<h3 id="23-如何查看默认垃圾收集器"><a class="markdownIt-Anchor" href="#23-如何查看默认垃圾收集器"></a> 2.3 如何查看默认垃圾收集器</h3>
<p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程 ID</code></p>
<ul>
<li>
<p>JDK8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:InitialHeapSize=265851776 -XX:MaxHeapSize=4253628416 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>JDK9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:G1ConcRefinementThreads=8 -XX:InitialHeapSize=265851776 -XX:MaxHeapSize=4253628416 -XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="24-serial-回收器串行回收"><a class="markdownIt-Anchor" href="#24-serial-回收器串行回收"></a> 2.4 Serial 回收器：串行回收</h3>
<ul>
<li>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li>
<li>Serial 收集器作为 HotSpot 中 Client 模式下的默认新生代垃圾收集器。</li>
<li><font color='cornflowerblue'>Serial收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</font></li>
<li>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<font color='cornflowerblue'>Serial Old收集器也采用了串行回收和“Stop-The-World”机制，只不过内存回收算法使用的是标记-压缩算法。</font></li>
<li>Serial Old 是运行在 Client 模式下默认的老年代垃圾回收器。</li>
<li>Serial Old 在 server 模式下主要由两个用途：
<ul>
<li>与新生代的 Parallel Scavenge 配合使用。</li>
<li>作为老年代 CMS 收集器的后备垃圾收集方案。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Serial-240301df3d3618327be114.jpeg" alt="垃圾回收器-Serial回收器-240301" /></p>
<ul>
<li>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它<font color='cornflowerblue'>只会使用一个 CPU 或一条收集线程去完成垃圾收集工作</font>，更重要的是在<font color='cornflowerblue'>它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</font>。</p>
</li>
<li>
<p>优势：<font color='cornflowerblue'>简单而高效（与其他收集器的单线程比）</font>，对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在 Client 模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
</li>
<li>
<p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。</p>
<ul>
<li>等价于新生代用 Serial GC，且老年代用 Serial old GC。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解即可，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java web应用程序中是不会采用串行垃圾收集器的。</p>
<h3 id="25-parnew-回收器并行回收"><a class="markdownIt-Anchor" href="#25-parnew-回收器并行回收"></a> 2.5 ParNew 回收器：并行回收</h3>
<ul>
<li>
<p>如果说 SerialGC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 serial 收集器的多线程版本。</p>
<ul>
<li>Par 是 Parallel 的缩写，New 表示只能处理的是新生代。</li>
</ul>
</li>
<li>
<p>ParNew 收集器除了采用<font color='cornflowerblue'>并行回收</font>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是<font color='cornflowerblue'>采用复制算法、&quot;Stop-The-World&quot;机制</font>。</p>
</li>
<li>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-ParNew-2403013ad52f9cfa15b139.jpeg" alt="垃圾回收器-ParNew回收器-240301" /></p>
<ul>
<li>
<p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li>
<p>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）。</p>
</li>
<li>
<p>在程序中，开发人员可以通过选项<code>-XX:+UseParNewGC</code>手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：限制线程数量，默认开启和 CPU 数量相同的线程数。</p>
</li>
</ul>
<p><strong>ParNew 回收器与 Serial 回收器比较</strong></p>
<p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
<p>A：不能</p>
<ol>
<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
<li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作。</li>
</ol>
<h3 id="26-parallel-回收器吞吐量优先"><a class="markdownIt-Anchor" href="#26-parallel-回收器吞吐量优先"></a> 2.6 Parallel 回收器：吞吐量优先</h3>
<ul>
<li>
<p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<font color='cornflowerblue'>复制算法、并行回收和&quot;Stop The World&quot;机制</font>。</p>
</li>
<li>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个<font color='cornflowerblue'>可控制的吞吐量（Throughput）</font>，它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
</li>
<li>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<font color='cornflowerblue'>适合在后台运算而不需要太多交互的任务</font>。因此，常见在服务器环境中使用。例如，那些<font color='cornflowerblue'>执行批量处理、订单处理、工资支付、科学计算的应用程序</font>。</p>
</li>
<li>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
</li>
<li>
<p>Parallel Old 收集器采用了<font color='cornflowerblue'>标记-压缩算法</font>，但同样也是基于<font color='cornflowerblue'>并行回收和&quot;Stop-The-World&quot;机制</font>。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Parallel-Scavenge-24030169e84e42515958d1.jpeg" alt="垃圾回收器-Parallel Scavenge回收器-240301" /></p>
<ul>
<li>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。<font color='cornflowerblue'>在 JDK8 中，默认是此垃圾收集器。</font></li>
</ul>
<p><strong>Parallel Scavenge回收器参数设置</strong></p>
<ol>
<li>
<p><code>-XX:+UseParallelGC</code>：手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
</li>
<li>
<p><code>-XX:+UseParallelOldGC</code>：手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。</li>
<li>默认开启一个，另一个也会被开启。<font color='red'>（互相激活）</font></li>
</ul>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li>
<p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p>
</li>
<li>
<p>当CPU数量大于8个，ParallelGCThreads的值等于<code>3 + [ ( 5 * CPU_Count ) / 8 ]</code>。（12核时ParallelGCThreads的值等于10）</p>
</li>
</ul>
</li>
<li>
<p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</p>
<ul>
<li>
<p>为了尽可能地把停顿时间控制在<code>MaxGCPauseMillis</code>以内，收集器在工作时会调整Java堆大小或者其他一些参数。</p>
</li>
<li>
<p>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</p>
</li>
<li>
<p><font color='red'>该参数使用需谨慎。</font></p>
</li>
</ul>
</li>
<li>
<p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例，即等于<code>1 / ( N + 1 )</code>，用于衡量吞吐量的大小。</p>
<ol>
<li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1%。</li>
<li>与前一个<code>MaxGCPauseMillis</code>参数有一定矛盾性，STW暂停时间越短，垃圾收集时间占总时间的比例就越容易超过设定值。</li>
</ol>
</li>
<li>
<p><code>-XX:+UseAdaptiveSizePolicy</code>：设置Parallel Scavenge收集器具有<font color='cornflowerblue'>自适应调节策略</font>。</p>
<ul>
<li>
<p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li>
<p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p>
</li>
</ul>
</li>
</ol>
<h3 id="27-cms-回收器低延迟"><a class="markdownIt-Anchor" href="#27-cms-回收器低延迟"></a> 2.7 CMS 回收器：低延迟</h3>
<ul>
<li>
<p>在JDK1.5时期，Hotspot推出了一款在<font color='cornflowerblue'>强交互应用中（就是和用户打交道的应用）</font>几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<font color='cornflowerblue'>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</font></p>
</li>
<li>
<p>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><font color='cornflowerblue'>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</font>，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li>
<p>CMS的垃圾收集算法采用<font color='cornflowerblue'>标记-清除</font>算法，并且也会&quot;Stop-the-World&quot;。</p>
</li>
<li>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</p>
</li>
<li>
<p>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</p>
</li>
</ul>
<p><strong>执行流程</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-CMS-2403013af2c01918492649.jpeg" alt="垃圾回收器-CMS回收器-240301" /></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及 STW 的阶段主要是：初始标记 和 重新标记)</p>
<ul>
<li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为&quot;Stop-The-World&quot;机制而出现短暂的暂停，这个阶段的主要任务<font color='red'>仅仅只是标记GC Roots能直接关联到的对象</font>。一旦标记完成之后就会恢复之前被暂停的所有应用线程，由于直接关联对象比较小，所以这个阶段<font color='red'>速度非常快</font>。</li>
<li>并发标记（Concurrent-Mark）阶段：从 GC Roots 的<font color='red'>直接关联对象开始遍历整个对象图的过程</font>，这个过程<font color='red'>耗时较长</font>但是<font color='red'>不需要停顿用户线程</font>，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<font color='red'>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（指可能有存活的对象没有标记）</font>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li>并发清除（Concurrent-Sweep）阶段：此阶段<font color='red'>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</font>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>
</ul>
<p><strong>分析</strong></p>
<ul>
<li>尽管CMS收集器采用的是并发回收（非独占式），<font color='cornflowerblue'>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</font>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li>
<li><font color='cornflowerblue'>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</font></li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，所以<font color='cornflowerblue'>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。</font>因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<font color='cornflowerblue'>而是当堆内存使用率达到某一阈值时，便开始进行回收</font>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“<font color='cornflowerblue'>Concurrent Mode Failure</font>” 失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>CMS收集器的垃圾收集算法采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<font color='cornflowerblue'>不可避免地将会产生一些内存碎片</font>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-6-240301593f0669f0910b69.jpeg" alt="垃圾回收器-6-240301" /></p>
<p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p>
<p>因为并发清除的时用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用。</p>
<p><strong>CMS 的优点与弊端</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>
<p>并发收集</p>
</li>
<li>
<p>低延迟</p>
</li>
</ul>
<p><strong>弊端</strong></p>
<ul>
<li>
<p><font color='cornflowerblue'>会产生内存碎片</font>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</p>
</li>
<li>
<p><font color='cornflowerblue'>CMS收集器对CPU资源非常敏感</font>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</p>
</li>
<li>
<p><font color='cornflowerblue'>CMS收集器无法处理浮动垃圾</font>。可能出现“<font color='cornflowerblue'>Concurrent Mode Failure</font>&quot;失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<font color='cornflowerblue'>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</font>，从而只能在下一次执行GC时释放这些之前未被回收的CMS 参数配置</p>
</li>
</ul>
<p><strong>CMS 参数配置</strong></p>
<ul>
<li>
<p><code>-XX:+UseConcMarkSweepGC</code>：手动指定使用CMS收集器执行内存回收任务。</p>
<ul>
<li>开启该参数后会自动将<code>-XX:+UseParNewGC</code>打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old（Old区备选方案）的组合。</li>
</ul>
</li>
<li>
<p><code>-XX:CMSInitiatingOccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。<font color='cornflowerblue'>JDK6及以上版本默认值为92%。</font></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<font color='cornflowerblue'>因此通过该选项便可以有效降低Full GC的执行次数。</font></li>
</ul>
</li>
<li>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li>
<p><code>-XX:CMSFullGCsBeforeCompaction</code>：设置在执行多少次Full GC后对内存空间进行压缩整理。</p>
</li>
<li>
<p><code>-XX:ParallelCMSThreads</code>：设置CMS的线程数量。</p>
<ul>
<li>CMS默认启动的线程数是 <code>(ParallelGCThreads + 3) / 4</code>，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong></p>
<p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<ul>
<li>
<p>如果你想要最小化地使用内存和并行开销，请选Serial GC；</p>
</li>
<li>
<p>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</p>
</li>
<li>
<p>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</p>
</li>
</ul>
<p><strong>JDK 后续版本中 CMS 的变化</strong></p>
<ul>
<li>
<p>JDK9新特性：CMS被标记为Deprecate了（JEP291）</p>
<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li>
</ul>
</li>
<li>
<p>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，</p>
<ul>
<li>如果在JDK14中使用<code>-XX:+UseConcMarkSweepGC</code>的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM。</li>
</ul>
</li>
</ul>
<h3 id="28-g1-回收器区域化分代式"><a class="markdownIt-Anchor" href="#28-g1-回收器区域化分代式"></a> 2.8 G1 回收器：区域化分代式</h3>
<p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p>
<ul>
<li>
<p>原因就在于应用程序所应对的<font color='cornflowerblue'>业务越来越庞大、复杂，用户越来越多</font>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
</li>
<li>
<p>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
</li>
<li>
<p>与此同时，<font color='cornflowerblue'>为了适应现在不断扩大的内存和不断增加的处理器数量</font>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
</li>
<li>
<p><font color='cornflowerblue'>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</font></p>
</li>
</ul>
<p><strong>为什么名字叫Garbage First(G1)呢？</strong></p>
<ul>
<li>
<p>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</p>
</li>
<li>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color='cornflowerblue'>每次根据允许的收集时间，优先回收价值最大的Region</font>。</p>
</li>
<li>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</p>
</li>
<li>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<font color='cornflowerblue'>主要针对配备多核CPU及大容量内存的机器</font>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</p>
</li>
<li>
<p>在JDK1.7版本正式启用，移除了Experimental的标识，<font color='cornflowerblue'>是JDK9以后的默认垃圾回收器</font>，取代了CMS回收器以及Parallel + Parallel Old组合。被Oracle官方称为<font color='cornflowerblue'>“全功能的垃圾收集器”</font>。</p>
</li>
<li>
<p>与此同时，CMS已经在JDK9中被标记为废弃（Deprecated）。<font color='cornflowerblue'>G1在JDK8中还不是默认的垃圾回收器</font>，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
</li>
</ul>
<p><strong>G1 回收器的优势</strong></p>
<p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<ol>
<li>
<p>并行与并发兼备</p>
<ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li>
</ul>
</li>
<li>
<p>分代收集</p>
<ul>
<li>
<p>从分代上看，<font color='cornflowerblue'>G1依然属于分代型垃圾回收器</font>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p>
</li>
<li>
<p><font color='cornflowerblue'>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</font></p>
</li>
<li>
<p>和之前的各类回收器不同，它同时<font color='cornflowerblue'>兼顾年轻代和老年代</font>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</p>
<p>G1的分代，已经不是下面这样的了：</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-7-240301c632f4c6e8592878.jpeg" alt="垃圾回收器-7-240301" /></p>
<p>​			而是如下图这样的一个区域：</p>
<p><img src="https://img.picgo.net/2025/01/20/-8-240301cdd02a36e1b0bf92.jpeg" alt="垃圾回收器-8-240301" /></p>
<ol start="3">
<li>
<p>空间整合</p>
<ul>
<li>CMS：标记-清除算法，会产生内存碎片，若干次GC后进行一次碎片整理。</li>
<li>G1将内存划分为一个个的Region。内存的回收是以Region作为基本单位的。<font color='cornflowerblue'>Region之间是复制算法，但整体上实际可看作是标记-压缩算法</font>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li>
<p>可预测的停顿时间模型（即：软实时soft real-time）</p>
<ul>
<li>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
<ul>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<font color='cornflowerblue'>每次根据允许的收集时间，优先回收价值最大的Region</font>。保证了G1收集器在有限的时间内可以<font color='cornflowerblue'>获取尽可能高的收集效率</font>。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>G1 回收器的缺点</strong></p>
<ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li>
</ol>
<p><strong>G1 参数设置</strong></p>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用G1垃圾收集器执行内存回收任务。</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms。</li>
<li><code>-XX:ParallelGCThread</code>：设置STW时GC线程数的值。最多设置为8。</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code>：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</li>
</ul>
<p><strong>G1 收集器的常见操作步骤</strong></p>
<p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ol>
<li>开启G1垃圾收集器。</li>
<li>设置堆的最大内存。</li>
<li>设置最大的停顿时间。</li>
</ol>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p>
<p><strong>G1 的适用场景</strong></p>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是给需要低GC延迟，并具有大堆的应用程序提供解决方案。
<ul>
<li>如在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>
</ul>
</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：
<ul>
<li>超过50%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于0.5至1秒）。</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ul>
<h4 id="分区-region化整为零"><a class="markdownIt-Anchor" href="#分区-region化整为零"></a> 分区 Region：化整为零</h4>
<ul>
<li>
<p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<font color='cornflowerblue'>所有的Region大小相同，且在JVM生命周期内不会被改变。</font></p>
</li>
<li>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
</li>
<li>
<p>一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li>
<p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果<font color='red'>超过0.5个Region，就放到H</font>。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-region-240301b174a4c427cfe0f5.jpg" alt="垃圾回收器-region-240301" /></p>
<p><strong>设置 H 的原因</strong></p>
<p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。<font color='cornflowerblue'>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。</font>为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p><strong>Region的细节</strong></p>
<ol>
<li>每个Region都是通过指针碰撞来分配空间。</li>
<li>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li>TLAB用来保证并发性。</li>
</ol>
<p><strong>G1 垃圾回收流程</strong></p>
<p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-9-24030171d8ab85e969f24e.png" alt="垃圾回收器-9-240301" /></p>
<ol>
<li>应用程序分配内存，<font color='cornflowerblue'>当年轻代的Eden区用尽时开始年轻代回收过程</font>；G1的年轻代收集阶段是一个<font color='cornflowerblue'>并行的独占式收集器</font>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<font color='cornflowerblue'>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能两个区间都会涉及。</font></li>
<li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。与G1的年轻代回收器和其他GC回收器不同，<font color='cornflowerblue'>G1的老年代回收器不需要回收整个老年代，一次只需要扫描/回收一小部分老年代的Region就可以了。</font>同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ol>
<p><strong>Remembered Set（记忆集）</strong></p>
<ul>
<li>
<p>一个对象被不同区域引用的问题。</p>
</li>
<li>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
</li>
<li>
<p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）。</p>
</li>
<li>
<p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率。</p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描。</p>
</li>
<li>
<p><font color='cornflowerblue'>每个Region都有一个对应的Remembered Set。</font></p>
</li>
<li>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作。</p>
</li>
<li>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）。</p>
</li>
<li>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中。</p>
</li>
<li>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-10-240301996aa998a81c6702.png" alt="垃圾回收器-10-240301" /></p>
<h4 id="g1回收过程一年轻代-gc"><a class="markdownIt-Anchor" href="#g1回收过程一年轻代-gc"></a> G1回收过程一：年轻代 GC</h4>
<ol>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li>年轻代回收只回收Eden区和Survivor区。</li>
<li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-11-24030145e8e40fa2eeee6a.png" alt="垃圾回收器-11-240301" /></p>
<blockquote>
<p>复制算法（S、E–&gt;空闲区相当于To区）（S–&gt;寻找新的空闲区作为老年代）</p>
</blockquote>
<p><strong>然后开始如下回收过程：</strong></p>
<p><font color='red'>第一阶段，扫描根。</font></p>
<p>​	根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p><font color='red'>第二阶段，更新RSet。</font></p>
<p>​	处理dirty card queue中的card，更新RSet。 此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用（指的新生代）。</p>
<ul>
<li>dirty card queue：对于应用程序的引用赋值语句object.field=object，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>
<li>在年轻代回收的时候， G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ul>
<p><font color='red'>第三阶段，处理RSet。</font></p>
<p>​	识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p><font color='red'>第四阶段，复制对象。</font></p>
<p>​	此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p><font color='red'>第五阶段，处理引用。</font></p>
<p>​	处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
<h4 id="g1回收过程二并发标记过程"><a class="markdownIt-Anchor" href="#g1回收过程二并发标记过程"></a> G1回收过程二：并发标记过程</h4>
<ol>
<li><font color='red'>初始标记阶段</font>：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li>
<li><font color='red'>根区域扫描（Root Region Scanning）</font>：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li>
<li><font color='red'>并发标记（Concurrent Marking）</font>：
<ul>
<li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li>
<li><font color='cornflowerblue'>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</font></li>
<li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
</ul>
</li>
<li><font color='red'>再次标记（Remark）</font>：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li>
<li><font color='red'>独占清理（cleanup，STW）</font>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。
<ul>
<li>这个阶段并不会实际上去做垃圾的收集。</li>
</ul>
</li>
<li><font color='red'>并发清理阶段</font>：识别并清理完全空闲的区域。</li>
</ol>
<h4 id="g1回收过程三混合回收过程"><a class="markdownIt-Anchor" href="#g1回收过程三混合回收过程"></a> G1回收过程三：混合回收过程</h4>
<p>​	当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="https://img.picgo.net/2025/01/20/-12-2403016721689d39f2bf1c.png" alt="垃圾回收器-12-240301" /></p>
<p><strong>混合回收的细节</strong></p>
<ul>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收。（意思就是一个Region会被分为8个内存段）</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。<font color='cornflowerblue'>垃圾占内存分段比例越高的，越会被先回收。</font>并且有一个阈值会决定内存分段是否被回收。<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<h4 id="g1回收可选的过程四full-gc"><a class="markdownIt-Anchor" href="#g1回收可选的过程四full-gc"></a> G1回收可选的过程四：Full GC</h4>
<ul>
<li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<font color='cornflowerblue'>单线程</font>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</li>
<li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Full GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</li>
</ul>
<p>导致G1 Full GC的原因可能有两个：</p>
<ol>
<li>回收阶段没有足够的to-space来存放晋升的对象。</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<h4 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h4>
<p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而<font color='cornflowerblue'>选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中</font>。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p><strong>G1 回收器的优化建议</strong></p>
<ol>
<li>年轻代大小
<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整。</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛
<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间。</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ol>
<h3 id="29-垃圾回收器总结"><a class="markdownIt-Anchor" href="#29-垃圾回收器总结"></a> 2.9 垃圾回收器总结</h3>
<p><strong>7 种垃圾回收器的比较</strong></p>
<p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="https://img.picgo.net/2025/01/20/-13-240301978b96b59371bcf1.jpeg" alt="垃圾回收器-13-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-14-240301cdd6f227e6f12a2d.png" alt="垃圾回收器-14-240301" /></p>
<p><strong>怎么选择垃圾回收器</strong></p>
<p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器。</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，使用串行收集器。</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择。</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器。</li>
<li>官方推荐G1，性能高。<font color='cornflowerblue'>现在互联网的项目，基本都是使用G1。</font></li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集算法。</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器。</li>
</ol>
<p><strong>面试</strong></p>
<ol>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li>
<li>这里较通用、基础性的部分如下：
<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</li>
</ol>
<h2 id="3-gc-日志分析"><a class="markdownIt-Anchor" href="#3-gc-日志分析"></a> 3、GC 日志分析</h2>
<h3 id="31-常用参数配置"><a class="markdownIt-Anchor" href="#31-常用参数配置"></a> 3.1 常用参数配置</h3>
<p>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</p>
<p>内存分配与垃圾回收的参数列表</p>
<ol>
<li><code>-XX:+PrintGC</code>：输出GC日志。类似：<code>-verbose:gc</code></li>
<li><code>-XX:+PrintGCDetails</code>：输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>：输出GC的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDateStamps</code>：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li>
<li><code>-XX:+PrintHeapAtGC</code>：在进行GC的前后打印出堆的信息</li>
<li>-<code>Xloggc:…/logs/gc.log</code>：日志文件的输出路径</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-Xms60m -Xmx60m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">            list.add(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGC/-verbose:gc</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  15324K-&gt;15322K(58880K), 0.0031346 secs]</span><br><span class="line">[GC (Allocation Failure)  30682K-&gt;30468K(58880K), 0.0037461 secs]</span><br><span class="line">[Full GC (Ergonomics)  30468K-&gt;30325K(58880K), 0.0053327 secs]</span><br><span class="line">[Full GC (Ergonomics)  45685K-&gt;45528K(58880K), 0.0039465 secs]</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGCDetails</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 15324K-&gt;2556K(17920K)] 15324K-&gt;15274K(58880K), 0.0041477 secs] [Times: user=0.00 sys=0.13, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 17916K-&gt;2532K(17920K)] 30634K-&gt;30460K(58880K), 0.0041784 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 2532K-&gt;0K(17920K)] [ParOldGen: 27928K-&gt;30325K(40960K)] 30460K-&gt;30325K(58880K), [Metaspace: 2625K-&gt;2625K(1056768K)], 0.0064628 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 15360K-&gt;5000K(17920K)] [ParOldGen: 30325K-&gt;40527K(40960K)] 45685K-&gt;45528K(58880K), [Metaspace: 2625K-&gt;2625K(1056768K)], 0.0037207 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 17920K, used 10633K [0x00000000fec00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 15360K, 69% used [0x00000000fec00000,0x00000000ff6625c8,0x00000000ffb00000)</span><br><span class="line">  from space 2560K, 0% used [0x00000000ffd80000,0x00000000ffd80000,0x0000000100000000)</span><br><span class="line">  to   space 2560K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffd80000)</span><br><span class="line"> ParOldGen       total 40960K, used 40527K [0x00000000fc400000, 0x00000000fec00000, 0x00000000fec00000)</span><br><span class="line">  object space 40960K, 98% used [0x00000000fc400000,0x00000000feb93e98,0x00000000fec00000)</span><br><span class="line"> Metaspace       used 2632K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p><strong><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2021-10-08T20:43:11.758+0800: 0.072: [GC (Allocation Failure)  15324K-&gt;15322K(58880K), 0.0033766 secs]</span><br><span class="line">2021-10-08T20:43:11.763+0800: 0.076: [GC (Allocation Failure)  30682K-&gt;30580K(58880K), 0.0040002 secs]</span><br><span class="line">2021-10-08T20:43:11.766+0800: 0.080: [Full GC (Ergonomics)  30580K-&gt;30325K(58880K), 0.0053498 secs]</span><br><span class="line">2021-10-08T20:43:11.772+0800: 0.086: [Full GC (Ergonomics)  45685K-&gt;45528K(58880K), 0.0039231 secs]</span><br></pre></td></tr></table></figure>
<h3 id="32-gc-日志补充说明"><a class="markdownIt-Anchor" href="#32-gc-日志补充说明"></a> 3.2 GC 日志补充说明</h3>
<ol>
<li>“GC&quot;和”Full GC&quot;说明了这次垃圾收集的停顿类型，如果是&quot;Full GC&quot;则说明发生了&quot;Stop The World&quot;。</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是&quot;DefNew&quot;。</li>
<li>使用ParNew收集器在新生代的名字会变成&quot;ParNew&quot;，意思是&quot;Parallel New Generation&quot;。</li>
<li>使用Parallel Scavenge收集器在新生代的名字是”PSYoungGen&quot;。</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的。</li>
<li>使用G1收集器的话，会显示为&quot;garbage-first heap&quot;。</li>
<li>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</li>
<li><code>[PSYoungGen: 15324K-&gt;2556K(17920K)] 15324K-&gt;15274K(58880K)</code>
<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间。</li>
</ol>
<p><strong>GC</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-15-240301605cefc98cc10f0c.jpeg" alt="垃圾回收器-15-240301" /></p>
<p><strong>Full GC</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-16-240301be13001555ebb8cf.jpeg" alt="垃圾回收器-16-240301" /></p>
<h3 id="33-gc-日志分析"><a class="markdownIt-Anchor" href="#33-gc-日志分析"></a> 3.3 GC 日志分析</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 6967K-&gt;520K(9216K), 0.0029979 secs] 6967K-&gt;6664K(19456K), 0.0030609 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 4781K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  52% used [0x00000000fec00000, 0x00000000ff0290e0, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  50% used [0x00000000ff500000, 0x00000000ff5823b8, 0x00000000ff600000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line"> tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 2629K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 279K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<ol>
<li>首先将3个2M的对象存放到Eden区，后面4M的对象来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次YGC，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-17-24030136ec53cf80809d13.png" alt="垃圾回收器-17-240301" /></p>
<ol start="2">
<li>腾出空间后，将4M对象存入到Eden区中。</li>
</ol>
<p><img src="https://img.picgo.net/2025/01/20/-18-240301bee93226f609ec1a.png" alt="垃圾回收器-18-240301" /></p>
<h3 id="34-常用日志分析工具"><a class="markdownIt-Anchor" href="#34-常用日志分析工具"></a> 3.4 常用日志分析工具</h3>
<p><strong>保存日志文件</strong></p>
<p><strong>JVM参数</strong>：<code>-Xloggc:./logs/gc.log</code>， ./ 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录。</p>
<p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p>
<p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等。</p>
<p><strong>推荐：GCeasy</strong></p>
<p>在线分析网址：<span class="exturl" data-url="aHR0cDovL2djZWFzeS5pbw==">gceasy.io<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://img.picgo.net/2025/01/20/-19-24030115db9abfa4850cd2.png" alt="垃圾回收器-19-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-20-240301638d167fc2188db5.png" alt="垃圾回收器-20-240301" /></p>
<p><img src="https://img.picgo.net/2025/01/20/-21-240301e2614e7cde73528d.png" alt="垃圾回收器-21-240301" /></p>
<h2 id="4-垃圾回收器的新发展"><a class="markdownIt-Anchor" href="#4-垃圾回收器的新发展"></a> 4、垃圾回收器的新发展</h2>
<p>​	GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，FullGC已经是并行运行，在很多场景下，其表现还略优于Parallel GC的并行Full GC实现。</p>
<p>​	即使是Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<font color='cornflowerblue'>在Serverless等新的应用场景下，Serial GC找到了新的舞台。</font></p>
<p>​	比较不幸的是CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除。</p>
<p>​	现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</p>
<h3 id="41-open-jdk12的shenandoash-gc低停顿时间的gc实验性"><a class="markdownIt-Anchor" href="#41-open-jdk12的shenandoash-gc低停顿时间的gc实验性"></a> 4.1 Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</h3>
<ul>
<li>
<p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称OpenJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li>
<p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<font color='cornflowerblue'>旨在针对JVM上的内存回收实现低停顿的需求</font>。在2014年贡献给OpenJDK。</p>
</li>
<li>
<p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
</li>
<li>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-Shenandoah-2403014156181d344db4af.png" alt="垃圾回收器-Shenandoah-240301" /></p>
<p>总结</p>
<ol>
<li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC的强项：低延迟时间。</li>
</ol>
<h3 id="42-令人震惊-革命性的-zgcjdk14-新特性"><a class="markdownIt-Anchor" href="#42-令人震惊-革命性的-zgcjdk14-新特性"></a> 4.2 <strong>令人震惊、革命性的 ZGC（JDK14 新特性）</strong></h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMTIvZ2N0dW5pbmcv">官方文档<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>ZGC与Shenandoah目标高度相似，在<font color='cornflowerblue'>尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</font></li>
<li>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<font color='cornflowerblue'>可并发的标记-压缩算法</font>的，以<font color='cornflowerblue'>低延迟为首要目标</font>的一款垃圾收集器。</li>
<li>ZGC的工作过程可以分为4个阶段：<font color='cornflowerblue'>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</font>等。</li>
<li>ZGC几乎在所有地方并发执行的，除了<font color='cornflowerblue'>初始标记的是STW的</font>。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li>
</ul>
<p><strong>吞吐量</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC1-240301adf6d068206269f3.png" alt="垃圾回收器-ZGC1-240301" /></p>
<ul>
<li>
<p>max-JOPS：以低延迟为首要前提下的数据</p>
</li>
<li>
<p>critical-JOPS：不考虑低延迟下的数据</p>
</li>
</ul>
<p><strong>暂停时间</strong></p>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC2-2403013dd0918acc912d1a.png" alt="垃圾回收器-ZGC2-240301" /></p>
<ul>
<li>
<p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p>
</li>
<li>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</li>
</ul>
<p><img src="https://img.picgo.net/2025/01/20/-ZGC3-2403010c250759cfcd1ce1.png" alt="垃圾回收器-ZGC3-240301" /></p>
<ul>
<li>
<p>JDK14之前，ZGC仅Linux才支持。</p>
</li>
<li>
<p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p>
</li>
<li>
<p>现在mac或Windows上也能使用ZGC了，示例如下：</p>
<p><code>-XX:+UnlockExperimentalVMOptions -XX：+UseZGC</code></p>
</li>
</ul>
<h3 id="43-其他垃圾回收器aligc"><a class="markdownIt-Anchor" href="#43-其他垃圾回收器aligc"></a> 4.3 其他垃圾回收器：AliGC</h3>
<p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://img.picgo.net/2025/01/20/-AliGC-240301968f08e3f45a3398.png" alt="垃圾回收器-AliGC-240301" /></p>
<blockquote>
<p>当然，其他厂商也提供了各种独具一格的GC实现，例如比较有名的低延迟GC，Zing，有兴趣可以参考提供的链接。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL2FydGljbGVzL2F6dWxfZ2NfaW5fZGV0YWls">https://www.infoq.com/articles/azul_gc_in_detail<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异步编程</title>
    <url>/2024/Java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>通常，Java开发者使用阻塞式（blocking）同步方式编写代码。这没有问题，在出现性能瓶颈后，我们可以增加处理线程，线程中同样是阻塞的代码。但是这种使用资源的方式会迅速面临资源竞争和并发问题。</p>
<span id="more"></span>
<p>更糟糕的是，阻塞会浪费资源。具体来说，比如当一个程序面临延迟（通常是I/O方面， 比如数据库读写请求或网络调用），所在线程需要进入 idle 状态等待数据，从而浪费资源。</p>
<p>异步编程适用于大多数<strong>IO密集型</strong>的系统, 可以提高系统<strong>整体</strong>的响应性和吞吐量。</p>
<h1 id="future"><a class="markdownIt-Anchor" href="#future"></a> Future</h1>
<p>在Jdk1.5后, 我们可以用Future来访问异步计算的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">   <span class="comment">// 进行一些耗时计算</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...做些其他事情</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> future.get();  <span class="comment">// 获取结果</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式也有缺陷:</p>
<ol>
<li>
<p>无法方便得知任务何时完成</p>
</li>
<li>
<p>获得任务结果会导致线程阻塞</p>
</li>
<li>
<p>缺少异常处理</p>
</li>
</ol>
<p><code>CompletableFuture</code> 是 Jdk 8 引入的一个类，用于表示异步计算的结果。它提供了一些方法，可以在计算完成后执行一些操作，或者组合多个 <code>CompletableFuture</code> 来实现复杂的异步逻辑。</p>
<p>考虑这样一种情景：在用户界面上显示用户的5个收藏，如果没有任何收藏则提供5个建议。这需要3个服务（一个提供收藏的ID列表，第二个服务获取收藏内容，第三个提供建议内容）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 userService 获取收藏的 ID 列表</span></span><br><span class="line">CompletableFuture&lt;List&lt;String&gt;&gt; favorites = userService.getFavorites(userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 favoriteService 获取每个收藏的详情</span></span><br><span class="line">CompletableFuture&lt;List&lt;Detail&gt;&gt; details = favorites.thenCompose(favList -&gt; &#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;Detail&gt;&gt; detailFutures = favList.stream()</span><br><span class="line">            .map(favoriteService::getDetails)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.allOf(detailFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]))</span><br><span class="line">            <span class="comment">// 将合并的 future 转换为一个详情列表</span></span><br><span class="line">            .thenApply(v -&gt; detailFutures.stream()</span><br><span class="line">                    .map(CompletableFuture::join)</span><br><span class="line">                    .collect(Collectors.toList()));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 exceptionally 处理 details future 失败或返回空列表的情况</span></span><br><span class="line"><span class="comment">// 在这种情况下，获取一个 CompletableFuture，包含建议内容</span></span><br><span class="line">CompletableFuture&lt;List&lt;Detail&gt;&gt; suggestions = details.exceptionally(ex -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> suggestionService.getSuggestions();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将列表项目数量限制为 5 个</span></span><br><span class="line">CompletableFuture&lt;List&lt;Detail&gt;&gt; topFive = suggestions.thenApply(list -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.subList(<span class="number">0</span>, Math.min(<span class="number">5</span>, list.size()));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 UI 线程调度器上发布结果，并在 uiList 上显示</span></span><br><span class="line">topFive.thenAcceptAsync(uiList::show, UiUtils.uiThreadScheduler())</span><br><span class="line">       .exceptionally(ex -&gt; &#123;</span><br><span class="line">           UiUtils.errorPopup(ex);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h1 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h1>
<p>提交了一次请求, 然后在事情完成后, 自动&quot;调用回来&quot;执行下一步操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSomeAsyncTask(result -&gt; &#123;</span><br><span class="line">   <span class="comment">// 耗时任务完成后,执行此回调</span></span><br><span class="line">   showResult(result); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是在一些复杂场景会导致“回调地狱”, 导致代码难以理解和维护。比如用Callback实现上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userService.getFavorites(userId, <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 收藏为空, 获取建议内容</span></span><br><span class="line">            suggestionService.getSuggestions(<span class="keyword">new</span> <span class="title class_">Callback</span>&lt;List&lt;Favorite&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(List&lt;Favorite&gt; list)</span> &#123;</span><br><span class="line">                    UiUtils.submitOnUiThread(() -&gt; &#123;</span><br><span class="line">                        list.stream()</span><br><span class="line">                                .limit(<span class="number">5</span>)</span><br><span class="line">                                .forEach(uiList::show);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable error)</span> &#123;</span><br><span class="line">                    UiUtils.errorPopup(error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取收藏内容</span></span><br><span class="line">            list.stream()</span><br><span class="line">                    .limit(<span class="number">5</span>)</span><br><span class="line">                    .forEach(favId -&gt; favoriteService.getDetails(favId,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Callback</span>&lt;Favorite&gt;() &#123;</span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(Favorite details)</span> &#123;</span><br><span class="line">                                    UiUtils.submitOnUiThread(() -&gt; uiList.show(details));</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable error)</span> &#123;</span><br><span class="line">                                    UiUtils.errorPopup(error);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                    ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable error)</span> &#123;</span><br><span class="line">        UiUtils.errorPopup(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="响应式"><a class="markdownIt-Anchor" href="#响应式"></a> 响应式</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9oYW50YS55dXF1ZS5jb20vcHg3a2cxL25uMWdkci95cTFjem4zYzVxa3JwdjRnI2h5cXJW">响应式编程说明<i class="fa fa-external-link-alt"></i></span></p>
<p>响应式编程是强调<strong>异步的、非阻塞的、事件驱动</strong>的、基于回调或流的编程风格。响应式编程的核心思想是将<strong>数据和事件作为流来处理</strong>，而不是作为单个的值或对象。开发者可以使用各种操作符来对流进行转换、过滤、合并、分组等操作，从而实现复杂的业务逻辑。</p>
<blockquote>
<p>目前，在 Java 领域实现了响应式编程的技术有 Spring 的 Project Reactor、Netflix RxJava 1/2 等。前者的 3.0 版本作为 Spring 5 的基础，在17年底发布，推动了后端领域响应式编程的发展。后者出现时间更早，在前端开发领域应用的比后端更要广泛一些。</p>
</blockquote>
<p>上面的例子使用Reactor实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userService.getFavorites(userId)  <span class="comment">// 获取收藏的ID列表到集合数据流</span></span><br><span class="line">           .flatMap(favoriteService::getDetails) <span class="comment">// 获取收藏内容</span></span><br><span class="line">           .switchIfEmpty(suggestionService.getSuggestions()) <span class="comment">// 如果为空获取建议内容</span></span><br><span class="line">           .take(<span class="number">5</span>) <span class="comment">// 只拿执行流中的5个</span></span><br><span class="line">           .publishOn(UiUtils.uiThreadScheduler()) <span class="comment">// 发布到 UI 线程中进行处理</span></span><br><span class="line">           .subscribe(uiList::show, UiUtils::errorPopup);  <span class="comment">// 订阅处理结果</span></span><br></pre></td></tr></table></figure>
<p>可以发现响应式版本的代码结构更清晰, 易读性也更高。此外 Reactor 支持<strong>背压机制</strong>，可以对上游发送反馈信号，控制数据流的速度，避免生产者和消费者之间的压力差异。</p>
<p>缺点是使用了函数式编程和链式调用，需要学习新的 API 和编程模型，以及需要理解和调试多个异步事件和数据流之间的动态交互，学习曲线较陡峭，调试也比较困难。另外虽然相对于 Callback，代码可读性更高，但这种优点是相对的，相对于传统代码，可读性就成了反应式编程的缺点。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzA2NzcxMi9hcnRpY2xlL2RldGFpbHMvMTA2MjY3NDE4">R2DBC pk JDBC 和 WebFlux pk Web MVC 评测数据<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="project-loom"><a class="markdownIt-Anchor" href="#project-loom"></a> Project Loom</h1>
<p><img src="https://img.picgo.net/2025/01/06/Pasted-image-20240130154036ac3a9a0f8221f63d.png" alt="Pasted image 20240130154036.png" /></p>
<p>为了让简单和高并发这两个目标兼得，我们需要 Project Loom。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jci5vcGVuamRrLm9yZy9+cnByZXNzbGVyL2xvb20vTG9vbS1Qcm9wb3NhbC5odG1s">这篇文档介绍了发起 Project Loom 的原因，以及 Java 线程基础的很多底层设计<i class="fa fa-external-link-alt"></i></span></p>
<p>使用虚拟线程实现上面的例子:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">    List&lt;String&gt; favorites = userService.getFavorites(userId); <span class="comment">// 获取收藏列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (favorites.isEmpty()) &#123; <span class="comment">// 收藏为空，获取建议内容</span></span><br><span class="line">        <span class="comment">// 获取建议列表</span></span><br><span class="line">        List&lt;Favorite&gt; suggestions = suggestionService.getSuggestions()</span><br><span class="line">                .stream()</span><br><span class="line">                .limit(<span class="number">5</span>)</span><br><span class="line">                .toList();</span><br><span class="line">        UiUtils.submitOnUiThread(() -&gt; &#123;</span><br><span class="line">            suggestions.forEach(uiList::show); <span class="comment">// 在 UI 线程中显示建议列表</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取收藏内容</span></span><br><span class="line">        favorites.stream()</span><br><span class="line">            .limit(<span class="number">5</span>)</span><br><span class="line">            .forEach(favId -&gt; &#123;</span><br><span class="line">                <span class="type">Favorite</span> <span class="variable">details</span> <span class="operator">=</span> favoriteService.getDetails(favId); <span class="comment">// 获取收藏详情</span></span><br><span class="line">                UiUtils.submitOnUiThread(() -&gt; uiList.show(details)); <span class="comment">// 在 UI 线程中显示收藏详情</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Project Loom 是一个 Java 项目，不同于之前的方案，Project Loom 是<strong>从</strong> <strong>JVM 层面对多线程技术进行彻底的改变</strong>。它为开发者提供了一种轻量级的并发抽象，称为虚拟线程，本质上它是一种有栈协程。</p>
<p><img src="https://img.picgo.net/2025/01/06/Pasted-image-20240130154047a872e5bdb3be9569.png" alt="Pasted image 20240130154047.png" /></p>
<blockquote>
<p>Green Thread是在OS Thread在用户空间的模拟，是一种在<strong>根本没有本机多线程支持的系统</strong>上支持多线程的解决方案。在这样的系统中，单个阻塞调用将阻塞整个进程，从而阻塞所有线程。现在已经不常使用了。</p>
</blockquote>
<p>虚拟线程有以下几个优势：</p>
<ul>
<li>
<p>虚拟线程不依赖于 OS 线程，而是由 JVM 在内部调度和执行。它只包含 Java 的调用栈，可以在需要的时候暂停和恢复自己的执行状态。</p>
</li>
<li>
<p><strong>虚拟线程的调用栈可以动态地增长和缩小</strong>，节省内存空间和提高性能。相比之下，OS 线程的调用栈是固定的大小，占用大量的内存空间（64 位 Linux 上 HotSpot 的线程栈容量默认是 1MB，而虚拟线程仅需要200-300字节来存储元数据）。因此，虚拟线程可以支持更高的并发度和更低的上下文切换开销。</p>
</li>
<li>
<p>虚拟线程的数量只受限于可用的内存和 CPU 资源，而不是 OS 的限制。在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ViYXJsYXMvcHJvamVjdC1sb29tLWM1bQ==">Project Loom C5M<i class="fa fa-external-link-alt"></i></span>中，已经成功地使用虚拟线程在C/S应用中实现500万个长连接。这意味着虚拟线程可以让开发者使用一对一的模型来编写并发代码，即每个请求或任务对应一个虚拟线程，而不需要使用线程池或其他复杂的机制来复用或管理线程。</p>
</li>
<li>
<p>虚拟线程可以实现对阻塞操作的透明化。当虚拟线程遇到一个阻塞操作，比如等待 I/O，JVM 会检测到这个操作，并把虚拟线程设置为 park 状态，等待 I/O 响应。同时，JVM 会把 OS 线程分配给其他可运行的虚拟线程，从而避免浪费 CPU 资源。当 I/O 响应到来时，JVM 会把虚拟线程恢复为 run 状态，并重新分配 OS 线程给它。</p>
</li>
</ul>
<p>基于上面的优势，开发者可以使用传统的同步和命令式的编程风格来写异步和非阻塞的代码，而不需要使用复杂的回调或者函数式编程。代码变得更简单、更清晰、更容易调试和维护，并发性能和资源利用率也得以提高。</p>
<p>很快，Project Loom 将在 JDK 21 中正式发布。JDK 21 也是下一个长期支持（LTS）的版本，这意味着 Project Loom 将得到更广泛和更稳定的应用。Project Loom 的出现可以使得 Java 在云原生时代能更好地适应高并发、低延迟、高吞吐的需求，同时简化开发者的编程模型和心智负担，让 Java 摆脱传统的线程模型的束缚，提高资源利用率和性能，降低复杂度和成本。Project Loom 无疑是 Java 的一个重大创新，它将为 Java 的未来带来更多的可能性和机遇。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<ul>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG91dGlhby5jb20vYXJ0aWNsZS82ODYxOTAwMjg1MzYzNjE4MzEyLz93aWQ9MTY4NzIyNjI3NjcyMQ==">Java 异步编程：从 Future 到 Loom-今日头条 (toutiao.com)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly90aW1lLmdlZWtiYW5nLm9yZy9jb2x1bW4vYXJ0aWNsZS8zMjExODU=">云原生时代的Java (geekbang.org)<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzNzA2NjkvcHJvamVjdC1sb29tLXdoYXQtbWFrZXMtdGhlLXBlcmZvcm1hbmNlLWJldHRlci13aGVuLXVzaW5nLXZpcnR1YWwtdGhyZWFkcw==">java - Project loom: what makes the performance better when using virtual threads? - Stack Overflow<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzY3NTc5NzkwL2Fuc3dlci8yOTM2NDY3MjI5">如何看待Project Loom? - 圆胖肿的回答 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM3NTk5Njk3OA==">对于后端开发，响应式编程真的是大势所趋吗？ - 知乎 (zhihu.com)<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown 渲染测试</title>
    <url>/2024/Markdown%E6%B8%B2%E6%9F%93%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="obsidian-flavored-markdownofm"><a class="markdownIt-Anchor" href="#obsidian-flavored-markdownofm"></a> Obsidian Flavored Markdown（OFM）</h1>
<h2 id="callouts"><a class="markdownIt-Anchor" href="#callouts"></a> Callouts</h2>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>note default</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>foo</p>
</div>
</details><details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>note open</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>foo</p>
</div>
</details><details class="custom-callout note"><summary class="callout-title"><div class="callout-icon"></div><div>note closed</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>foo</p>
</div>
</details><h2 id="codeblock"><a class="markdownIt-Anchor" href="#codeblock"></a> Codeblock</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">CODE_MAX_HEIGHT</span> = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">var</span> containers = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;.js_unfold_code_btn&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>).<span class="title function_">addClass</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收起</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;.js_retract_code_btn&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $container = $(<span class="variable language_">this</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> winTop = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line">    <span class="keyword">var</span> offsetTop = $container.<span class="title function_">offset</span>().<span class="property">top</span>;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&#x27;top&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (winTop &gt; offsetTop) &#123;</span><br><span class="line">        <span class="comment">// 设置滚动条位置</span></span><br><span class="line">        $(<span class="string">&#x27;body, html&#x27;</span>).<span class="title function_">animate</span>(&#123;</span><br><span class="line">            <span class="attr">scrollTop</span>: $container.<span class="title function_">offset</span>().<span class="property">top</span> - <span class="variable constant_">CODE_MAX_HEIGHT</span></span><br><span class="line">        &#125;, <span class="number">600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 滚动事件，触发动画效果</span></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">on</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> scrollTop = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line">    <span class="keyword">var</span> temp = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; containers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> item = containers[i];</span><br><span class="line">        <span class="keyword">var</span> &#123; $container, height, $hide, hasHorizontalScrollbar &#125; = item;</span><br><span class="line">        <span class="keyword">if</span> ($container.<span class="title function_">closest</span>(<span class="string">&#x27;body&#x27;</span>).<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 $container 元素已经不在页面上, 则删除该元素</span></span><br><span class="line">            <span class="comment">// 防止pjax页面跳转之后，元素未删除</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.<span class="title function_">push</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (!$container.<span class="title function_">hasClass</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> offsetTop = $container.<span class="title function_">offset</span>().<span class="property">top</span>;</span><br><span class="line">        <span class="keyword">var</span> hideBtnHeight = $hide.<span class="title function_">outerHeight</span>();</span><br><span class="line">        <span class="comment">// 减去按钮高度，减去底部滚动条高度</span></span><br><span class="line">        <span class="keyword">var</span> maxTop = <span class="built_in">parseInt</span>(height - (hasHorizontalScrollbar ? <span class="number">17</span> : <span class="number">0</span>) - hideBtnHeight);</span><br><span class="line">        <span class="keyword">let</span> top = <span class="built_in">parseInt</span>(</span><br><span class="line">            <span class="title class_">Math</span>.<span class="title function_">min</span>(</span><br><span class="line">                <span class="title class_">Math</span>.<span class="title function_">max</span>(scrollTop - offsetTop, <span class="number">0</span>), <span class="comment">// 如果小于 0 ，则取 0</span></span><br><span class="line">                maxTop,<span class="comment">// 如果大于 height ，则取 height</span></span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 根据 sin 曲线设置&quot;收起代码&quot;位置</span></span><br><span class="line">        <span class="keyword">var</span> halfHeight = <span class="built_in">parseInt</span>($(<span class="variable language_">window</span>).<span class="title function_">height</span>() / <span class="number">2</span> * <span class="title class_">Math</span>.<span class="title function_">sin</span>((top / maxTop) * <span class="number">90</span> * (<span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">360</span>)));</span><br><span class="line">        $hide.<span class="title function_">css</span>(<span class="string">&#x27;top&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(top + halfHeight, maxTop));</span><br><span class="line">    &#125;</span><br><span class="line">    containers = temp;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加隐藏容器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addCodeWrap</span>(<span class="params">$node</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> $container = $node.<span class="title function_">wrap</span>(<span class="string">&#x27;&lt;div class=&quot;js_highlight_container highlight-container&quot;&gt;&lt;div class=&quot;highlight-wrap&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span>).<span class="title function_">closest</span>(<span class="string">&#x27;.js_highlight_container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部 &quot;展开代码&quot; 与 侧边栏 &quot;收起代码&quot;</span></span><br><span class="line">    <span class="keyword">var</span> $btn = $(<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class=&quot;highlight-footer&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;a class=&quot;js_unfold_code_btn show-btn&quot; href=&quot;javascript:;&quot;&gt;展开代码&lt;i class=&quot;fa fa-angle-down&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;a class=&quot;js_retract_code_btn hide-btn&quot; href=&quot;javascript:;&quot;&gt;&lt;i class=&quot;fa fa-angle-up&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;收起代码&lt;/a&gt;</span></span><br><span class="line"><span class="string">  `</span>);</span><br><span class="line"></span><br><span class="line">    $container.<span class="title function_">append</span>($btn);</span><br><span class="line">    <span class="keyword">return</span> $container;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">codeUnfold</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;.highlight&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 防止重复渲染</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">__render__</span> === <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">__render__</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">var</span> $this = $(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">var</span> height = $(<span class="variable language_">this</span>).<span class="title function_">outerHeight</span>();</span><br><span class="line">        <span class="keyword">if</span> (height &gt; <span class="variable constant_">CODE_MAX_HEIGHT</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加展开&amp;收起容器</span></span><br><span class="line">            <span class="keyword">var</span> $container = <span class="title function_">addCodeWrap</span>($this, height);</span><br><span class="line">            containers.<span class="title function_">push</span>(&#123;</span><br><span class="line">                $container,</span><br><span class="line">                height,</span><br><span class="line">                <span class="attr">$hide</span>: $container.<span class="title function_">find</span>(<span class="string">&#x27;.js_retract_code_btn&#x27;</span>),</span><br><span class="line">                <span class="attr">hasHorizontalScrollbar</span>: <span class="variable language_">this</span>.<span class="property">scrollWidth</span> &gt; <span class="variable language_">this</span>.<span class="property">offsetWidth</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 防火墙 UFW 对 Docker 容器端口的策略问题处理</title>
    <url>/2024/Ubuntu%E9%98%B2%E7%81%AB%E5%A2%99UFW%E5%AF%B9Docker%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h1>
<p>UFW（Uncomplicated Firewall）是 Debian 和 Ubuntu 系统自带的一个前端工具，便于用户管理防火墙规则。然而，由于 Docker 和 UFW 在操作 iptables 时采取不同的方式，二者之间存在不兼容的问题。</p>
<p>当 Docker 公开容器端口时，容器的流入和流出流量会在经过 UFW 防火墙规则之前被重定向。具体而言，Docker 使用 <code>nat</code> 表对容器流量进行路由，使得数据包在到达 UFW 监控的 <code>INPUT</code> 链之前就被处理。同样，流出的 <code>OUTPUT</code> 数据包也在 UFW 应用规则之前完成了路由操作，导致 UFW 的防火墙配置被绕过。</p>
<p>现在的目标是让 UFW 生效，同时尽可能少的修改 Docker 网络。</p>
<span id="more"></span>
<h1 id="方案一"><a class="markdownIt-Anchor" href="#方案一"></a> 方案一</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NoYWlmZW5nL3Vmdy1kb2NrZXI/dGFiPXJlYWRtZS1vdi1maWxlI3NvbHZpbmctdWZ3LWFuZC1kb2NrZXItaXNzdWVz">https://github.com/chaifeng/ufw-docker?tab=readme-ov-file#solving-ufw-and-docker-issues<i class="fa fa-external-link-alt"></i></span></p>
<p>该方案的优点是不需要修改 Docker 的网络配置。缺点是无论内网还是外网，想要访问容器暴露的端口，都需要进行一些额外的操作。</p>
<ol>
<li>
<p>在 <code>/etc/ufw/after.rules</code> 末尾添加以下内容：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># BEGIN UFW AND DOCKER</span><br><span class="line">*filter</span><br><span class="line">:ufw-user-forward - [0:0]</span><br><span class="line">:ufw-docker-logging-deny - [0:0]</span><br><span class="line">:DOCKER-USER - [0:0]</span><br><span class="line">-A DOCKER-USER -j ufw-user-forward</span><br><span class="line"></span><br><span class="line"># [1]允许同一网络的容器可以互相访问，但也导致内网可以访问容器暴露的端口，如需更高安全性可注释</span><br><span class="line">-A DOCKER-USER -j RETURN -s 10.0.0.0/8</span><br><span class="line">-A DOCKER-USER -j RETURN -s 172.16.0.0/12</span><br><span class="line">-A DOCKER-USER -j RETURN -s 192.168.0.0/16</span><br><span class="line"></span><br><span class="line"># [2]允许容器进行 DNS 查询</span><br><span class="line">-A DOCKER-USER -p udp -m udp --sport 53 --dport 1024:65535 -j RETURN</span><br><span class="line"></span><br><span class="line"># [3]记录并拒绝所有发往内网 IP 的新 TCP 连接（SYN 包）和 UDP 流量</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 192.168.0.0/16</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 10.0.0.0/8</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -d 172.16.0.0/12</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 192.168.0.0/16</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 10.0.0.0/8</span><br><span class="line">-A DOCKER-USER -j ufw-docker-logging-deny -p udp -m udp --dport 0:32767 -d 172.16.0.0/12</span><br><span class="line"></span><br><span class="line"># [4]默认返回规则</span><br><span class="line">-A DOCKER-USER -j RETURN</span><br><span class="line"></span><br><span class="line"># [5]记录并丢弃非法连接尝试</span><br><span class="line">-A ufw-docker-logging-deny -m limit --limit 3/min --limit-burst 10 -j LOG --log-prefix &quot;[UFW DOCKER BLOCK] &quot;</span><br><span class="line">-A ufw-docker-logging-deny -j DROP</span><br><span class="line"></span><br><span class="line">COMMIT</span><br><span class="line"># END UFW AND DOCKER</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重载配置：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload &amp;&amp; <span class="built_in">sudo</span> ufw reload</span><br><span class="line"><span class="comment"># 如果不生效，执行以下命令</span></span><br><span class="line"><span class="built_in">sudo</span> /usr/lib/ufw/ufw-init flush-all &amp;&amp; <span class="built_in">sudo</span> service ufw restart &amp;&amp; <span class="built_in">sudo</span> service docker restart</span><br></pre></td></tr></table></figure>
</li>
</ol>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>配置后的效果</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<ul>
<li>宿主机可以访问容器内端口。（与新增配置无关）</li>
<li>容器内无法访问宿主机的端口。（与新增配置无关）</li>
<li>同一 Docker 网络内的容器可以互相访问端口（如果注释了 <code>[1]</code> 部分的规则，则此功能将失效，解决方法请参考问题1）。</li>
<li>内网可以访问容器暴露的端口（如果注释了 <code>[1]</code> 部分的规则，则此功能将失效，解决方法请参考问题2）。</li>
<li><strong>外网无法访问容器暴露的端口</strong>。（解决方法请参考问题2）</li>
</ul>
</div>
</details><h2 id="问题及解决方案"><a class="markdownIt-Anchor" href="#问题及解决方案"></a> 问题及解决方案</h2>
<h3 id="1-容器无法访问同一-docker-网络中的其他容器端口"><a class="markdownIt-Anchor" href="#1-容器无法访问同一-docker-网络中的其他容器端口"></a> 1. 容器无法访问同一 Docker 网络中的其他容器端口</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw route allow from 172.18.0.0/16 to 172.18.0.0/16</span><br></pre></td></tr></table></figure>
<p>或者直接在 <code>/etc/ufw/after.rules</code> 的 <code>-A DOCKER-USER -j ufw-user-forward</code> 后面添加一行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-A DOCKER-USER -j ufw-user-forward</span><br><span class="line"></span><br><span class="line">-A DOCKER-USER -s 172.18.0.0/16 -d 172.18.0.0/16 -j RETURN</span><br></pre></td></tr></table></figure>
<h3 id="2-无法访问容器映射的端口"><a class="markdownIt-Anchor" href="#2-无法访问容器映射的端口"></a> 2. 无法访问容器映射的端口</h3>
<p>当使用 <code>-p 8080:80</code> 映射端口时，应允许路由到容器端口 <code>80</code>，而不是主机端口 <code>8080</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw route allow proto tcp from any to &lt;容器ip&gt; port &lt;容器端口&gt;</span><br></pre></td></tr></table></figure>
<p>同时需要确保主机的 <code>8080</code> 端口能够被外部访问：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow proto tcp from any to &lt;主机ip&gt; port &lt;主机端口&gt;</span><br></pre></td></tr></table></figure>
<h1 id="方案二"><a class="markdownIt-Anchor" href="#方案二"></a> 方案二</h1>
<p>虽然该方案需要修改 Docker 的网络配置，但不会有方案一中出现的问题，<strong>推荐使用</strong>。</p>
<ol>
<li>
<p>禁用 Docker 的 iptables 管理：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>添加以下配置：</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;iptables&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 Docker 启动配置：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/default/docker</span><br></pre></td></tr></table></figure>
<p>添加 <code>-iptables=false</code>：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DOCKER_OPTS=&quot;-iptables=false&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 UFW 配置：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/default/ufw</span><br></pre></td></tr></table></figure>
<p>把 <code>DEFAULT_FORWARD_POLICY</code> 改为 <code>ACCEPT</code>：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 UFW 规则：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure>
<p>在 <code>*filter</code> 前面添加下面内容：</p>
 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0]</span><br><span class="line"># 访问外部网络时，将源地址改为主机的 IP 地址，只影响发往 docker0 网卡之外的流量</span><br><span class="line">-A POSTROUTING ! -o docker0 -s 172.17.0.0/16 -j MASQUERADE5COMMIT</span><br><span class="line">-A POSTROUTING ! -o [网卡名] -s [网卡所在网段] -j MASQUERADE5COMMIT</span><br><span class="line">...</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>重启 UFW 和 Docker：</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> /usr/lib/ufw/ufw-init flush-all &amp;&amp; <span class="built_in">sudo</span> service ufw restart &amp;&amp; <span class="built_in">sudo</span> service docker restart</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>UFW</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>VIDEO TDR FAILURE 蓝屏解决过程</title>
    <url>/2024/VIDEO_TDR_FAILURE%E8%93%9D%E5%B1%8F%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>电脑用着用着突然卡住，不一会儿出现蓝屏：</p>
<p><img src="https://img.picgo.net/2024/11/28/Pasted-image-20241128135542260dc1e28fefd6dd.png" alt="Pasted image 20241128135542.png" /></p>
<span id="more"></span>
<h1 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h1>
<p><strong>VIDEO_TDR_FAILURE</strong> 这类蓝屏错误提示通常与显卡驱动程序相关，通过查看终止代码下方发生故障的文件得知，蓝屏错误是由 <code>nvlddmkm.sys</code> 这个文件引起的，其对应的是 <strong>NVIDIA</strong> 显卡。</p>
<h1 id="解决过程"><a class="markdownIt-Anchor" href="#解决过程"></a> 解决过程</h1>
<h2 id="重装驱动"><a class="markdownIt-Anchor" href="#重装驱动"></a> 重装驱动</h2>
<ol>
<li>
<p>以安全模式启动（这一步是为了防止电脑启动后一直因为显卡驱动问题而崩溃），分为两种情况：被动和主动；</p>
<ol>
<li>
<p>被动情况：在蓝屏错误自动重启的过程中，会显示“你的电脑未正确启动”，这时只需点击右下角的高级选项即可，随后转入步骤3</p>
</li>
<li>
<p>主动进入：依次点击 <code>设置-&gt;更新与安全-&gt;恢复</code>，选择 <code>高级启动</code>，点击 <code>立即重新启动</code>：</p>
<p><img src="https://img.picgo.net/2024/11/28/Pasted-image-202411281409570b19f1819a271d7f.png" alt="Pasted image 20241128140957.png" /></p>
</li>
<li>
<p>选择 <code>疑难解答-&gt;高级选项-&gt;启动设置</code>，然后点击重启</p>
</li>
<li>
<p>在重启界面点击“4”或者“F4”，进入安全模式</p>
</li>
</ol>
</li>
<li>
<p>安装 <span class="exturl" data-url="aHR0cHM6Ly93d3cud2FnbmFyZHNvZnQuY29tL2Rpc3BsYXktZHJpdmVyLXVuaW5zdGFsbGVyLWRkdS0=">Display Driver Uninstaller (DDU)<i class="fa fa-external-link-alt"></i></span>。卸载显卡驱动：</p>
<p><img src="https://img.picgo.net/2024/11/28/Pasted-image-202411281358427450e0b8a23dfd14.png" alt="Pasted image 20241128135842.png" /></p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubnZpZGlhLmNuL2dlZm9yY2UvZHJpdmVycy8=">下载 NVIDIA 驱动<i class="fa fa-external-link-alt"></i></span>备用。</p>
</li>
<li>
<p>重启后马上断网，防止系统自动下载安装驱动。接着安装刚刚下载的驱动。</p>
</li>
<li>
<p>使用一段时间后，依旧出现蓝屏。。。</p>
</li>
</ol>
<h2 id="检查硬件"><a class="markdownIt-Anchor" href="#检查硬件"></a> 检查硬件</h2>
<p>拔下 HDMI 线，清扫积灰后重新插上，开机，问题解决。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMjM1ODU2L2FydGljbGUvZGV0YWlscy8xMjkyNzQ4NTM=">记录一次VIDEO_TDR_FAILURE蓝屏解决过程_video tdr failure-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>蓝屏</tag>
      </tags>
  </entry>
  <entry>
    <title>从协议到算法：解读分布式一致性的核心机制</title>
    <url>/2024/%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E7%AE%97%E6%B3%95%EF%BC%9A%E8%A7%A3%E8%AF%BB%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>在现代计算领域，分布式系统已成为众多应用的标准架构，通过将数据和计算任务分散到多个独立节点上，极大地提升了系统的可扩展性和容错能力。然而，随着系统规模的增长和分布特性的增强，如何确保数据一致性成为一项重要而复杂的挑战。事务一致性是数据库系统中维护数据准确性和可靠性的关键因素，但在分布式环境中，由于节点独立性和网络通信的不确定性，实现事务一致性变得尤为困难。</p>
<p>为应对这一挑战，分布式一致性协议和算法应运而生。它们在分布式系统中起着至关重要的作用，旨在保证多个节点在执行某项操作后能够保持一致的状态，从而确保集群中数据的一致性和系统的稳定性。通过这些协议和算法，分布式系统可以在面对网络延迟、节点故障甚至网络分区时，依然实现数据的一致性和高可用性。</p>
<h1 id="两阶段提交协议-2pc"><a class="markdownIt-Anchor" href="#两阶段提交协议-2pc"></a> 两阶段提交协议 (2PC)</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<p>两阶段提交协议（Two-Phase Commit，2PC）是一种用于确保分布式系统中事务一致性的协议。它的基本思想是在提交事务之前，通过协调者（Coordinator）向所有参与者（Participator）确认是否能够提交，然后根据所有参与者的响应决定提交还是回滚事务。2PC通常用于需要强一致性的分布式数据库系统中。</p>
<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2>
<h3 id="投票阶段vote"><a class="markdownIt-Anchor" href="#投票阶段vote"></a> 投票阶段（Vote）</h3>
<ul>
<li>协调者向所有参与者发起投票请求。</li>
<li>参与者执行事务并写入Undo和Redo日志，但不提交。</li>
<li>参与者回应准备就绪（YES）或失败（NO）。</li>
</ul>
<p><img src="https://i.postimg.cc/K88zZ8rG/Pasted-image-20240802100143.png" alt="Pasted image 20240802100143.png" /></p>
<details class="custom-callout question" open><summary class="callout-title"><div class="callout-icon"></div><div>写入Undo和Redo日志与提交的关系</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<ul>
<li><strong>写入Undo和Redo日志</strong>是事务处理过程中重要的步骤，它们用于支持事务的持久性和原子性。但是，<strong>仅仅写入这些日志并不等同于提交事务</strong>。</li>
<li>提交事务的操作除了可能包括写入Undo和Redo日志外，还包括确保这些更改被永久性地写入数据库的存储介质中（如硬盘），并且使这些更改对其他事务可见。</li>
<li>在许多数据库系统中，提交事务的操作还包括一个“提交点”（Commit Point），在这一点上，数据库会确保所有相关的日志条目都已被安全地写入磁盘，并且事务的更改也被持久化。一旦达到提交点，事务就被认为是“已提交”的，其更改成为永久性的。</li>
</ul>
</div>
</details><h3 id="提交阶段commit"><a class="markdownIt-Anchor" href="#提交阶段commit"></a> 提交阶段（Commit）</h3>
<p>协调者根据参与者的响应决定提交或中断事务。</p>
<ul>
<li><strong>提交事务</strong>（所有参与者均反馈YES时）：
<ol>
<li>协调者向所有参与者发送 <code>commit</code> 请求。</li>
<li>参与者提交事务。</li>
<li>参与者释放事务期间占用的资源。</li>
<li>参与者回应 ACK 确认。</li>
<li>协调者收到所有参与者反馈的 ACK 消息后，完成事务提交。</li>
</ol>
</li>
<li><strong>中断事务</strong>（任何一个参与者反馈NO，或者协调者等待所有参与者的反馈超时时）：
<ol>
<li>协调者向所有参与者发送 <code>rollback</code> 请求。</li>
<li>参与者回滚事务。</li>
<li>参与者释放事务期间占用的资源。</li>
<li>参与者回应 ACK 确认。</li>
<li>协调者收到所有参与者反馈的 ACK 消息后，完成事务中断。</li>
</ol>
</li>
</ul>
<p><img src="https://i.postimg.cc/7ZGFMvq1/Pasted-image-20240802100118.png" alt="Pasted image 20240802100118.png" /></p>
<h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2>
<ul>
<li><strong>实现简单</strong>：2PC 的协议流程比较简单，易于实现和理解。目前，绝大多数关系型数据库都采用 2PC 来完成分布式事务处理。</li>
<li><strong>保证一致性</strong>：在<strong>没有网络分区</strong>的情况下，2PC 能够确保数据一致性，即所有参与者要么全部提交，要么全部回滚。</li>
</ul>
<h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2>
<ul>
<li><strong>同步阻塞</strong>：在提交阶段，所有参与者必须等待协调者的最终决策，这可能导致长时间的资源锁定，牺牲了可用性。</li>
<li><strong>单点故障</strong>：协调者的故障会导致参与者一直处于锁定状态，整个事务将无法完成，甚至可能导致数据不一致。</li>
<li><strong>分区敏感</strong>：2PC协议为了保证数据的强一致，实际上选择的是 CAP 理论中的 CA 部分，不能容忍网络分区异常。网络分区会导致参与者无法收到协调者的指令，可能出现只有部分参与者接收并执行了 <code>commit</code> 请求，从而导致节点数据的不一致。</li>
</ul>
<h1 id="三阶段提交协议-3pc"><a class="markdownIt-Anchor" href="#三阶段提交协议-3pc"></a> 三阶段提交协议 (3PC)</h1>
<h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2>
<p>三阶段提交协议（Three-Phase Commit，3PC）是对 2PC 的改进，旨在解决 2PC 中的同步阻塞和单点故障问题。3PC 将 2PC 的 <strong>Vote</strong> 阶段拆分为 <strong>CanCommit</strong> 和 <strong>PreCommit</strong> 阶段，进一步细化了事务的提交过程，从而提高了系统的性能和网络延迟的容忍性。</p>
<h2 id="流程-2"><a class="markdownIt-Anchor" href="#流程-2"></a> 流程</h2>
<h3 id="准备阶段cancommit"><a class="markdownIt-Anchor" href="#准备阶段cancommit"></a> 准备阶段（CanCommit）</h3>
<ul>
<li>协调者向所有参与者发出包含事务内容的 <code>canCommit</code> 请求</li>
<li>参与者回应准备就绪（YES）或失败（NO）。</li>
</ul>
<h3 id="预提交阶段precommit"><a class="markdownIt-Anchor" href="#预提交阶段precommit"></a> 预提交阶段（PreCommit）</h3>
<p>协调者根据参与者的响应决定预提交或中断事务。</p>
<ul>
<li><strong>提交事务</strong>（所有参与者均反馈YES时）：
<ol>
<li>协调者向所有参与者发送 <code>preCommit</code> 请求。</li>
<li>参与者执行事务并写入Undo和Redo日志，但不提交。</li>
<li>参与者回应 ACK 或 NO。</li>
</ol>
</li>
<li><strong>中断事务</strong>（任何一个参与者反馈NO，或者协调者等待所有参与者的反馈超时时）：
<ol>
<li>协调者向所有参与者发送 <code>abort</code> 请求。</li>
<li>参与者中断事务。</li>
</ol>
</li>
</ul>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>Note</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>在等待协调者请求过程中出现<strong>超时</strong>，参与者会<strong>中断事务</strong>。</p>
</div>
</details><p><img src="https://i.postimg.cc/VNsjPw5n/Pasted-image-20240802110926.png" alt="Pasted image 20240802110926.png" /></p>
<h3 id="提交阶段docommit"><a class="markdownIt-Anchor" href="#提交阶段docommit"></a> 提交阶段（DoCommit）</h3>
<p>协调者根据参与者的响应决定提交或中断事务。</p>
<ul>
<li><strong>提交事务</strong>（所有参与者均反馈 ACK 时）：
<ol>
<li>协调者向所有参与者发送 <code>doCommit</code> 请求。</li>
<li>参与者提交事务。</li>
<li>参与者释放事务期间占用的资源。</li>
<li>参与者回应 ACK 确认。</li>
<li>协调者收到所有参与者反馈的 ACK 消息后，完成事务提交。</li>
</ol>
</li>
<li><strong>中断事务</strong>（任何一个参与者反馈NO，或者协调者等待所有参与者的反馈超时时）：
<ol>
<li>协调者向所有参与者发送 <code>abort</code> 请求。</li>
<li>参与者回滚事务。</li>
<li>参与者释放事务期间占用的资源。</li>
<li>参与者回应 ACK 确认。</li>
<li>协调者收到所有参与者反馈的 ACK 消息后，完成事务中断。</li>
</ol>
</li>
</ul>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>Note</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>在等待协调者请求过程中出现超时，参与者会直接<strong>提交事务</strong>。</p>
</div>
</details><p><img src="https://i.postimg.cc/85tXgw1P/Pasted-image-20240802111014.png" alt="Pasted image 20240802111014.png" /></p>
<h2 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h2>
<ul>
<li><strong>减少同步阻塞</strong>：3PC 协议在 CanCommit 不占用资源，只进行校验，减少了不必要的资源浪费。</li>
<li><strong>降低单点故障影响</strong>：在 PreCommit 阶段，参与者在等待协调者请求超时时会<strong>中断事务</strong>；在 DoCommit 阶段，参与者在等待协调者请求超时时将<strong>继续提交事务</strong>。</li>
</ul>
<h2 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h2>
<ul>
<li><strong>实现复杂</strong>：相比于2PC，3PC的实现更加复杂，需要处理更多的状态和消息。</li>
<li><strong>数据不一致问题依然存在</strong>：DoCommit 阶段中，如果协调者请求中断事务，但因故障或网络分区无法同部分参与者正常通信，这部分参与者会继续提交事务，从而导致节点数据的不一致。</li>
</ul>
<h1 id="paxos"><a class="markdownIt-Anchor" href="#paxos"></a> Paxos</h1>
<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2>
<p>无论是 2PC 或 3PC，均无法彻底解决分布式的一致性问题。</p>
<details class="custom-callout quote" open><summary class="callout-title"><div class="callout-icon"></div><div>Quote</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>There is only one consensus protocol, and that’s “Paxos” — all other approaches are just broken versions of Paxos</p>
<p>世界上只有一种共识协议，就是 Paxos，其他所有共识算法都是 Paxos 的退化版本。</p>
<p>—— <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWljaGFlbF9CdXJyb3dz">Mike Burrows<i class="fa fa-external-link-alt"></i></span>，Inventor of Google Chubby</p>
</div>
</details><p>Paxos 算法是一个解决分布式系统中一致性问题的一种<strong>共识算法</strong>（Consensus Algorithm），由莱斯利·兰伯特（Leslie Lamport）于1990年提出。在 Paxos 算法中，每次运行以达成一致选择<strong>一个值</strong>的过程称为一个实例（instance）。Paxos 是少数在工程实践中被证实的强一致性、高可用、去中心的分布式协议。</p>
<details class="custom-callout question" open><summary class="callout-title"><div class="callout-icon"></div><div>什么是共识算法</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>所谓共识，就是达成一致性的方法与过程。共识算法能够让分布式系统内部暂时容忍存在不同的状态，但最终能够保证大多数节点的状态达成一致；同时，能够让分布式系统在外部看来始终表现出整体一致的结果。这个让系统各节点不受局部的网络分区、宕机、执行性能或者其他因素影响，都能最终表现出整体一致的过程，就被称为各个节点的<strong>协商共识</strong>（Consensus）。</p>
<p>共识算法建立在<strong>状态机复制</strong>（State Machine Replication）模型的基础上。状态机复制模型的核心在于状态机的一个关键特性：<em>当所有状态机起始于相同状态，并接收并执行完全相同的命令序列时，它们最终会达到相同的状态</em>。这一特性被巧妙地应用于多参与者系统的共识机制中，意味着系统中的每个参与者（即状态机实例）需从相同的基础状态出发，遵循完全一致的指令序列进行状态更新。</p>
<p>根据状态机的特性，要让多台机器的最终状态一致，只要确保它们的初始状态是一致的，并且接收到的操作指令序列也是一致的即可，无论这个操作指令是新增、修改、删除抑或是其他任何可能的程序行为，都可以理解为要将一连串的操作日志正确地广播给各个分布式节点。广播指令与指令执行期间，<strong>允许系统内部状态存在不一致</strong>的情况，即并不要求所有节点的每一条指令都是同时开始、同步完成的，<strong>只要求在此期间的内部状态不能被外部观察到，且当操作指令序列执行完毕时，所有节点的最终的状态是一致的</strong>，这种模型就被称为状态机复制。</p>
</div>
</details><p>Paxos 协议用于在多个副本之间在有限时间内对某个决议达成共识。Paxos 协议运行在允许消息重复、丢失、延迟或乱序，但没有<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl6YW50aW5lX2ZhdWx0">拜占庭错误<i class="fa fa-external-link-alt"></i></span>的网络环境中，它利用“多数派 （Majority）”机制保证了 <code>2F+1</code> 的容错能力，即 <code>2F+1</code> 个节点的系统最多允许 <code>F</code> 个节点同时出现故障。</p>
<blockquote>
<p>在本小节中 Paxos 均特指最早的 Basic-Paxos 算法。</p>
</blockquote>
<h2 id="概念-3"><a class="markdownIt-Anchor" href="#概念-3"></a> 概念</h2>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<ul>
<li><strong>提案（Proposal）</strong>：提案包括提案编号和提案值。</li>
<li><strong>提议者（Proposer）</strong>：提出提案的角色。Proposer 生成提案编号，并向 Acceptor 发送提案请求。Paxos 是一种合作协议，类似于无锁无等待算法。<em>Proposer 的职责并非确保其提案值被选中，而是辅助推进流程</em>。</li>
<li><strong>接受者（Acceptor）</strong>：接受提案的角色。Acceptor 会根据提案编号决定是否接受提案。</li>
<li><strong>学习者（Learner）</strong>：不参与提案，也不参与决策，只了解已经达成共识的提案的角色。Learner 通过观察多数派 Acceptor 的接受情况来<strong>确定提案值是否被最终批准（chosen）</strong>。</li>
<li><strong>约束</strong>：在一次 Paxos 算法的执行实例中，<strong>只批准一个提案值</strong>（只要提案值是一样的，批准多个提案不会违背约束）。</li>
</ul>
<p>使用 Paxos 算法的分布式系统里的，所有的节点都是平等的，它们都可以承担以上某一种或者多种的角色，不过为了便于确保有明确的多数派，Acceptor 的数量应该被设定为<strong>奇数</strong>个，且在系统初始化时，网络中每个节点都知道整个网络所有 Acceptor 的数量、地址等信息。</p>
<h3 id="基础逻辑"><a class="markdownIt-Anchor" href="#基础逻辑"></a> 基础逻辑</h3>
<p>Paxos 算法分为两个主要阶段：<strong>准备阶段</strong>（Prepare Phase）和<strong>接受阶段</strong>（Accept Phase）。</p>
<h4 id="准备阶段prepare-phase"><a class="markdownIt-Anchor" href="#准备阶段prepare-phase"></a> 准备阶段（Prepare Phase）</h4>
<ul>
<li><strong>Proposer 生成提案编号</strong>：
<ul>
<li>Proposer 生成一个<strong>全局唯一且递增</strong>的提案编号 <code>n</code>。</li>
</ul>
</li>
<li><strong>发送 Prepare 请求</strong>：
<ul>
<li>Proposer 向集群中的 Acceptor 广播发送 <code>Prepare</code> 请求，该请求包含<strong>提案编号 <code>n</code></strong>。</li>
</ul>
</li>
<li><strong>Acceptor 响应 Prepare 请求</strong>：
<ul>
<li>收到后 Prepare 请求后，Acceptor 将会给予 Proposer 两个承诺与一个应答：
<ul>
<li>两个承诺是指：
<ol>
<li>承诺不会再接受提案编号<strong>小于等于 n</strong> 的 Prepare 请求。</li>
<li>承诺不会再接受提案编号<strong>小于 n</strong> 的 Accept 请求。</li>
</ol>
</li>
<li>一个应答是指：
<ul>
<li>向 Proposer 发送响应数据 <code>Promise</code>，包含提案编号 <code>n</code> 和<strong>其之前接受（Accepted）的最大编号的提案值</strong>（如果有的话）。</li>
</ul>
</li>
</ul>
</li>
<li>如果与承诺相悖，即收到的提案编号小于等于之前收到的提案编号，Acceptor 会忽略该请求。</li>
</ul>
</li>
</ul>
<p><img src="https://i.postimg.cc/k5NhfqzS/Pasted-image-20240802142340.png" alt="Pasted image 20240802142340.png" /></p>
<details class="custom-callout note"><summary class="callout-title"><div class="callout-icon"></div><div>关于提案编号</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>在 Paxos 算法中，提案编号并非由算法自身生成，而是由外部指定并传入。根据不同的应用场景和业务需求，我们可以自定义提案编号的生成规则，只需确保提案编号是递增的数值即可。具体实现方式如下：</p>
<ul>
<li>在单一 Proposer 的场景下，可采用自增ID或时间戳作为提案编号。</li>
<li>在两个 Proposer 的场景中，可以分别采用奇数（如1、3、5、7…）和偶数（如2、4、6、8…）作为提案编号。</li>
<li>在多 Proposer 的环境中，可以为每个节点分配一个唯一的 <strong>ServerId</strong>（例如1、2、3、4…），然后采用自增序号与 ServerId 的组合（如 <code>自增序号 ‘.’ ServerId</code>）或时间戳与ServerId的组合（如 <code>timestamp ‘.’ ServerId</code>）作为提案编号，例如：1.1、1.2、2.3、3.1、3.2或1693702932000.1、1693702932000.2、1693702932000.3。</li>
<li>当 Proposer 在发起 <code>Prepare</code> 请求后未获得超过半数的响应时，需要更新自己的提案编号，并重新发起一轮 Prepare 请求。</li>
</ul>
</div>
</details><h4 id="接受阶段accept-phase"><a class="markdownIt-Anchor" href="#接受阶段accept-phase"></a> 接受阶段（Accept Phase）</h4>
<h5 id="proposer-发送-accept-请求"><a class="markdownIt-Anchor" href="#proposer-发送-accept-请求"></a> Proposer 发送 Accept 请求</h5>
<p>如果 Proposer 从超过半数的 Acceptor 处收到 <code>Prepare</code> 请求的响应，它将向集群中的 Acceptor 广播发送 <code>Accept</code> 请求，该请求包含提案编号 <code>n</code> 和提案值 <code>v</code>。</p>
<details class="custom-callout question" open><summary class="callout-title"><div class="callout-icon"></div><div>Accept 请求的提案值是什么</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<ul>
<li>如果 Proposer 接收到的 <code>Promise</code> 响应中包含 Acceptor 之前已接收的提案，则选择<strong>最大提案编号对应的提案值</strong>作为当前 <code>Accept</code> 请求的提案值，这种设计的目的是为了能够更快的达成共识。</li>
<li>如果所有 <code>Promise</code> 响应的提案值均为空，则 Proposer 可以自行决定一个提案值。</li>
</ul>
</div>
</details><h5 id="acceptor-处理-accept-请求"><a class="markdownIt-Anchor" href="#acceptor-处理-accept-请求"></a> Acceptor 处理 Accept 请求</h5>
<ul>
<li>如果 Acceptor 收到的 <code>Accept</code> 请求的编号 <code>n</code> <strong>等于其承诺的提案编号</strong>，则 Acceptor 接受该提案并<strong>持久化提案编号和提案值</strong>。</li>
<li>如果与承诺相悖，Acceptor 会忽略该请求。</li>
<li>Acceptor 接受提案后发送包含提案编号和提案值的 <code>Accepted</code> 消息给 <strong>Proposer</strong> 和 <strong>Learner</strong>。</li>
</ul>
<h5 id="最终值的选择"><a class="markdownIt-Anchor" href="#最终值的选择"></a> 最终值的选择</h5>
<p>每当 Acceptor 接受一个新的提案时，都会将提案值发送给 Learner。Learner 统计所有 Acceptor 的提案值，如果某个提案值被超过半数的 Acceptor 接受，则<strong>批准</strong>该提案，并将该值同步给集群中的所有需要了解最终决策的 Proposer 和 Acceptor，之后结束当前提案过程。</p>
<p>在实际业务场景中，Learner 可能由多个节点组成，每个 Learner 都需要“学习”到最新的投票结果。关于 Learner 的实现，Lamport 在其论文中给出了下面两种实现方式：</p>
<ol>
<li>选择一个 Learner 作为主节点用于接收提案值，其他 Learner 节点作为备份节点。主节点接收到数据后再同步给其他 Learner 节点。该方案的缺点是存在单点故障风险，如果主节点宕机，则无法获取到投票结果。</li>
<li>Acceptor 接受提案后，将提案值广播给所有 Learner，每个 Learner 再将提案值广播给其他 Learner 节点。这样可以避免单点故障问题，但缺点是涉及多次消息传递，效率要低于上一种方案。</li>
</ol>
<h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h4>
<ul>
<li>
<p><em>Acceptor 未接受过提案的时序图：</em></p>
<p><img src="https://i.postimg.cc/FR9C6wXB/Pasted-image-20240802143717.png" alt="Pasted image 20240802143717.png" /></p>
</li>
<li>
<p><em>Acceptor 接受过提案后的时序图：</em></p>
<p><img src="https://i.postimg.cc/1Rv2kRtc/Pasted-image-20240802144457.png" alt="Pasted image 20240802144457.png" /></p>
<details class="custom-callout info" open><summary class="callout-title"><div class="callout-icon"></div><div>Info</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>&gt; Acceptor1 和 Acceptor2 已经接受过提案，它们的 <code>Promise</code> 响应中包含了之前的提案 <code>(1, ‘apple’)</code> 和 <code>(2, ‘banana’)</code>，Proposer 选择之前最大提案编号的提案值作为 <code>Accept</code> 请求的提案值，即 <code>banana</code>。</p>
</div>
</details></li>
</ul>
<h2 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点</h2>
<ul>
<li><strong>强一致性</strong>：Paxos 保证了在分布式系统中，即使部分节点发生故障，也能达成一致的决策。这种强一致性对于需要严格保证数据正确性的系统至关重要。</li>
<li><strong>容错性强</strong>：Paxos 能够在多数节点正常工作的情况下继续运行。它允许少数节点出现故障而不影响系统的整体功能。</li>
<li><strong>避免脑裂</strong>：Paxos 的核心在于“多数派”原则，即一个提案要在集群中被批准，必须得到超过半数的节点同意。这意味着即使集群被分割成多个部分，也只能有一个部分能够形成多数派，而其他部分由于节点数量不足，无法独立达成共识。</li>
</ul>
<h2 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h2>
<p>Paxos 的价值在于开拓了分布式共识算法的发展思路，但它因有如下缺陷，一般不会直接用于实践：</p>
<ul>
<li><strong>实现复杂</strong>：Paxos 的实现较为复杂，涉及多个阶段和细节处理，特别是在处理失败和超时方面，并且只能对单个值形成决议。</li>
<li><strong>性能较低</strong>：决议的形成至少需要两次网络请求和应答（Prepare 和 Accept 阶段各一次），高并发情况下将产生较大的网络开销。</li>
<li><strong>活锁问题</strong>：在某些情况下，Proposer 之间可能会频繁地互相打断彼此的提案，导致没有提案能够成功提交。</li>
</ul>
<p>总之，Paxos 是一种很学术化但对工业化并不友好的算法，现在几乎只用来做理论研究。实际的应用都是基于 Multi Paxos 和 Fast Paxos 算法的。</p>
<details class="custom-callout question"><summary class="callout-title"><div class="callout-icon"></div><div>什么是活锁</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>活锁是指系统虽然没有陷入死锁，但由于各个进程频繁地相互干扰，导致没有进程能够取得进展的情况。<br />
在 Paxos 中，活锁通常发生在多个 Proposer 同时提出提案，导致提案不断地被否决和重试，但始终无法达成一致。</p>
<p><img src="https://i.postimg.cc/J4tvMwHw/Pasted-image-20240802151232.png" alt="Pasted image 20240802151232.png" /></p>
</div>
</details><details class="custom-callout question" open><summary class="callout-title"><div class="callout-icon"></div><div>活锁如何解决</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>活锁有可能自行解开，但该过程的持续时间可长可短并不确定，这与具体的业务场景实现逻辑、网络状况、提案重新发起时间间隔等多方面因素有关。<br />
解决活锁问题，有以下常见的方法：</p>
<ol>
<li>当 Proposer 接收到响应，发现支持它的 Acceptor 小于半数时，不立即更新编号发起重试，而是随机延迟一小段时间，来错开彼此的冲突。</li>
<li>可以设置一个 Proposer 的 Leader，集群全部由它来进行提案，等同于下文的 Multi-Paxos 算法。</li>
</ol>
</div>
</details><h2 id="multi-paxos"><a class="markdownIt-Anchor" href="#multi-paxos"></a> Multi-Paxos</h2>
<p>前文介绍了 Paxos 算法的基本流程，但存在两个主要问题：</p>
<ol>
<li>集群内所有 Proposer 都可以发起提案，可能导致活锁问题；</li>
<li>每次发起提案都需要经过反复的 <code>Prepare</code> 和 <code>Accept</code> 流程，涉及多次网络交互，影响程序的执行效率。</li>
</ol>
<p>考虑到以上两个问题，能不能在保障分布式一致性的前提下避免活锁情况的发生，以及尽可能减少达成共识过程中的网络交互，基于这种目的随即产生了 Multi-Paxos 算法。</p>
<p>理想的共识达成过程应是这样的：在多个 Proposer 的环境中，一个 Proposer 广播一次 <code>Prepare</code> 请求并获得多数响应，随后广播一次 <code>Accept</code> 请求，一旦获得多数同意，共识即告达成。然而，现实情况中，多个 Proposer 可能同时发送消息，导致冲突，且在网络不稳定时，消息可能延迟或丢失，迫使重新发起提案，降低效率。Multi-Paxos 算法旨在解决这些问题。</p>
<p>Multi-Paxos 算法在保持集群节点平等的同时，引入了主次节点的概念，以减少不必要的网络交互。该算法通过选举出一个主 Proposer 节点来避免上述问题。集群中的 Proposer 节点通过定期发送心跳包来监控主节点的存在。一旦检测到主节点失活，Proposer 节点会向Acceptor 节点发送申请，表明其希望成为新的主节点。当获得多数节点的同意后，该Proposer 便成为主节点。</p>
<p>在主节点存在的情况下，<strong>集群中的提案仅由主节点提出</strong>，其他 Proposer 不再提案，从而避免了活锁问题。由于只有一个节点负责提案，消除了冲突的可能性，因此无需发送 <code>Prepare</code> 请求，<strong>只需发送 <code>Accept</code> 请求</strong>，显著减少了网络协商的次数。</p>
<h3 id="相关应用"><a class="markdownIt-Anchor" href="#相关应用"></a> 相关应用</h3>
<p>Chubby 和 Boxwood 均使用 Multi-Paxos。</p>
<p>Zookeeper 使用的 ZAB（Zookeeper Atomic Broadcast）也是 Multi-Paxos 的变体。</p>
<h2 id="应用场景示例"><a class="markdownIt-Anchor" href="#应用场景示例"></a> 应用场景示例</h2>
<h3 id="场景描述"><a class="markdownIt-Anchor" href="#场景描述"></a> 场景描述</h3>
<p>在一个分布式数据库中，假设包含3个节点。客户端访问时通过负载均衡请求到某个节点，并通过 Paxos 算法保证分布式数据库3个节点中的数据一致性。为了方便阐述，我们对实际分布式数据一致性的流程进行了简化。</p>
<p><img src="https://i.postimg.cc/B6gkQ4C3/Pasted-image-20240805090659.jpg" alt="Pasted image 20240805090659.jpg" /></p>
<p>分布式数据库中的每个节点都存储三类数据：事务日志数据、数据库数据（DB数据）、事务日志执行位置。</p>
<ul>
<li><strong>事务日志表</strong>：存储数据库的操作日志记录，包括写入 <code>Put</code>、修改 <code>Update</code> 和删除 <code>Delete</code> 等操作日志。事务日志表可以被看做是状态机的命令序列。</li>
<li><strong>DB数据表</strong>：存储具体的业务数据。</li>
<li><strong>事务日志执行位置</strong>：记录当前节点执行到哪一条操作记录。</li>
</ul>
<p><img src="https://i.postimg.cc/6qpS8gHv/Pasted-image-20240805090852.jpg" alt="Pasted image 20240805090852.jpg" /></p>
<details class="custom-callout note"><summary class="callout-title"><div class="callout-icon"></div><div>快照</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>随着数据不断写入，事务日志表的数据量不断增加。可以通过<strong>快照</strong>方式，将某个时间点之前的数据备份到磁盘。这样，宕机恢复时直接从快照点开始恢复，可以提高恢复效率。</p>
</div>
</details><h3 id="整体设计思想"><a class="markdownIt-Anchor" href="#整体设计思想"></a> 整体设计思想</h3>
<p>为了保证所有节点执行相同的事务日志，我们采用了 Paxos 共识算法的一系列单独实例，<strong>实例 i 确定的值是事务日志中的第 i 个操作</strong>。每个节点在算法的每个实例中扮演所有角色（Proposer、Acceptor 和 Learner）。</p>
<details class="custom-callout caution" open><summary class="callout-title"><div class="callout-icon"></div><div>注意</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>Paxos 中的提案编号与事务日志索引没有直接关系，每个 Paxos 实例与特定的事务日志索引相关联；而提案编号的作用是作为共识达成过程中的一个重要机制，确保即使在多个提议者存在的情况下，所有节点也能对同一索引的操作达成一致。</p>
</div>
</details><h3 id="初始状态"><a class="markdownIt-Anchor" href="#初始状态"></a> 初始状态</h3>
<ul>
<li>系统启动后，所有节点的事务日志表和数据表均为空，且 <code>OperateIndex</code> 设置为0。</li>
<li>客户端 C1、C2 <strong>有序</strong>向系统发起写请求：C1 请求 <code>Put(a,'1')</code>，C2 请求 <code>Put(b,'1')</code>。</li>
</ul>
<h3 id="流程说明"><a class="markdownIt-Anchor" href="#流程说明"></a> 流程说明</h3>
<ol>
<li>
<p><strong>请求接收</strong>：</p>
<ul>
<li>Server1 接收 C1 的 <code>Put(a,'1')</code> 请求，并不直接写入数据表，而是启动 Paxos 实例1以达成共识。</li>
</ul>
</li>
<li>
<p><strong>Prepare 请求</strong>：</p>
<ul>
<li>Server1 作为 Proposer，对所有节点（包括自己）发起 <code>Prepare(n)</code> 请求，其中n是提案编号。</li>
</ul>
</li>
<li>
<p><strong>Promise 响应</strong>：</p>
<ul>
<li>Server1 收到过半节点的 <code>Promise</code> 响应后，发出 <code>Accept(n, '&#123;&quot;Op1&quot;: &quot;Put(a,'1')&quot;&#125;')</code> 请求。此时三个节点达成共识，实例1结束，事务日志表均为：<code>&#123;&quot;Op1&quot;: &quot;Put(a,'1')&quot;&#125;</code>。</li>
</ul>
</li>
<li>
<p><strong>写入操作</strong>：</p>
<ul>
<li>达成共识后，Server1 执行写入操作，此时 Server1 的 <code>OperateIndex</code> 为1，其他节点仍为0。Server1 的数据表为：<code>a = 1</code>，另外两个节点的数据表为空，三个节点的事务日志表相同，当前写入流程结束。</li>
</ul>
</li>
</ol>
<p><img src="https://i.postimg.cc/1X7dwBTY/Pasted-image-20240805091108.png" alt="Pasted image 20240805091108.png" /></p>
<h3 id="继续处理后续请求"><a class="markdownIt-Anchor" href="#继续处理后续请求"></a> 继续处理后续请求</h3>
<p>Paxos 实例1完成后，Server2 继续处理 C2 的请求。</p>
<ol>
<li>
<p><strong>检查事务日志表</strong>：</p>
<ul>
<li>Server2 检查事务日志表和 <code>OperateIndex</code>，按顺序执行遗漏的操作。</li>
</ul>
</li>
<li>
<p><strong>Prepare 请求</strong>：</p>
<ul>
<li>Server2 的 <code>OperateIndex</code> 更新后，开始 Paxos 实例2，发起 <code>Prepare(n)</code> 请求。</li>
</ul>
</li>
<li>
<p><strong>Promise 响应</strong>：</p>
<ul>
<li>接收到过半数的 <code>Promise</code> 响应后，Server2 发送 <code>Accept(n, '&#123;&quot;Op1&quot;: &quot;Put(b,'2')&quot;&#125;')</code> 请求，并得到 <code>Accepted</code> 响应。此时三个节点达成共识，实例2结束，事务日志表均更新为：<code>&#123;&quot;Op1&quot;: &quot;Put(a,'1')&quot;, &quot;Op2&quot;: &quot;Put(b,'1')&quot;&#125;</code>。</li>
</ul>
</li>
<li>
<p><strong>执行写入</strong>：</p>
<ul>
<li>达成共识后，Server2 执行写入操作，此时 Server2 的 <code>OperateIndex</code> 为2，其他节点仍为1。Server2 的数据表为：<code>a = 1, b = 1</code>，其他节点的数据表仍为空，三个节点的事务日志表相同，当前写入流程结束。</li>
</ul>
</li>
</ol>
<h3 id="读操作示例"><a class="markdownIt-Anchor" href="#读操作示例"></a> 读操作示例</h3>
<p>当 Server3 接收到 <code>Get(a)</code> 请求时：</p>
<ol>
<li>
<p><strong>检查操作记录</strong>：</p>
<ul>
<li>Server3 比对 <code>OperateIndex</code> 与事务日志表，执行遗漏操作以确保数据一致性。</li>
</ul>
</li>
<li>
<p><strong>执行读取</strong>：</p>
<ul>
<li>由于 <code>Get</code> 请求不涉及写入和修改数据，理论上不需要发起 Paxos 协商。</li>
</ul>
</li>
</ol>
<p>执行流程示意图如下：</p>
<p><img src="https://i.postimg.cc/xdV4vcxY/Pasted-image-20240805092807.png" alt="Pasted image 20240805092807.png" /></p>
<h3 id="提案的体现"><a class="markdownIt-Anchor" href="#提案的体现"></a> 提案的体现</h3>
<p>在决定日志单个索引的值的过程中，可以有多个提案。</p>
<p>假设在 Paxos 实例1未完成时，即 C1 的请求还未写入事务日志前，客户端 C3 向 Server3 发起一个写请求，那么该请求也会参与到 Paxos 实例1中。</p>
<p>Server3 发送 <code>Prepare(nh)</code> 请求，其中 <code>nh &gt; n</code>。得到多数响应，Acceptor <strong>承诺不在接受提案编号小于 nh 的提案</strong>。</p>
<ul>
<li>如果 Server1 还未发送 <code>Accept</code> 请求，那么当它尝试发送时，会因为提案编号小于 nh 而被多数节点拒绝。</li>
<li>如果 Server1 已经发送了 <code>Accept</code> 请求，并且从至少一个 Acceptor 那里得到了 <code>Accepted</code> 响应，但在 Server3 发送 <code>Prepare(nh)</code> 请求之前还未完成 Accept 阶段；Server3 在 Prepare 阶段会发现至少有一个 Acceptor 已经接受了 Server1 的提案。在这种情况下，Server3 为了遵守 Paxos 算法规则，在 Accept 阶段必须发送 <code>Accept(nh, 'Put(a,'1')')</code> 请求，即<strong>采用与 Server1 相同的提案值</strong>。</li>
</ul>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p>Paxos 算法虽然概念简单，但在实际实现中由于需要处理各种故障情况，其复杂性较高。Paxos 的变种，如 Multi-Paxos 和 Raft，针对不同应用场景进行了优化和改进，广泛应用于现代分布式系统中。</p>
<h1 id="raft"><a class="markdownIt-Anchor" href="#raft"></a> Raft</h1>
<h2 id="介绍-2"><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h2>
<p>鉴于 Paxos 算法因其高度复杂性及实现难度，显著限制了其在实际应用中的广泛推广，而分布式系统领域又亟需一种高效而易于实现的分布式一致性算法，在此背景下，Raft 算法应运而生。</p>
<p>Raft是一种<strong>共识算法</strong>。与 Paxos 不同，Raft 强调的是<strong>易懂性</strong>（Understandability）。为了达成这个目标，Raft 主要做了两方面的事情：</p>
<ol>
<li>运用了分而治之的策略，将复杂的算法逻辑解构为三个清晰独立的子问题：<strong>领导者选举</strong>（Leader Election）、<strong>日志复制</strong>（Log Replication）以及<strong>安全性</strong>（Safety）；</li>
<li>对算法做出一些限制，减少状态数量和可能产生的变动。</li>
</ol>
<p>Raft 不是拜占庭容错（BFT）算法，节点信任当选的领导者。</p>
<p>Raft 还引入了联合共识（Joint Consensus）这一新机制，允许线上进行动态的集群扩容，利用有交集的大多数机制来保证安全性。</p>
<h2 id="概念-4"><a class="markdownIt-Anchor" href="#概念-4"></a> 概念</h2>
<p>先介绍两个非常优秀的网站：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hY2VoaS5naXRodWIuaW8vdGhlc2VjcmV0bGl2ZXNvZmRhdGEtY24vcmFmdC8=">The Secret Lives of Data-CN<i class="fa fa-external-link-alt"></i></span> 以图文方式介绍 Raft 算法，是非常好的入门材料。将其阅读完后您大概率已经了解了 Raft 算法，如果您仍有疑问可以回来继续阅读本文。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yYWZ0LmdpdGh1Yi5pby9yYWZ0c2NvcGUvaW5kZXguaHRtbA==">Raft Scope<i class="fa fa-external-link-alt"></i></span> 是 Raft 官方提供的互动式演示程序，它展示了 Raft 集群的工作状态。您可以用它模拟节点宕机、心跳超时等各种情况。有了 Raft Scope 我们可以亲自“动手”观察 Raft 集群是如何工作、如何处理各种故障的。</li>
</ol>
<h3 id="核心概念-2"><a class="markdownIt-Anchor" href="#核心概念-2"></a> 核心概念</h3>
<p>Raft 算法通过选举出的领导者来在集群内达成共识。在 Raft 集群中，每个节点的角色明确分为领导者（Leader）、追随者（Follower），以及在特定选举情境下（当 Leader 不可用时）可能成为的候选者（Candidate）。Leader 的核心职责是<strong>将日志条目（log entry）复制给所有 Follower</strong>，以确保数据一致性。为实现这一点，Leader <strong>定期向 Follower 发送心跳消息</strong>，以此宣示其存在和活动状态。</p>
<p>Raft 集群有且只有一位当选的 Leader，该 Leader 完全负责管理集群其他节点上的日志复制。这意味着 Leader 可以决定新条目的放置位置以及它与其他节点之间数据流的建立，而无需与其他节点协商。Leader 会一直在任，直到发生故障或断开连接，在这种情况下，幸存的节点会选出新的领导者。</p>
<p>每个 Follower 内部维护一个<strong>选举超时</strong>计时器，其时长<strong>随机</strong>设定在150~300毫秒之间，用于等待来自 Leader 的心跳信号。一旦接收到有效的心跳消息，该计时器会被重置。若超时时间内未接收到心跳，则 Follower 会认为当前 Leader 可能已失效或网络分区发生，随后自动转变为 Candidate 状态，并启动新一轮的<strong>领导者选举</strong>过程，以恢复集群的正常运作和共识机制。</p>
<h3 id="节点之间通信方式"><a class="markdownIt-Anchor" href="#节点之间通信方式"></a> 节点之间通信方式</h3>
<p>Raft 集群节点之间通过 RPC 交互，只需要两种 RPC 消息：<code>RequestVote</code> 和 <code>AppendEntries</code>。另外，RPC 都是<strong>幂等</strong>的，发起 RPC 是<strong>并行</strong>的。</p>
<h4 id="requestvote-rpc"><a class="markdownIt-Anchor" href="#requestvote-rpc"></a> RequestVote RPC</h4>
<p>用于领导者选举。Candidate 会向其他节点发送 <code>RequestVote</code> 请求，征求选票。</p>
<p><strong>请求体</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>           <span class="comment">// Candidate 的任期号</span></span><br><span class="line">  <span class="attr">&quot;candidateId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span>  <span class="comment">// Candidate 的ID</span></span><br><span class="line">  <span class="attr">&quot;lastLogIndex&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>  <span class="comment">// Candidate 最后日志条目的索引值</span></span><br><span class="line">  <span class="attr">&quot;lastLogTerm&quot;</span><span class="punctuation">:</span> <span class="number">4</span>     <span class="comment">// Candidate 最后日志条目的任期号</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>响应体</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>           <span class="comment">// 当前节点的任期号</span></span><br><span class="line">  <span class="attr">&quot;voteGranted&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span>  <span class="comment">// 当前节点是否投票给 Candidate</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="appendentries-rpc"><a class="markdownIt-Anchor" href="#appendentries-rpc"></a> AppendEntries RPC</h4>
<p>用于日志复制和心跳检查。Leader 通过发送 <code>AppendEntries</code> 消息向 Follower 复制日志条目，同时也可以作为心跳消息，防止 Follower 超时。</p>
<p><strong>请求体</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>               <span class="comment">// Leader 的任期号</span></span><br><span class="line">  <span class="attr">&quot;leaderId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;A&quot;</span><span class="punctuation">,</span>         <span class="comment">// Leader 的ID</span></span><br><span class="line">  <span class="attr">&quot;prevLogIndex&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>      <span class="comment">// 紧邻新日志条目之前的那个日志条目的索引值</span></span><br><span class="line">  <span class="attr">&quot;prevLogTerm&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span>        <span class="comment">// 紧邻新日志条目之前的那个日志条目的任期号</span></span><br><span class="line">  <span class="attr">&quot;entries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>             <span class="comment">// 需要存储的日志条目（可以为空，用于心跳）</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set x=10&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set y=20&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;leaderCommit&quot;</span><span class="punctuation">:</span> <span class="number">8</span>        <span class="comment">// Leader 已经提交的日志的索引值</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>响应体</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span>               <span class="comment">// 当前节点的任期号</span></span><br><span class="line">  <span class="attr">&quot;success&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>         <span class="comment">// 如果 Follower 包含了匹配上 prevLogIndex 和 prevLogTerm 的日志条目时为真</span></span><br><span class="line">  <span class="attr">&quot;matchIndex&quot;</span><span class="punctuation">:</span> <span class="number">12</span>         <span class="comment">// 成功追加的日志条目的索引值（只有在 success 为 true 时包含）</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="领导者选举"><a class="markdownIt-Anchor" href="#领导者选举"></a> 领导者选举</h3>
<p>当现有 Leader 发生故障或算法初始化时，需要选举新的 Leader。这时，集群内将开启一个新的<strong>任期</strong>（term）。<strong>term 用于将时间划分为不同的逻辑周期</strong>，用一个<strong>单调递增</strong>的整数表示。每个 term 都以领导人选举开始。如果选举成功完成（即选举出单个 Leader），则该任期内将由新 Leader 负责正常运作（normal operation）。如果选举失败，该任期结束，新的任期开始，并进行新一轮的选举。</p>
<p><img src="https://i.postimg.cc/W1kyqM7X/Pasted-image-20240806144929.png" alt="Pasted image 20240806144929.png" /></p>
<p>领导者选举由 Candidate 启动。在一段时间内如果 Follower 没有收到 Leader 的心跳，它会<strong>增加自己的任期号</strong>，再成为 Candidate，<strong>为自己投票</strong>，然后向集群中的所有节点发送请求<strong>投票消息</strong>（RequestVote）来开始选举。每个节点<strong>在一个任期只能投票一次</strong>，只能投给任期号<strong>大于等于</strong>自己任期号的 Candidate，并按<strong>先到先得</strong>的原则投票。</p>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>说明</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>每个节点都会维护一个<strong>当前任期号</strong> (current term)。当一个节点收到任期号更大的 <code>RequestVote</code> 或 <code>AppendEntries</code> 时，它必须更新自己的任期号；如果该节点是 Candidate 或者 Leader ，它必须要“放下身段”变为 Follower。如果节点接收到一个任期号小于其维护的当前任期号的请求，它将拒绝该请求。</p>
</div>
</details><p>根据 Candidate 从集群中其他节点收到的响应，可以得出选举的三个结果：</p>
<ol>
<li>收到超过半数的选票，则该节点成为 Leader，开始发送心跳消息。</li>
<li>收到来自 Leader 的心跳消息，如果 Leader 的任期号<strong>大于等于</strong>自己当前的任期号，则它会转变为 Follower，并承认该 Leader 的合法性。</li>
<li>如果以上两种情况都未发生（比如由于票数分散），每个 Candidate 会在选举超时后<strong>增加任期号，并启动新一轮选举</strong>。</li>
</ol>
<details class="custom-callout question" open><summary class="callout-title"><div class="callout-icon"></div><div>为什么选举超时时长是随机的</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>为了最大程度地减少票数分散的情况，这样 Follower 几乎不可能同时成为 Candidate。</p>
</div>
</details><p><img src="https://i.postimg.cc/fTFFbHYV/Pasted-image-20240806133321.jpg" alt="Pasted image 20240806133321.jpg" /></p>
<h3 id="日志复制"><a class="markdownIt-Anchor" href="#日志复制"></a> 日志复制</h3>
<p>在Raft中， Leader 负责日志复制和接收客户端请求，每个请求包含一个将在集群中被复制状态机执行的命令（command）。</p>
<h4 id="具体步骤"><a class="markdownIt-Anchor" href="#具体步骤"></a> 具体步骤</h4>
<ol>
<li>Leader 将 command 作为一个新的<strong>日志条目</strong>（log entry）追加到自己的日志中，然后将该请求以 <code>AppendEntries</code> 消息的形式发送给所有 Follower。</li>
<li>如果 Follower 没有响应，Leader 会<strong>无限期地重试</strong>发送 <code>AppendEntries</code> 消息，直到日志条目<strong>被所有 Follower 存储</strong>为止。</li>
<li>一旦 Leader 收到超过半数的 Follower 确认日志条目已经被复制，它就会将该条目<strong>应用</strong>到本地状态机，并认为该请求已经<strong>提交</strong>（committed）。这一事件也会使得 Leader 日志中的所有之前的条目被间接提交。</li>
<li>当 Follower 得知一个日志条目已被提交后，它会将该条目应用到自己的本地状态机。这确保了集群中所有服务器日志的一致性，从而保证了<strong>日志匹配</strong>的安全规则。</li>
</ol>
<details class="custom-callout caution" open><summary class="callout-title"><div class="callout-icon"></div><div>关于提交</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>一个日志条目被“提交”，意味着这个条目已经被大多数节点复制，并且即使当前 Leader 故障，这个条目也不会被未来的 Leader 删除或覆盖。换句话说，一旦一个日志条目被提交，它就成为了系统状态的一部分，并且<strong>最终</strong>会被所有节点应用。</p>
</div>
</details><h4 id="处理-leader-故障"><a class="markdownIt-Anchor" href="#处理-leader-故障"></a> 处理 Leader 故障</h4>
<p>如果 Leader 故障，日志可能会出现不一致。旧 Leader 的一些日志条目可能已经复制到部分 Follower 但还<strong>未提交</strong>，而新 Leader 可能不具备这些日志条目。在这种情况下，新 Leader 会<strong>强制 Follower 覆盖它自己的日志</strong>（因为这些日志条目尚未提交，不违背外部一致性）。具体步骤如下：</p>
<ol>
<li><strong>日志比较</strong>：新 Leader 会与每个 Follower 比较日志，找到它们<strong>最后一致的条目</strong>。</li>
<li><strong>删除和替换</strong>：然后，新 Leader 会<strong>删除 Follower 中在这个关键条目之后的所有日志条目，并用自己的日志条目覆盖它们</strong>。</li>
</ol>
<h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3>
<p>Raft 确保了以下关键安全特性：</p>
<ul>
<li><strong>选举安全</strong>：在任何给定的任期内，最多只能有一个 Leader 被选举出来。这是通过以下机制实现的：
<ul>
<li>每个节点在一个任期只能投票一次；</li>
<li>只有获得大多数投票才能当任 Leader。</li>
</ul>
</li>
<li><strong>Leader Append-Only</strong>：Leader 只能在其日志的末尾追加新的条目，而不能修改或删除已存在的条目。这保证了日志的顺序性和一致性。</li>
<li><strong>日志匹配</strong>：如果两份日志中的两个条目具有相同的索引和任期号，那么在这两个条目之前（包括这两个条目本身）的所有日志条目在这两份日志中都是相同的。</li>
<li><strong>Leader 完整性</strong>：一旦一个日志条目在某个 Leader 的任期内被提交，那么从该任期开始，所有后续的 Leader（包括当前 Leader 和未来通过选举产生的 Leader）的日志中都将包含这个已提交的日志条目。这确保了即使发生 Leader 变更，已提交的日志条目也不会丢失。</li>
<li><strong>状态机安全</strong>：如果某个节点已经将某个特定的日志条目成功应用到了其状态机上，那么其他任何节点都不能在<strong>同一任期号和索引</strong>上为该日志条目应用不同的命令。这一特性确保了所有节点的状态机在执行相同日志序列后的状态是一致的。为了维持状态机安全：
<ul>
<li>Candidate 在选举过程中必须<strong>包含</strong>之前任期已提交的所有日志条目。如果 Follower 的日志比 Candidate 的日志更<strong>新</strong>（即 Follower 的日志包含更新的任期号或更高的索引），Follower 将拒绝投票给该 Candidate。日志的新旧通过比较任期号和索引来确定，具体地，<strong>任期号大的更新，如果任期号相同，则索引大的更新</strong>。</li>
<li>值得注意的是，Leader <strong>不会直接通过计算集群中日志条目的副本数来提交之前任期内的日志条目</strong>。然而，由于日志匹配特性，Leader 在自己任期内提交的日志条目会间接导致之前任期的日志条目也被提交，因为所有已提交的日志条目必须是连续的。</li>
</ul>
</li>
<li><strong>Follower 故障</strong>：如果 Follower 故障，其他节点发送的 <code>AppendEntries</code> 和 <code>RequestVote</code> 将失败。为了应对这种情况，集群中的其他节点会<strong>持续不断地</strong>尝试与已宕机的 Follower 建立联系，直到 Follower 恢复。如果某个请求在 Follower 故障之前已经被其接收并处理，当 Follower 重新启动并再次接收到这一请求时，它将忽略该请求（幂等）。</li>
<li><strong>时间和可用性</strong>：Raft 算法整体不依赖于客观时间，即使在面对网络延迟或 RPC 通信顺序混乱的情况下，其正确性依然不受影响。Raft 维持一个稳定 Leader 的关键在于系统需满足以下时间条件：broadcastTime（广播时间） &lt;&lt; electionTimeout（选举超时时间） &lt;&lt; MTBF（平均故障时间）。
<ul>
<li><strong>广播时间</strong>：即一次RPC请求从发送到接收完整响应的时间，这一时间跨度极大地受到存储技术的影响，通常范围在0.5毫秒至20毫秒之间。由于 Raft 的 RPC 机制要求接收方将信息持久化到磁盘，因此这一时间相对较长，但仍是可预测的。</li>
<li><strong>选举超时时间</strong>：是 Raft 算法中用于触发新选举的关键参数，它必须显著大于广播时间，以确保在 Leader 可能存在的情况下，足够的 RPC 请求能够完成而不会误触发新的选举。同时，选举超时时间也应远小于系统的平均故障时间，以避免在短暂的故障期间频繁进行不必要的选举。基于广播时间的范围，选举超时时间通常设定在10毫秒至500毫秒之间，以平衡响应速度和系统稳定性。</li>
<li><strong>平均故障时间</strong>：代表系统组件（如服务器）在两次故障之间平均无故障运行的时间，对于大多数服务器而言，这一时间通常以月或年为单位计算，远远超过了选举超时时间的设定范围。</li>
</ul>
</li>
</ul>
<h2 id="相关应用-2"><a class="markdownIt-Anchor" href="#相关应用-2"></a> 相关应用</h2>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXRjZA==" title="Etcd">Etcd<i class="fa fa-external-link-alt"></i></span> 使用 Raft 来管理其内部的高可用复制日志。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9uZ29EQg==">MongoDB<i class="fa fa-external-link-alt"></i></span> 内部实现了一种称为“复制协议”的机制，该机制与 Raft 有许多相似之处，特别是用于维护多个数据副本之间的一致性和选主（选举Leader）的过程。这可以视为 Raft 的一个变体应用。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGlEQg==" title="TiDB">TiDB<i class="fa fa-external-link-alt"></i></span> 采用了 HTAP（混合事务/分析处理）架构，其核心组件之一 TiKV 是一个基于 Raft 的分布式事务型键值数据库。TiKV 使用 Raft 来确保数据的强一致性和高可用性，即使在多个节点出现故障时也能保证数据不丢失且服务不中断。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2xpY2tIb3VzZQ==">ClickHouse<i class="fa fa-external-link-alt"></i></span> 利用 Raft 来实现类似 Zookeeper 的服务，比如用于配置管理、服务发现或分布式锁等场景。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXBhY2hlX0thZmth">Apache Kafka<i class="fa fa-external-link-alt"></i></span> 使用 Raft （KRaft）来管理元数据，从而减少对外部系统的依赖。</li>
</ul>
<h2 id="优点-4"><a class="markdownIt-Anchor" href="#优点-4"></a> 优点</h2>
<ul>
<li><strong>易于理解和实现</strong>：相比于其他共识算法如 Paxos，Raft 算法的设计更加直观和易于理解，使得开发人员能够更容易地实现和调试。</li>
<li><strong>安全性</strong>：Raft 算法通过领导者选举和日志复制等机制来确保数据的一致性和可靠性，提供了较高的安全性。</li>
<li><strong>高可用性</strong>：在 Leader 失效时，Raft 算法能够快速进行新的领导者选举，从而保证系统的高可用性。</li>
<li><strong>强一致性</strong>：Raft 算法通过多数投票机制来确保系统的安全性，任何一条已提交的日志条目都必须在多数节点上复制并最终应用到其状态机，这保证了数据的一致性。</li>
</ul>
<h2 id="缺点-4"><a class="markdownIt-Anchor" href="#缺点-4"></a> 缺点</h2>
<ul>
<li><strong>性能开销</strong>：对于每个写操作，Raft 算法都必须通过 Leader 进行处理和复制。因此，当 Leader 的负载过高时，可能会成为系统的瓶颈，影响性能和响应时间。</li>
<li><strong>Leader 单点故障</strong>：在 Raft 算法中，Leader 扮演着关键角色，负责处理所有客户端请求并协调日志复制。一旦 Leader 失效，不仅会导致与客户端的直接连接中断，还可能引发一系列问题，如提交状态的不确定性增加，客户端难以确认提交的最终状态。这种不确定性进一步影响了系统的整体性能和可用性。</li>
<li><strong>选举期间的服务中断</strong>：当 Leader 发生变更时，系统可能会经历短暂的服务中断。这种中断可能会影响系统的可用性和性能，特别是在频繁发生选举的情况下。</li>
<li><strong>扩展性限制</strong>：Raft 的性能和延迟在大规模集群（如数百个节点）中可能会受到影响。Leader 的负载和日志复制的开销在大规模集群中会显著增加，影响系统的扩展性。</li>
</ul>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>分布式一致性协议和算法是保障现代分布式系统稳定性和数据一致性的核心组件。在本文中，我们探讨了两阶段提交（2PC）和三阶段提交（3PC）协议，以及 Paxos 和 Raft 这两种分布式一致性算法的原理与特点。2PC 和 3PC 通过分阶段协调节点操作，实现事务的一致性，但它们在应对网络分区和节点故障时存在不同的优缺点。相比之下，Paxos 和 Raft 等一致性算法旨在提供容错能力和稳定的领导者选举，能够在更复杂和动态的网络环境中保持集群一致性。</p>
<p>随着分布式系统的广泛应用，这些协议和算法不仅成功解决了事务一致性的关键问题，还奠定了系统高可用性、良好的扩展性以及稳定运行的基础。深入理解和掌握这些核心机制，对于架构师和开发人员在设计及优化分布式系统时至关重要，能够帮助他们做出更加明智、有根据的决策，从而确保系统能够有效应对现实中的各种挑战和复杂情况。</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTMwNDUwMy9hcnRpY2xlL2RldGFpbHMvMTM1MDUyODky">分布式事务 ｜ 2PC与3PC 详解_2pc和3pc-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pY3lmZW5peC5jbi9kaXN0cmlidXRpb24vY29uc2Vuc3VzLw==">分布式共识算法 | 凤凰架构 (icyfenix.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGF4b3NfKGNvbXB1dGVyX3NjaWVuY2Up">Paxos (computer science) - Wikipedia<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzbWZlbmcyL2FydGljbGUvZGV0YWlscy8xMzI4NTExOTU=">一篇文章让你弄懂分布式一致性协议Paxos_paxos 协议-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215X21pdXllL2FydGljbGUvZGV0YWlscy8xMjI5NDQwMTE=">共识算法 — PBFT、Raft和Paxos_pbft raft-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDYyMDQ1MTM=">分布式共识算法 Raft - 知乎<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次服务器宕机后MySQL无法启动的解决过程</title>
    <url>/2024/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%95%E6%9C%BA%E5%90%8EMySQL%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>机房停电，重启服务器后发现 MySQL 无法启动。</p>
<span id="more"></span>
<h1 id="报错内容"><a class="markdownIt-Anchor" href="#报错内容"></a> 报错内容</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ERROR] InnoDB: Ignoring the redo log due to missing MLOG_CHECKPOINT between the checkpoint</span><br></pre></td></tr></table></figure>
<p>表示 MySQL 在启动时检测到 redo 日志中缺少了一个检查点记录，这通常发生在非正常关机后。</p>
<h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1>
<ol>
<li>备份 data 目录</li>
<li>在 <code>my.ini</code> 中添加：</li>
</ol>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">innodb_force_recovery</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<details class="custom-callout note" open><summary class="callout-title"><div class="callout-icon"></div><div>innodb_force_recovery</div>
<div class="callout-fold"></div></summary><div class="callout-body">
<p>这个选项的目的是在数据库发生严重故障时绕过某些恢复步骤，使数据库能够启动。这个选项的值可以设置为1到6之间的整数，每个级别都会忽略更多的错误和恢复步骤</p>
<p>1：忽略所有corrupt页</p>
<p>2：阻止Master Thread，清理操作由Purge Thread执行</p>
<p>3：不进行事务回滚</p>
<p>4：不进行插入缓冲合并操作</p>
<p>5：不查看重做日志，即不进行前滚操作</p>
<p>6：不进行undo操作</p>
<p>遇到关于redo日志文件的问题，尝试设置<code>innodb_force_recovery=3</code>或更高的值可能会帮助数据库启动，因为它会跳过一些redo日志的处理。但是，这也会导致未提交的事务被保留，可能会影响数据的一致性。</p>
</div>
</details><ol start="3">
<li>启动MySQL。如果仍然启动不成功，则每次对 <code>innodb_force_recovery</code> + 1，提高恢复级别再次重启。</li>
<li>使用 mysqldump 导出备份。</li>
<li>关闭 MySQL 服务。</li>
<li>删除 <code>innodb_force_recovery</code> 配置，删除data目录下的内容，记得先备份。</li>
<li>重新初始化MySQL：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>从备份恢复。</li>
</ol>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>记录本站使用的主题配置和插件</title>
    <url>/2024/%E8%AE%B0%E5%BD%95%E6%9C%AC%E7%AB%99%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="next"><a class="markdownIt-Anchor" href="#next"></a> <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL2dldHRpbmctc3RhcnRlZC8=">NexT<i class="fa fa-external-link-alt"></i></span></h1>
<p>先看效果：&lt;a href=“/2024/Markdown渲染测试/”&gt;Markdown渲染测试</a></p>
<span id="more"></span>
<h2 id="自动生成类别"><a class="markdownIt-Anchor" href="#自动生成类别"></a> 自动生成类别</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3p0aHh4eC9oZXhvLWRpcmVjdG9yeS1jYXRlZ29yeQ==">zthxxx/hexo-directory-category: Automatically add category to Hexo article according to the article file directory.<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="暗黑模式"><a class="markdownIt-Anchor" href="#暗黑模式"></a> 暗黑模式</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVjaGdyb3cuY24vcG9zdHMvYWJmNGFlZTEuaHRtbA==">Hexo Next 8.x 主题添加可切换的暗黑模式 | Clay 的技术空间<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="本地搜索"><a class="markdownIt-Anchor" href="#本地搜索"></a> 本地搜索</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL3RoaXJkLXBhcnR5LXNlcnZpY2VzL3NlYXJjaC1zZXJ2aWNlcyNMb2NhbC1TZWFyY2g=">Search Services | NexT<i class="fa fa-external-link-alt"></i></span></p>
<p>本地搜索不需要任何外部第三方服务，并且可以被搜索引擎额外索引。推荐大多数用户使用这种搜索方法。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<p>在 <code>_config.next.yml</code> 中修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="字数统计"><a class="markdownIt-Anchor" href="#字数统计"></a> 字数统计</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by13b3JkLWNvdW50ZXI=">hexo-word-counter<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL3RoZW1lLXNldHRpbmdzL3Bvc3RzLmh0bWw/aGlnaGxpZ2h0PXN5bWJvbHNfY291bnRfdGltZSNQb3N0LVdvcmRjb3VudA==">Post Settings | NexT<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter --save</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">suffix:</span> <span class="string">&quot;mins.&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>
<p><code>awl</code> 为平均字符长度</p>
<ul>
<li>CN ≈ 2</li>
<li>EN ≈ 5</li>
<li>RU ≈ 6</li>
</ul>
</li>
<li>
<p><code>wpm</code> 为每秒阅读的单词数</p>
<ul>
<li>Slow ≈ 200</li>
<li>Normal ≈ 275</li>
<li>Fast ≈ 350</li>
</ul>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25leHQtdGhlbWUvaGV4by13b3JkLWNvdW50ZXIjcGFyYW1ldGVycw==">更多参数<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
<blockquote>
<p>中文的话推荐配置 <code>awl</code> = 2, <code>wpm</code> = 300</p>
</blockquote>
<p>在 <code>_config.next.yml</code> 中配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="阅读进度显示"><a class="markdownIt-Anchor" href="#阅读进度显示"></a> 阅读进度显示</h2>
<p>next 主题自带的 back2top 和暗黑模式按钮放一起有些违和，遂改用 moon-cake：</p>
<p><img src="https://img.picgo.net/2024/11/25/2024112513482484770e3e31caa6c4.png" alt="image.png" /></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-extend-injector2 --save</span><br><span class="line">npm install hexo-cake-moon-menu --save</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.next.yml</code> 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">moon_menu:</span></span><br><span class="line">  <span class="attr">back2top:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-chevron-up</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">back2bottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-chevron-down</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-2</span></span><br></pre></td></tr></table></figure>
<p>自定义样式 <code>themes/next/source/css/_custom/moon_cake.css</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.moon-menu</span>, <span class="selector-class">.moon-menu-bg</span>, <span class="selector-class">.moon-menu-content</span> &#123;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">29px</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">bottom</span>: <span class="number">128px</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">3.4rem</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">3.4rem</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">1rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.moon-menu</span> &#123;</span><br><span class="line">	<span class="attr">--moon-cricle</span>: <span class="number">#100F2C</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attr">--moon-item-bg-color</span>: <span class="number">#100F2C</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.moon-menu-item</span> &#123;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0.46em</span> <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#282828</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.moon-menu-text</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">1.1rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.moon-menu-icon</span> &#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">2.1rem</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>themes/next/source/css/main.styl</code> 引用该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;_custom/moon_cake.css&#x27;;</span><br></pre></td></tr></table></figure>
<p><code>themes/next/source/css/_custom/darkmode.styl</code> 中添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.darkmode--activated</span> <span class="selector-class">.moon-menu</span> &#123;</span><br><span class="line">    <span class="attr">--moon-cricle</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attr">--moon-item-bg-color</span>: <span class="number">#fff</span> <span class="meta">!important</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.darkmode--activated</span> <span class="selector-class">.moon-menu-icon</span>,<span class="selector-class">.darkmode--activated</span> <span class="selector-class">.moon-menu-item</span>,<span class="selector-class">.darkmode--activated</span> <span class="selector-class">.moon-menu-text</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果：</p>
<p><img src="https://img.picgo.net/2024/11/25/20241125151422a40d1e9f9dc0f694.png" alt="image.png" /></p>
<h2 id="鼠标点击特效"><a class="markdownIt-Anchor" href="#鼠标点击特效"></a> 鼠标点击特效</h2>
<ol>
<li>
<p><code>themes/next/source</code> 下新建文件 <code>clicklove.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params">e,t,a</span>)&#123;<span class="keyword">function</span> <span class="title function_">n</span>(<span class="params"></span>)&#123;<span class="title function_">c</span>(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),<span class="title function_">o</span>(),<span class="title function_">r</span>()&#125;<span class="keyword">function</span> <span class="title function_">r</span>(<span class="params"></span>)&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.<span class="property">length</span>;e++)d[e].<span class="property">alpha</span>&lt;=<span class="number">0</span>?(t.<span class="property">body</span>.<span class="title function_">removeChild</span>(d[e].<span class="property">el</span>),d.<span class="title function_">splice</span>(e,<span class="number">1</span>)):(d[e].<span class="property">y</span>--,d[e].<span class="property">scale</span>+=<span class="number">.004</span>,d[e].<span class="property">alpha</span>-=<span class="number">.013</span>,d[e].<span class="property">el</span>.<span class="property">style</span>.<span class="property">cssText</span>=<span class="string">&quot;left:&quot;</span>+d[e].<span class="property">x</span>+<span class="string">&quot;px;top:&quot;</span>+d[e].<span class="property">y</span>+<span class="string">&quot;px;opacity:&quot;</span>+d[e].<span class="property">alpha</span>+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].<span class="property">scale</span>+<span class="string">&quot;,&quot;</span>+d[e].<span class="property">scale</span>+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].<span class="property">color</span>+<span class="string">&quot;;z-index:99999&quot;</span>);<span class="title function_">requestAnimationFrame</span>(r)&#125;<span class="keyword">function</span> <span class="title function_">o</span>(<span class="params"></span>)&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.<span class="property">onclick</span>&amp;&amp;e.<span class="property">onclick</span>;e.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params">e</span>)&#123;t&amp;&amp;<span class="title function_">t</span>(),<span class="title function_">i</span>(e)&#125;&#125;<span class="keyword">function</span> <span class="title function_">i</span>(<span class="params">e</span>)&#123;<span class="keyword">var</span> a=t.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);a.<span class="property">className</span>=<span class="string">&quot;heart&quot;</span>,d.<span class="title function_">push</span>(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.<span class="property">clientX</span>-<span class="number">5</span>,<span class="attr">y</span>:e.<span class="property">clientY</span>-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:<span class="title function_">s</span>()&#125;),t.<span class="property">body</span>.<span class="title function_">appendChild</span>(a)&#125;<span class="keyword">function</span> <span class="title function_">c</span>(<span class="params">e</span>)&#123;<span class="keyword">var</span> a=t.<span class="title function_">createElement</span>(<span class="string">&quot;style&quot;</span>);a.<span class="property">type</span>=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.<span class="title function_">appendChild</span>(t.<span class="title function_">createTextNode</span>(e))&#125;<span class="keyword">catch</span>(t)&#123;a.<span class="property">styleSheet</span>.<span class="property">cssText</span>=e&#125;t.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].<span class="title function_">appendChild</span>(a)&#125;<span class="keyword">function</span> <span class="title function_">s</span>(<span class="params"></span>)&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="title class_">Math</span>.<span class="title function_">random</span>())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.<span class="property">requestAnimationFrame</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> e.<span class="property">requestAnimationFrame</span>||e.<span class="property">webkitRequestAnimationFrame</span>||e.<span class="property">mozRequestAnimationFrame</span>||e.<span class="property">oRequestAnimationFrame</span>||e.<span class="property">msRequestAnimationFrame</span>||<span class="keyword">function</span>(<span class="params">e</span>)&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),<span class="title function_">n</span>()&#125;(<span class="variable language_">window</span>,<span class="variable language_">document</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改文件 <code>layout/_scripts/index.njk</code>，在最后添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- next_js(&#x27;clicklove.js&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="代码折叠"><a class="markdownIt-Anchor" href="#代码折叠"></a> 代码折叠</h2>
<p>NexT 在 <code>v8.18.0</code> 后已支持代码折叠功能：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">fold:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>如果是 <code>8.18.0</code> 以前的版本，可以采用以下方案：&lt;a href=“/2024/Hexo实现代码折叠功能/”&gt;Hexo实现代码折叠功能</a></p>
<h2 id="双向链接支持"><a class="markdownIt-Anchor" href="#双向链接支持"></a> 双向链接支持</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3V1YW5xaW4vaGV4by1maWx0ZXItdGl0bGViYXNlZC1saW5r">uuanqin/hexo-filter-titlebased-link: Transfer wiki links (based on the title) in Markdown files to permalink. 将基于标题的双向链接转换为 Hexo 设定的永久链接。<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="callouts-支持"><a class="markdownIt-Anchor" href="#callouts-支持"></a> Callouts 支持</h2>
<p>安装插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 替换原先的 markdown 渲染器</span></span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-markdown-it-plus --save</span><br><span class="line">npm install mdit-plugin-callouts --save</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 中添加插件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># markdown_it_plus 语法渲染插件选项</span></span><br><span class="line"><span class="attr">markdown_it_plus:</span></span><br><span class="line">    <span class="attr">plugins:</span></span><br><span class="line">        <span class="comment"># Obsidian Callouts</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">plugin:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">mdit-plugin-callouts</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">options:</span></span><br><span class="line">                <span class="comment"># this is plugin option</span></span><br></pre></td></tr></table></figure>
<p>在 <code>themes/next/source/css</code> 下创建一个_custom文件夹，新建外部 CSS 文件 <code>callout_blocks.css</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--un-ring-offset-shadow</span>: <span class="number">0</span> <span class="number">0</span> transparent;</span><br><span class="line">    <span class="attr">--un-ring-shadow</span>: <span class="number">0</span> <span class="number">0</span> transparent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">3px</span> solid;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--callout-radius);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="built_in">var</span>(--un-ring-offset-shadow), <span class="built_in">var</span>(--un-ring-shadow), <span class="built_in">var</span>(--un-shadow);</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attr">--callout-note</span>: <span class="number">68</span>, <span class="number">138</span>, <span class="number">255</span>;</span><br><span class="line">    <span class="attr">--callout-abstract</span>: <span class="number">0</span>, <span class="number">176</span>, <span class="number">255</span>;</span><br><span class="line">    <span class="attr">--callout-info</span>: <span class="number">0</span>, <span class="number">184</span>, <span class="number">212</span>;</span><br><span class="line">    <span class="attr">--callout-tip</span>: <span class="number">0</span>, <span class="number">191</span>, <span class="number">165</span>;</span><br><span class="line">    <span class="attr">--callout-success</span>: <span class="number">8</span>, <span class="number">185</span>, <span class="number">78</span>;</span><br><span class="line">    <span class="attr">--callout-question</span>: <span class="number">224</span>, <span class="number">172</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="attr">--callout-warning</span>: <span class="number">255</span>, <span class="number">145</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="attr">--callout-failure</span>: <span class="number">255</span>, <span class="number">82</span>, <span class="number">82</span>;</span><br><span class="line">    <span class="attr">--callout-danger</span>: <span class="number">255</span>, <span class="number">23</span>, <span class="number">68</span>;</span><br><span class="line">    <span class="attr">--callout-bug</span>: <span class="number">245</span>, <span class="number">0</span>, <span class="number">87</span>;</span><br><span class="line">    <span class="attr">--callout-example</span>: <span class="number">124</span>, <span class="number">77</span>, <span class="number">255</span>;</span><br><span class="line">    <span class="attr">--callout-quote</span>: <span class="number">158</span>, <span class="number">158</span>, <span class="number">158</span>;</span><br><span class="line">    <span class="attr">--callout-radius</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attr">--callout-border-opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">    <span class="attr">--callout-title-bg-opacity</span>: <span class="number">0.08</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-fold</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;gray&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;chevron-down&quot;&gt;&lt;path d=&quot;m6 9 6 6 6-6&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-fold</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">90deg</span>);</span><br><span class="line">    <span class="attribute">transition</span>: .<span class="number">5s</span> <span class="built_in">cubic-bezier</span>(.<span class="number">075</span>, .<span class="number">82</span>, .<span class="number">165</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-attr">[open]</span> &gt; <span class="selector-tag">summary</span> &gt; <span class="selector-class">.callout-fold</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">border-top-left-radius</span>: <span class="built_in">var</span>(--callout-radius);</span><br><span class="line">    <span class="attribute">border-top-right-radius</span>: <span class="built_in">var</span>(--callout-radius);</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-tag">summary</span><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-tag">summary</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: .<span class="number">5rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-tag">summary</span>::-webkit-details-marker &#123;</span><br><span class="line">    <span class="attribute">display</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-title</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: transparent <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">5rem</span> <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-body</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">8px</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-body</span> &gt; pre &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1.25rem</span> -<span class="number">1rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-body</span> &gt; pre<span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -.<span class="number">75rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-body</span> &gt; pre<span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: -.<span class="number">75rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.note</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-note), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.note</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-note), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.abstract</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tldr</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-abstract), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.abstract</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.summary</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tldr</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-abstract), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.info</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.todo</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-info), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.info</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.todo</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-info), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.hint</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.important</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tip</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-tip), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.hint</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.important</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tip</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-tip), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.check</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.done</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.success</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-success), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.check</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.done</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.success</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-success), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.faq</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.help</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.question</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-question), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.faq</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.help</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.question</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-question), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.attention</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.caution</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.warning</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-warning), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.attention</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.caution</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.warning</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-warning), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.fail</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.failure</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.missing</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-failure), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.fail</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.failure</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.missing</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-failure), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.danger</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-danger), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.danger</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.error</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-danger), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.bug</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-bug), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.bug</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-bug), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.example</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-example), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.example</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-example), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.cite</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.quote</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-quote), <span class="built_in">var</span>(--callout-border-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.cite</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.quote</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-quote), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> &#123;</span><br><span class="line">    -webkit-box-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    -ms-<span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">0%</span>;</span><br><span class="line">    -webkit-<span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">0%</span>;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">0%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: .<span class="number">25rem</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-icon</span> &#123;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.attention</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.caution</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.warning</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23FF9100&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-alert-triangle&quot;&gt;&lt;path d=&quot;m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.note</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23448AFF&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-pencil&quot;&gt;&lt;path d=&quot;m18 2 4 4M7.5 20.5 19 9l-4-4L3.5 16.5 2 22z&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.abstract</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.summary</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tldr</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%2300B0FF&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-clipboard-list&quot;&gt;&lt;rect x=&quot;8&quot; y=&quot;2&quot; width=&quot;8&quot; height=&quot;4&quot; rx=&quot;1&quot; ry=&quot;1&quot;/&gt;&lt;path d=&quot;M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2M12 11h4M12 16h4M8 11h.01M8 16h.01&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.info</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.todo</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%2300B8D4&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-check-circle-2&quot;&gt;&lt;path d=&quot;M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z&quot;/&gt;&lt;path d=&quot;m9 12 2 2 4-4&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.hint</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.important</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.tip</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%2300BFA5&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-flame&quot;&gt;&lt;path d=&quot;M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.check</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.done</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.success</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%2300C853&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-check&quot;&gt;&lt;path d=&quot;M20 6 9 17l-5-5&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.faq</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.help</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.question</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23E0AC00&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-help-circle&quot;&gt;&lt;circle cx=&quot;12&quot; cy=&quot;12&quot; r=&quot;10&quot;/&gt;&lt;path d=&quot;M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3M12 17h.01&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.fail</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.failure</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.missing</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23FF5252&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-x&quot;&gt;&lt;path d=&quot;M18 6 6 18M6 6l12 12&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.danger</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.error</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23FF1744&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-zap&quot;&gt;&lt;path d=&quot;M13 2 3 14h9l-1 8 10-12h-9l1-8z&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.bug</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23F50057&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-bug&quot;&gt;&lt;rect x=&quot;8&quot; y=&quot;6&quot; width=&quot;8&quot; height=&quot;14&quot; rx=&quot;4&quot;/&gt;&lt;path d=&quot;m19 7-3 2M5 7l3 2M19 19l-3-2M5 19l3-2M20 13h-4M4 13h4M10 4l1 2M14 4l-1 2&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.example</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%237C4DFF&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-list&quot;&gt;&lt;path d=&quot;M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.cite</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.quote</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%239E9E9E&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-quote&quot;&gt;&lt;path d=&quot;M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找不到关键字则提供默认样式 note 样式 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:image/svg+xml;charset=utf-8,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;20&quot; height=&quot;20&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;%23448AFF&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-pencil&quot;&gt;&lt;path d=&quot;m18 2 4 4M7.5 20.5 19 9l-4-4L3.5 16.5 2 22z&quot;/&gt;&lt;/svg&gt;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> , <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &#123;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-note), <span class="built_in">var</span>(--callout-border-opacity)); <span class="comment">/* 不起作用 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> &gt; <span class="selector-tag">summary</span>, <span class="selector-class">.custom-callout</span><span class="selector-class">.seealso</span> &gt; <span class="selector-tag">summary</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-note), <span class="built_in">var</span>(--callout-title-bg-opacity))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标题加粗并着色 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span> <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-note)); <span class="comment">/* 默认颜色 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.abstract</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.summary</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.tldr</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-abstract));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.info</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.todo</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-info));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.hint</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.important</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.tip</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-tip));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.check</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.done</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.success</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-success));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.question</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.faq</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.help</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-question));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.attention</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.caution</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.warning</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-warning));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.fail</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.failure</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.missing</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-failure));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.error</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.danger</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-danger));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.bug</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-bug));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.example</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-example));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.cite</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span> ,</span><br><span class="line"><span class="selector-class">.custom-callout</span><span class="selector-class">.quote</span>&gt; <span class="selector-class">.callout-title</span> &gt; <span class="selector-class">.callout-icon</span> + <span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="built_in">var</span>(--callout-quote));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在 <code>themes/next/source/css/main.styl</code> 引用该文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &#x27;_custom/callout_blocks.css&#x27;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>博主也尝试了使用 next 的<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9kb2NzL2FkdmFuY2VkLXNldHRpbmdzL2N1c3RvbS1maWxlcy5odG1sP2hpZ2hsaWdodD1jdXN0b20ranMjQ3VzdG9tLUZpbGUtU3VwcG9ydA==">自定义文件<i class="fa fa-external-link-alt"></i></span>方式，即在 <code>styles.styl</code> 里添加样式，会有显示问题。</p>
</blockquote>
<h2 id="cdn-加速"><a class="markdownIt-Anchor" href="#cdn-加速"></a> CDN 加速</h2>
<p>【✅推荐】南方科技大学 CDN 镜像 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV1YW5xaW4udG9wL2dvLmh0bWw/dT1hSFIwY0RvdkwyMXBjbkp2Y25NdWMzVnpkR1ZqYUM1bFpIVXVZMjR2YUdWc2NDOWpaRzVxY3k1b2RHMXM=">mirrors.sustech.edu.cn/help/cdnjs.html<i class="fa fa-external-link-alt"></i></span> ，是 cdnjs 的镜像站。</p>
<p>修改 <code>_config.next.yml</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">internal:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">plugins:</span> <span class="string">custom</span></span><br><span class="line">  <span class="attr">custom_cdn_url:</span> <span class="string">https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/$&#123;cdnjs_name&#125;/$&#123;version&#125;/$&#123;cdnjs_file&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="生成站点地图"><a class="markdownIt-Anchor" href="#生成站点地图"></a> 生成站点地图</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在 hexo 站点根目录下，创建站点地图的模板文件 <code>sitemap_template.xml</code>，将以下内容复制到文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">urlset</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;</span>&gt;</span></span><br><span class="line">  &#123;% for post in posts %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loc</span>&gt;</span>&#123;&#123; post.permalink | uriencode &#125;&#125;<span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">    &#123;% if post.updated %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.updated.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% elif post.date %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">lastmod</span>&gt;</span>&#123;&#123; post.date.toISOString() &#125;&#125;<span class="tag">&lt;/<span class="name">lastmod</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">urlset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>_config.yml</code> 中添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line">   <span class="attr">template:</span> <span class="string">./sitemap_template.xml</span></span><br></pre></td></tr></table></figure>
<h2 id="页脚添加萌-icp-备案"><a class="markdownIt-Anchor" href="#页脚添加萌-icp-备案"></a> 页脚添加萌 ICP 备案</h2>
<p>在 <code>themes/next/layout/_partials/</code> 目录下创建 <code>moe_icp.njk</code> 源文件，并添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.moe_icp</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">all</span>: unset; <span class="comment">/* 重置所有默认样式 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.moe_icp</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">filter</span>: <span class="built_in">brightness</span>(<span class="number">1.2</span>);</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;moe_icp&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: flex; justify-content: center; align-items: center; gap: 10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://icp.gov.moe/?keyword=20248869&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/%E8%90%8CICP%E5%A4%8720248869%E5%8F%B7-e22b84&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;萌ICP备20248869号&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding-top: 9px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;color:#e77c8e; display: inline-flex; align-items: center;&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">href</span>=<span class="string">&quot;https://travel.moe/go.html&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">title</span>=<span class="string">&quot;异次元之旅-跃迁-我们一起去萌站成员的星球旅行吧！&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://travel.moe/images/icon/icon64pink.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:24px;height:24px; margin-right: 4px;&quot;</span>&gt;</span></span><br><span class="line">    异次元之旅</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>themes/next/layout/_partials/footer.njk</code> 的文件末尾添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.moe_icp.enable %&#125;</span><br><span class="line">  &#123;% include &#x27;moe_icp.njk&#x27; %&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>themes/next/_config.yml</code> 添加以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 萌备</span></span><br><span class="line"><span class="attr">moe_icp:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="页脚添加站点运行时间"><a class="markdownIt-Anchor" href="#页脚添加站点运行时间"></a> 页脚添加站点运行时间</h2>
<p>在 <code>themes/next/layout/_partials/</code> 目录下创建 <code>runtime.njk</code> 源文件，并添加如下内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;site-runtime&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-clock-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;runtime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">isPC</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> userAgentInfo = navigator.<span class="property">userAgent</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> agents = [<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; agents.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (userAgentInfo.<span class="title function_">indexOf</span>(agents[i]) &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">siteTime</span>(<span class="params">openOnPC, start</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="string">&quot;siteTime(openOnPC, start)&quot;</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> years = days * <span class="number">365</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#123;%- <span class="keyword">if</span> theme.<span class="property">runtime</span>.<span class="property">start</span> %&#125;</span></span><br><span class="line"><span class="language-javascript">      start = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;&#123;&#123; theme.runtime.start &#125;&#125;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#123;%- endif %&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> year = now.<span class="title function_">getFullYear</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> month = now.<span class="title function_">getMonth</span>() + <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> date = now.<span class="title function_">getDate</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> hour = now.<span class="title function_">getHours</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> minute = now.<span class="title function_">getMinutes</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> second = now.<span class="title function_">getSeconds</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diff = now - start;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diffYears = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff / years);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diffDays = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff / days) - diffYears * <span class="number">365</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diffHours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days) / hours);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diffMinutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours) / minutes);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> diffSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (openOnPC) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;runtime&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已运行: &quot;</span> + diffYears + <span class="string">&quot; 年 &quot;</span> + diffDays + <span class="string">&quot; 天 &quot;</span> + diffHours + <span class="string">&quot; 小时 &quot;</span> + diffMinutes + <span class="string">&quot; 分 &quot;</span> + diffSeconds + <span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;runtime&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;本站已运行: &quot;</span> + diffYears + <span class="string">&quot;年 &quot;</span> + diffDays + <span class="string">&quot;天 &quot;</span> + diffHours + <span class="string">&quot;小时 &quot;</span> + diffMinutes + <span class="string">&quot;分 &quot;</span> + diffSeconds + <span class="string">&quot;秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> showOnMobile = &#123;&#123; theme.<span class="property">runtime</span>.<span class="property">mobile</span> &#125;&#125;;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> openOnPC = <span class="title function_">isPC</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">siteTime</span>(openOnPC, start);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span> (!openOnPC &amp;&amp; !showOnMobile) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;site-runtime&#x27;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>themes/next/layout/_partials/footer.njk</code> 的文件末尾添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.runtime.enable %&#125;</span><br><span class="line">  &#123;% include &#x27;runtime.swig&#x27; %&#125;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>_config.next.yml</code> 添加以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site Runtime</span></span><br><span class="line"><span class="attr">runtime:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The time of the site started running. If not defined, current time of local time zone will be used.</span></span><br><span class="line">  <span class="comment"># You can specify the time zone by adding the `+HOURS` or `-HOURS` format time zone.</span></span><br><span class="line">  <span class="comment"># If not specify the time zone, it will use `+0000` as default.</span></span><br><span class="line">  <span class="comment"># ex: &quot;2015-06-08 07:24:13 +0800&quot;, `+0800` specify that it is the time in the East Eight Time Zone.</span></span><br><span class="line">  <span class="attr">start:</span> <span class="number">2019-11-23 09:00:00</span> <span class="string">+0800</span></span><br><span class="line">  <span class="comment"># Whether to show on the mobile side</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="启用不蒜子统计"><a class="markdownIt-Anchor" href="#启用不蒜子统计"></a> 启用不蒜子统计</h2>
<p>在 <code>_config.next.yml</code> 中设置以下内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<p>由于流量日渐变多，不蒜子经常会出现 <code>502</code> 的情况，可以自己搭建服务，参见：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnpoaGVvLmNvbS9wL2I3YmI3ODMyLmh0bWw=">如何自己搭建busuanzi不蒜子平台，搭建静态博客的访问量统计 | 张洪Heo<i class="fa fa-external-link-alt"></i></span></p>
<p>或者使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3prZXE=">zkeq<i class="fa fa-external-link-alt"></i></span> 大佬的<span class="exturl" data-url="aHR0cHM6Ly9idXN1YW56aS5pY29kZXEuY29tLw==">自建 API<i class="fa fa-external-link-alt"></i></span>，直接在 <code>_config.next.yml</code> 中的 <strong>vendors</strong> 下添加：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="attr">busuanzi:</span> <span class="string">https://busuanzi.icodeq.com/busuanzi.pure.mini.js</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NzM4NTEwL2FydGljbGUvZGV0YWlscy8xMDYyMDA0MjA=">Hexo之next主题优化_hexo next首页优化-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV1YW5xaW4udG9wL3AvZDRiYzU1ZjIv">Hexo 博客适配 Obsidian 新语法 | 半方池水半方田<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVjaGdyb3cuY24vcG9zdHMvNzU1ZmYzMGQuaHRtbA==">Hexo Next 主题详细配置之一 | Clay 的技术空间<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>博客相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>深度解析 class-winter：构建时加密与运行时解密的JAR保护方案</title>
    <url>/2025/class-winter-%E5%AE%8C%E6%95%B4%E6%8A%80%E6%9C%AF%E6%8E%A2%E6%9F%A5%E4%B8%8E%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>在Java的世界里，字节码的易于反编译性一直是保护知识产权和核心业务逻辑的一大挑战。为了应对这一挑战，开发者们探索了各种代码混淆和加密技术。今天，我们将深入剖析一个名为 <code>class-winter</code> 的开源项目，它通过一种精巧的“构建时加密，运行时解密”机制，为Java应用提供了一层坚实的静态保护外壳。</p>
<p>项目地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vSnVzdHJ5RGVuZy9jbGFzcy13aW50ZXI=">class-winter (Gitee)<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="总体架构两阶段安全模式"><a class="markdownIt-Anchor" href="#总体架构两阶段安全模式"></a> <strong>总体架构：两阶段安全模式</strong></h1>
<p><code>class-winter</code> 的核心思想是将代码的保护分为两个独立且衔接的阶段：</p>
<ol>
<li><strong>第一阶段（构建时）</strong>：在项目打包（<code>package</code>）阶段，一个自定义的 <strong>Maven插件 (<code>class-winter-maven-plugin</code>)</strong> 会被触发。它会精准地找到需要保护的 <code>.class</code> 文件和资源文件，使用AES算法对其进行加密，然后巧妙地将原始 <code>.class</code> 文件的方法体“掏空”，最后生成一个加密后的JAR或WAR包。</li>
<li><strong>第二阶段（运行时）</strong>：当应用启动时，借助 <strong>Java Agent (<code>class-winter-core</code>)</strong> 技术，一个<code>ClassFileTransformer</code>会悄无声息地注入到JVM中。这个“转换器”会拦截所有类的加载请求。当它识别到这是一个被加密过的“空壳”类时，便会在内存中实时进行解密，并将原始的、完整的字节码交还给JVM。</li>
</ol>
<p>整个过程对上层应用程序完全透明，业务代码无需任何修改即可享受到保护。</p>
<h1 id="第一阶段构建时的加密魔法"><a class="markdownIt-Anchor" href="#第一阶段构建时的加密魔法"></a> <strong>第一阶段：构建时的加密魔法</strong></h1>
<p>让我们跟随源码，一探究竟在项目打包时发生了什么。</p>
<h2 id="1-入口一切始于maven插件"><a class="markdownIt-Anchor" href="#1-入口一切始于maven插件"></a> <strong>1. 入口：一切始于Maven插件</strong></h2>
<p>分析的起点是 <code>class-winter-maven-plugin</code> 模块。其核心类 <code>ClassWinterPlugin</code> 继承自 <code>AbstractMojo</code>，并绑定在Maven的 <code>package</code> 构建生命周期上。它的主要职责是：</p>
<ul>
<li>解析 <code>pom.xml</code> 中配置的参数，例如加密密码 (<code>password</code>)、需要加密的包路径前缀 (<code>includePrefix</code>) 等。</li>
<li>实例化并调用加密执行器 <code>EncryptExecutor</code>，启动真正的加密流程。</li>
</ul>
<h2 id="2-核心揭秘加密逻辑"><a class="markdownIt-Anchor" href="#2-核心揭秘加密逻辑"></a> <strong>2. 核心：揭秘加密逻辑</strong></h2>
<p><code>EncryptExecutor</code> 是整个加密过程的大脑。深入其代码，我们发现了几个关键点：</p>
<ul>
<li>
<p><strong>加密算法</strong>：在工具类 <code>EncryptUtil.java</code> 中，一行代码揭示了天机：<code>private static final String AES_MODE = &quot;AES/ECB/PKCS5Padding&quot;;</code>。这明确了其加密方案为 <strong>AES</strong> 算法，配合 <strong>ECB</strong> 工作模式和 <strong>PKCS5Padding</strong> 填充。</p>
</li>
<li>
<p><strong>密钥生成</strong>：你以为在配置中提供的 <code>password</code> 就是最终的AES密钥吗？并非如此。为了增强安全性，<code>class-winter</code> 会将用户提供的密码与一个内部硬编码的<code>SALT</code>（盐值）合并，然后计算其 <strong>MD5</strong> 值。这个16字节的MD5摘要才是用于AES加密的真正密钥。这种加盐机制可以有效抵御针对预计算彩虹表的攻击。</p>
</li>
<li>
<p><strong>文件处理与伪装</strong>：<code>EncryptExecutor.process()</code> 方法负责调度整个加密工作流。它会：</p>
<ol>
<li>根据配置筛选出目标 <code>.class</code> 文件。</li>
<li>调用 <code>EncryptUtil</code> 加密其字节码。</li>
<li>将加密后的密文存放在打包产物内的 <code>winter/classes/</code> 目录下。</li>
<li>执行一个关键操作：利用 <strong>Javassist</strong> 字节码操作库，调用 <code>clearClassMethod()</code> 方法，将原始 <code>.class</code> 文件的所有方法体清空，只保留方法签名。这使得任何试图直接反编译JAR包中 <code>.class</code> 文件的行为，都只能看到一堆没有实现的空方法，从而完美实现静态反编译防御。</li>
</ol>
</li>
</ul>
<h1 id="第二阶段运行时的解密揭秘"><a class="markdownIt-Anchor" href="#第二阶段运行时的解密揭秘"></a> <strong>第二阶段：运行时的解密揭秘</strong></h1>
<p>加密后的代码如何“复活”？答案就隐藏在Java Agent技术中。</p>
<h2 id="1-注入java-agent的妙用"><a class="markdownIt-Anchor" href="#1-注入java-agent的妙用"></a> <strong>1. 注入：Java Agent的妙用</strong></h2>
<p>在加密阶段，<code>EncryptExecutor</code> 还会悄悄地修改打包产物的 <code>META-INF/MANIFEST.MF</code> 文件，添加一行至关重要的配置：<code>Premain-Class: winter.com.ideaaedi.classwinter.Reverses</code>。</p>
<p>这就是 <strong>Java Agent</strong> 的入口。当你的Java应用使用 <code>-javaagent</code> 参数启动时，JVM在执行 <code>main</code> 方法前，会首先调用 <code>Reverses</code> 类的 <code>premain</code> 方法。这种机制提供了一个极早期、极底层的代码注入点，远比自定义ClassLoader更为强大和通用。</p>
<h2 id="2-解密透明的类加载转换"><a class="markdownIt-Anchor" href="#2-解密透明的类加载转换"></a> <strong>2. 解密：透明的类加载转换</strong></h2>
<p><code>Reverses.premain</code> 方法是运行时解密的起点。它的核心动作是向JVM注册一个自定义的 <code>ClassFileTransformer</code>。这个Transformer从此便获得了“审查”每一个即将被加载的类的权力。</p>
<p>其完整的解密数据流如下：</p>
<ol>
<li>
<p><strong>拦截</strong>：当JVM需要加载一个类（如 <code>com.example.MyService</code>）时，它首先读取到的是我们之前处理过的“空壳”字节码。这个字节码被传递给 <code>transform</code> 方法。</p>
</li>
<li>
<p><strong>识别</strong>：<code>transform</code> 方法会进行双重校验：</p>
<ul>
<li>首先，它会查询 <code>checklist.classes.winter</code> 文件（一个在加密时生成的清单），确认当前类是否在被加密的名单上。</li>
<li>其次，它会检查“空壳”字节码中是否嵌入了加密时留下的特殊“印章”，确保不会误处理。</li>
</ul>
</li>
<li>
<p><strong>获取密钥</strong>：<code>premain</code> 方法会解析 <code>-javaagent</code> 启动参数，从中提取出 <code>password=...</code> 部分来获取解密密码。</p>
</li>
<li>
<p><strong>执行解密</strong>：确认是目标类后，<code>DecryptExecutor</code> 被调用。它会根据类名，从 <code>winter/classes/</code> 目录中读取对应的密文。然后，使用与加密时完全相同的 <code>SALT + MD5</code> 方式生成密钥，调用 <code>EncryptUtil.decrypt()</code> 将密文解密，还原出原始的、完整的 <code>.class</code> 字节码。</p>
</li>
<li>
<p><strong>返回明文</strong>：<code>transform</code> 方法将解密后的明文字节码返回给JVM。</p>
</li>
<li>
<p><strong>完成加载</strong>：JVM拿到明文的字节码后，继续执行后续的类定义、链接和初始化。</p>
</li>
</ol>
<p>至此，一个被加密的类就神不知鬼不觉地在内存中被还原并投入使用，整个过程对应用程序而言毫无感知。</p>
<h1 id="最终结论与安全评估"><a class="markdownIt-Anchor" href="#最终结论与安全评估"></a> <strong>最终结论与安全评估</strong></h1>
<p><code>class-winter</code> 提供了一个设计精良的代码保护框架。</p>
<h2 id="核心优势"><a class="markdownIt-Anchor" href="#核心优势"></a> <strong>核心优势</strong></h2>
<ul>
<li><strong>强大的静态反编译防御</strong>：直接反编译打包产物无法得到任何有用的业务逻辑，能有效抵御初级的逆向分析。</li>
<li><strong>对使用者透明</strong>：一次配置，长期有效。开发者无需关心加密解密的细节，可以专注于业务开发。</li>
</ul>
<h2 id="主要安全弱点"><a class="markdownIt-Anchor" href="#主要安全弱点"></a> <strong>主要安全弱点</strong></h2>
<p>任何“运行时解密”的方案都存在一个根本性的、无法避免的弱点：<strong>密钥和明文数据必须在某一时刻同时存在于内存中</strong>。</p>
<ul>
<li><strong>密钥暴露风险</strong>：密码通过 <code>-javaagent</code> 命令行参数传递，在服务器上，一个简单的 <code>ps -ef | grep java</code> 命令就可能使其暴露无遗。这是最直接的攻击路径。</li>
<li><strong>内存Dump攻击</strong>：攻击者可以通过 <code>jmap</code> 等工具或JVM调试器，在合适的时机Dump JVM的堆内存。理论上，解密后的字节码或密钥对象都可能从内存快照中被提取出来。</li>
<li><strong>Agent拦截攻击</strong>：更高级的攻击者可以编写自己的Java Agent，并确保它的执行顺序在 <code>class-winter</code> 的Transformer之后。这样，他们就能轻松拦截到 <code>class-winter</code> 返回的明文字节码，并将其转储到本地磁盘，从而实现对所有加密类的完美提取。</li>
</ul>
<p><strong>最终结论</strong>：<code>class-winter</code> 是一款出色的反静态分析工具，它极大地提高了逆向工程的门槛和复杂度。然而，它并非一个坚不可摧的安全堡垒。对于能够在目标系统上执行命令或附加调试器的高级攻击者来说，其保护机制可以被绕过。因此，它更适合被看作是一种有效的“代码混淆”或“增加逆向难度”的手段，而不是终极的安全解决方案。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>代码保护</category>
      </categories>
      <tags>
        <tag>Java Agent</tag>
        <tag>字节码加密</tag>
        <tag>逆向工程</tag>
        <tag>运行时解密</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 24 新特性深度解析与代码示例</title>
    <url>/2025/jdk-24-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="一-引言-introduction"><a class="markdownIt-Anchor" href="#一-引言-introduction"></a> 一、引言 (Introduction)</h2>
<p>Java Development Kit (JDK) 24 于 2025 年 3 月 18 日正式发布 [1]，带来了 Java SE 平台和 JDK 的参考实现。此版本包含了多达 24 个 JDK 增强提案 (JEPs)，是自基于时间的发布计划引入以来新特性数量最多的版本之一 [2]。这些 JEPs 涵盖了语言改进、API 增强、性能提升、安全更新以及工具优化等多个方面，旨在进一步提升开发者生产力、平台性能和安全性。本报告将对 JDK 24 中的关键新特性进行详细总结，并尽可能提供代码示例以帮助理解。</p>
<h2 id="二-jdk-24-主要特性概览-overview-of-jdk-24-main-features"><a class="markdownIt-Anchor" href="#二-jdk-24-主要特性概览-overview-of-jdk-24-main-features"></a> 二、JDK 24 主要特性概览 (Overview of JDK 24 Main Features)</h2>
<p>JDK 24 引入了众多 JEPs，其中一些是预览特性，意味着它们的设计和实现已完成，但尚未永久化，可能会在未来的版本中发生变化或被移除；另一些则是正式特性或实验性特性。下表总结了 JDK 24 中包含的主要 JEPs 及其状态：</p>
<table>
<thead>
<tr>
<th>JEP 编号</th>
<th>标题</th>
<th>类型与状态</th>
<th>核心领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>JEP 488</td>
<td>模式、instanceof 和 switch 中的基本类型 (第二次预览)</td>
<td>语言预览</td>
<td>语言特性</td>
</tr>
<tr>
<td>JEP 492</td>
<td>灵活的构造函数体 (第三次预览)</td>
<td>语言预览</td>
<td>语言特性</td>
</tr>
<tr>
<td>JEP 494</td>
<td>模块导入声明 (第二次预览)</td>
<td>语言预览</td>
<td>语言特性</td>
</tr>
<tr>
<td>JEP 495</td>
<td>简单源文件和实例主方法 (第四次预览)</td>
<td>语言预览</td>
<td>语言特性</td>
</tr>
<tr>
<td>JEP 487</td>
<td>作用域值 (第四次预览)</td>
<td>API 预览</td>
<td>核心库/并发</td>
</tr>
<tr>
<td>JEP 485</td>
<td>Stream Gatherers</td>
<td>正式特性</td>
<td>核心库/Stream API</td>
</tr>
<tr>
<td>JEP 484</td>
<td>Class-File API</td>
<td>正式特性</td>
<td>JVM/工具</td>
</tr>
<tr>
<td>JEP 450</td>
<td>紧凑对象头 (实验性)</td>
<td>JVM 实验性</td>
<td>性能/运行时</td>
</tr>
<tr>
<td>JEP 475</td>
<td>G1 的晚期屏障扩展</td>
<td>JVM</td>
<td>性能/运行时</td>
</tr>
<tr>
<td>JEP 483</td>
<td>Ahead-of-Time 类加载与链接</td>
<td>JVM</td>
<td>性能/运行时</td>
</tr>
<tr>
<td>JEP 491</td>
<td>无需固定的虚拟线程同步</td>
<td>JVM/并发</td>
<td>性能/运行时</td>
</tr>
<tr>
<td>JEP 493</td>
<td>无需 JMOD 的运行时镜像链接</td>
<td>工具</td>
<td>工具</td>
</tr>
<tr>
<td>JEP 486</td>
<td>永久禁用安全管理器</td>
<td>安全性</td>
<td>安全性</td>
</tr>
<tr>
<td>JEP 496</td>
<td>抗量子模块化格密码密钥封装机制</td>
<td>安全性</td>
<td>安全性</td>
</tr>
<tr>
<td>JEP 497</td>
<td>抗量子模块化格密码数字签名算法</td>
<td>安全性</td>
<td>安全性</td>
</tr>
<tr>
<td>JEP 498</td>
<td>警告使用 sun.misc.Unsafe 中的内存访问方法</td>
<td>JVM/安全性</td>
<td>安全性/迁移</td>
</tr>
<tr>
<td>JEP 489</td>
<td>Vector API (第九次孵化)</td>
<td>API 孵化</td>
<td>核心库/性能</td>
</tr>
<tr>
<td>JEP 404</td>
<td>分代 Shenandoah (实验性)</td>
<td>JVM 实验性</td>
<td>GC/性能</td>
</tr>
<tr>
<td>JEP 472</td>
<td>准备限制 JNI 的使用</td>
<td>JVM/安全性</td>
<td>安全性/迁移</td>
</tr>
<tr>
<td>JEP 478</td>
<td>密钥派生函数 API (预览)</td>
<td>API 预览</td>
<td>安全性</td>
</tr>
<tr>
<td>JEP 479</td>
<td>移除 Windows 32位 x86 移植</td>
<td>平台</td>
<td>平台支持</td>
</tr>
<tr>
<td>JEP 490</td>
<td>ZGC: 移除非分代模式</td>
<td>JVM/GC</td>
<td>GC/性能</td>
</tr>
</tbody>
</table>
<p><em>数据来源: [1]</em></p>
<p>这些 JEPs 共同构成了 JDK 24 的核心内容，为 Java 生态系统带来了显著的进步。</p>
<h2 id="三-语言特性预览-language-feature-previews"><a class="markdownIt-Anchor" href="#三-语言特性预览-language-feature-previews"></a> 三、语言特性预览 (Language Feature Previews)</h2>
<p>JDK 24 继续推进多个语言特性的预览，收集反馈并逐步完善。</p>
<h3 id="1-jep-488-模式-instanceof-和-switch-中的基本类型-第二次预览"><a class="markdownIt-Anchor" href="#1-jep-488-模式-instanceof-和-switch-中的基本类型-第二次预览"></a> 1. JEP 488: 模式、instanceof 和 switch 中的基本类型 (第二次预览)</h3>
<p>此 JEP 旨在增强模式匹配，允许在所有模式上下文中使用基本类型，并将 instanceof 和 switch 扩展为支持所有基本类型 [4]。这将使得对基本类型的数据探索更加统一和富有表现力。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>统一数据探索：允许对所有类型（无论是基本类型还是引用类型）使用类型模式。</li>
<li>对齐 instanceof 与安全转换：扩展 instanceof 以支持基本类型，使其能够作为安全转换的前提条件。</li>
<li>提升 switch 的表达能力：允许 switch 处理所有基本类型的值，例如 boolean、float、double 和 long [6]。</li>
</ul>
<p><strong>主要变更及代码示例</strong>:</p>
<ul>
<li>
<p>instanceof 支持基本类型模式: 以前，instanceof 模式匹配仅支持引用类型。现在，它可以检查值是否可以安全地转换为给定的基本类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JEP 488 之前，需要手动进行范围检查</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br><span class="line">    <span class="comment">//... 使用 b...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 JEP 488</span></span><br><span class="line"><span class="keyword">if</span> (i <span class="keyword">instanceof</span> <span class="type">byte</span> b) &#123;</span><br><span class="line">    <span class="comment">//... 使用 b，如果匹配，则转换无信息损失...</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Value fits in byte: &quot;</span> + b);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Value does not fit in byte.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>int i = 1000;</code>，输出将是 “Value does not fit in byte.”。如果 <code>int i = 100;</code>，则输出 “Value fits in byte: 100” [6]。</p>
</li>
<li>
<p>switch 支持所有基本类型: switch 语句和表达式现在可以处理 boolean、long、float 和 double 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boolean switch</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLoggedIn</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">accessLevel</span> <span class="operator">=</span> <span class="keyword">switch</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span> -&gt; <span class="string">&quot;User&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span> -&gt; <span class="string">&quot;Guest&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;Access Level: &quot;</span> + accessLevel); <span class="comment">// 输出: Access Level: User</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float switch</span></span><br><span class="line"><span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10.5f</span>;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0.0f</span>    -&gt; System.out.println(<span class="string">&quot;Zero&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10.5f</span>   -&gt; System.out.println(<span class="string">&quot;Ten point five&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="type">float</span> f -&gt; System.out.println(<span class="string">&quot;Other float: &quot;</span> + f); <span class="comment">// 基本类型模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Ten point five</span></span><br></pre></td></tr></table></figure>
<p>注意，case 常量必须与选择器表达式的类型相同（或其对应的包装类型），以防止有损转换。使用两个在表示上等效的浮点字面量作为 case 标签会导致编译时错误 [6]。</p>
</li>
<li>
<p>基本类型在记录模式中: 允许在记录模式中对基本类型组件进行更灵活的匹配，包括安全的窄化转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printIntCoordinates</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> ix, <span class="type">int</span> iy)</span>) &#123; <span class="comment">// 使用 int 模式匹配 double 组件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Integer coordinates: (&quot;</span> + ix + <span class="string">&quot;, &quot;</span> + iy + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Point</span><span class="params">(<span class="type">double</span> dx, <span class="type">double</span> dy)</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Double coordinates: (&quot;</span> + dx + <span class="string">&quot;, &quot;</span> + dy + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">printIntCoordinates(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10.0</span>, <span class="number">20.0</span>)); <span class="comment">// 输出: Integer coordinates: (10, 20)</span></span><br><span class="line">printIntCoordinates(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10.5</span>, <span class="number">20.3</span>)); <span class="comment">// 输出: Double coordinates: (10.5, 20.3)</span></span><br></pre></td></tr></table></figure>
<p>在此示例中，如果 Point 的 double 组件可以无损转换为 int，则 <code>Point(int ix, int iy)</code> 模式会匹配 [6]。</p>
</li>
</ul>
<p>此 JEP 的第二次预览旨在收集更多反馈，以期未来将其最终确定。</p>
<h3 id="2-jep-492-灵活的构造函数体-第三次预览"><a class="markdownIt-Anchor" href="#2-jep-492-灵活的构造函数体-第三次预览"></a> 2. JEP 492: 灵活的构造函数体 (第三次预览)</h3>
<p>JEP 492 提议允许在 Java 构造函数中，在显式构造函数调用（即 <code>super(...)</code> 或 <code>this(...)</code>）之前出现语句 [3]。这些语句不能引用正在构造的实例，但可以初始化其字段或执行其他准备工作。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>更自然地放置构造函数参数的验证或转换逻辑，避免将其拆分到静态辅助方法或辅助构造函数中 [8]。</li>
<li>提高代码可读性和可维护性。</li>
<li>在方法被重写时，通过在调用超类构造函数之前初始化字段，可以使类更加可靠 [4]。</li>
</ul>
<p>主要变更及代码示例: 构造函数体现在被分为两个阶段：<code>super(...)</code> 或 <code>this(...)</code> 调用之前的“序言”（prologue）和之后的“尾声”（epilogue）。</p>
<ul>
<li>
<p><strong>序言中的语句</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    SuperClass(String arg) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass constructor called with: &quot;</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> processedValue;</span><br><span class="line"></span><br><span class="line">    SubClass(String rawValue) &#123;</span><br><span class="line">        <span class="comment">// 序言开始</span></span><br><span class="line">        <span class="keyword">if</span> (rawValue == <span class="literal">null</span> || rawValue.trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Raw value cannot be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">processedArg</span> <span class="operator">=</span> <span class="string">&quot;[&quot;</span> + rawValue.trim() + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="comment">// 序言结束</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(processedArg); <span class="comment">// 显式构造函数调用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尾声开始</span></span><br><span class="line">        <span class="built_in">this</span>.processedValue = rawValue.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass instance initialized. Processed value: &quot;</span> + <span class="built_in">this</span>.processedValue);</span><br><span class="line">        <span class="comment">// 尾声结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">// new SubClass(&quot;  test  &quot;);</span></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// SuperClass constructor called with: [test]</span></span><br><span class="line"><span class="comment">// SubClass instance initialized. Processed value: 8</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，对 <code>rawValue</code> 的验证和处理 (<code>processedArg</code>) 发生在 <code>super(processedArg)</code> 调用之前 [9]。</p>
</li>
<li>
<p><strong>限制</strong>:</p>
<ul>
<li>序言中的语句不能通过 <code>this</code> 引用当前正在构造的实例（例如调用实例方法或访问实例字段，除非是初始化当前类声明的字段）。</li>
<li>序言中不允许 <code>return</code> 语句。</li>
<li>可以读取和写入当前类声明的字段，前提是这些字段没有自己的初始化器。在显式构造函数调用之前，不能读取任何字段（无论是当前类还是超类的）。</li>
</ul>
</li>
</ul>
<p>此 JEP 的第三次预览继续完善这一特性，目标是使构造函数的编写更加灵活和直观。</p>
<h3 id="3-jep-494-模块导入声明-第二次预览"><a class="markdownIt-Anchor" href="#3-jep-494-模块导入声明-第二次预览"></a> 3. JEP 494: 模块导入声明 (第二次预览)</h3>
<p>JEP 494 旨在通过允许简洁地导入模块导出的所有包来增强 Java 语言 [4]。这简化了模块化库的重用，且不要求导入代码本身位于模块中。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>简化模块化库的重用，允许一次性导入整个模块的 API [11]。</li>
<li>减少大量 <code>import com.foo.bar.*;</code> 声明的冗余。</li>
<li>帮助初学者更容易使用第三方库和核心 Java 类，而无需深入了解其包层次结构 [11]。</li>
</ul>
<p>主要变更及代码示例: 模块导入声明的形式为 <code>import module M;</code>。它会按需导入模块 M 导出到当前模块的所有公共顶层类和接口，以及由于读取模块 M 而导致当前模块读取的其他模块所导出的包 [11]。</p>
<ul>
<li>
<p>基本用法: 假设有一个 <code>com.example.mathutils</code> 模块，它导出了 <code>com.example.mathutils.algebra</code> 和 <code>com.example.mathutils.geometry</code> 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="comment">// import com.example.mathutils.algebra.*;</span></span><br><span class="line"><span class="comment">// import com.example.mathutils.geometry.*;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 JEP 494</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">module</span> com.example.mathutils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//可以直接使用来自 algebra 和 geometry 包的类</span></span><br><span class="line">        <span class="comment">//例如：var point = new Point2D(1,2);</span></span><br><span class="line">        <span class="comment">//例如：var matrix = new Matrix(2,2);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译和运行时需要启用预览特性：<code>javac --release 24 --enable-preview Main.java</code> 和 <code>java --enable-preview Main</code> [11]。</p>
</li>
<li>
<p>与 <code>java.base</code> 和 <code>java.se</code> 的交互: 一个重要的变更是，解除了任何模块都不能声明对 <code>java.base</code> 模块的传递依赖的限制。<code>java.se</code> 模块的声明已被修改为传递性地依赖 <code>java.base</code> 模块。因此，<code>import module java.se;</code> 现在将按需导入整个 Java SE API，包括 <code>java.base</code> 中的所有包 [11]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前可能需要:</span></span><br><span class="line"><span class="comment">// import java.util.*;</span></span><br><span class="line"><span class="comment">// import java.util.function.*;</span></span><br><span class="line"><span class="comment">// import java.util.stream.*;</span></span><br><span class="line"><span class="comment">//... 等其他 java.base 包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，如果代码在模块化环境中且该模块依赖 java.se:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">module</span> java.se; <span class="comment">// 导入整个标准 Java API</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>歧义解决: 如果不同的导入模块导出了同名单的类，编译器会报错。可以通过更具体的单类型导入声明或按需包导入声明来解决歧义，这些声明会“遮蔽”模块导入声明 [11]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">module</span> java.desktop; <span class="comment">// 导出 java.awt.List</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">module</span> java.base;    <span class="comment">// 导出 java.util.List</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import java.util.List; // 使用此声明来消除 List 的歧义，使其指向 java.util.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmbiguityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// List list; // 如果没有上面的单类型导入，这里会产生歧义错误</span></span><br><span class="line">        java.util.List&lt;String&gt; utilList = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;(); <span class="comment">// 使用全限定名</span></span><br><span class="line">        System.out.println(utilList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>此 JEP 的第二次预览旨在通过实际使用收集更多反馈，特别是在与 <code>java.se</code> 模块的交互以及导入声明的遮蔽规则方面。</p>
<h3 id="4-jep-495-简单源文件和实例主方法-第四次预览"><a class="markdownIt-Anchor" href="#4-jep-495-简单源文件和实例主方法-第四次预览"></a> 4. JEP 495: 简单源文件和实例主方法 (第四次预览)</h3>
<p>JEP 495 致力于改进 Java 语言，使初学者能够编写他们的第一个程序，而无需理解为大型程序设计的语言特性 [4]。目标是简化单类程序的声明，并允许这些程序随着开发者技能的增长无缝扩展以使用更高级的特性。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>降低 Java 的入门门槛，减少编写简单程序（如 “Hello, World!”）所需的样板代码 [13]。</li>
<li>允许主方法 (<code>main</code>) 作为实例方法存在，无需 <code>static</code> 修饰符。</li>
<li>引入“隐式声明的类”的概念，使得源文件可以直接包含方法和字段，而无需显式的 <code>class</code> 声明。</li>
<li>不引入 Java 语言的单独方言或单独的工具链 [13]。</li>
</ul>
<p><strong>主要变更及代码示例</strong>:</p>
<ul>
<li>
<p>实例主方法: <code>main</code> 方法不再强制要求是 <code>public static</code>。它可以是实例方法，甚至可以没有 <code>String[] args</code> 参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">// 实例主方法，无参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, instance main!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用源文件启动器运行：<code>java --enable-preview HelloWorld.java</code> [13]。 JVM 启动时：</p>
<ol>
<li>如果类包含带 <code>String[]</code> 参数的 <code>main</code> 方法，则选择该方法。</li>
<li>否则，如果类包含无参数的 <code>main</code> 方法，则选择该方法。</li>
<li>如果选择的方法是 <code>static</code>，则直接调用。</li>
<li>否则（实例 main 方法），类必须有一个无参数的非私有构造函数。启动器调用该构造函数创建对象，然后调用该对象的 main 方法 [13]。</li>
</ol>
</li>
<li>
<p>简单源文件 (隐式声明的类): 源文件可以直接包含方法和字段，编译器会隐式声明一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple.java</span></span><br><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello from simple source file!&quot;</span>; <span class="comment">// 隐式类的字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="comment">// 隐式类的主方法</span></span><br><span class="line">    System.out.println(greeting);</span><br><span class="line">    greet(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">greet</span><span class="params">(String name)</span> &#123; <span class="comment">// 隐式类的辅助方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Greetings, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：<code>java --enable-preview Simple.java</code> [13]。 隐式声明的类是 <code>final</code> 的，位于未命名包中，名称通常派生自文件名。它必须有一个可启动的 main 方法 [13]。</p>
</li>
<li>
<p>自动导入 <code>java.base</code> 模块和 <code>java.io.IO</code>: 为了进一步简化，简单源文件会自动导入 <code>java.base</code> 模块中的所有公共顶层类和接口（相当于 <code>import module java.base;</code>），以及 <code>java.io.IO</code> 类中的五个静态方法 (<code>println(Object)</code>, <code>println()</code>, <code>print(Object)</code>, <code>readln(String)</code>, <code>readln()</code>)（相当于 <code>import static java.io.IO.*;</code>）[13]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AutoImportDemo.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; names = List.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// List 来自 java.util (java.base)</span></span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        println(<span class="string">&quot;Name: &quot;</span> + name); <span class="comment">// println 来自 java.io.IO</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> readln(<span class="string">&quot;Enter something: &quot;</span>); <span class="comment">// readln 来自 java.io.IO</span></span><br><span class="line">    println(<span class="string">&quot;You entered: &quot;</span> + input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行：<code>java --enable-preview AutoImportDemo.java</code> [13]。</p>
</li>
</ul>
<p>这是该特性的第四次预览，表明其正朝着最终确定的方向稳步发展，目标是显著改善 Java 的初学者体验。</p>
<h3 id="5-jep-487-作用域值-第四次预览"><a class="markdownIt-Anchor" href="#5-jep-487-作用域值-第四次预览"></a> 5. JEP 487: 作用域值 (第四次预览)</h3>
<p>JEP 487 引入了作用域值（Scoped Values），这是一种在线程内及其子线程间共享不可变数据的新机制 [5]。作用域值比线程局部变量（ThreadLocal）更容易推理，并且具有更低的空间和时间成本，尤其是在与虚拟线程（JEP 444）和结构化并发（JEP 480）一起使用时 [3]。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li><strong>易用性</strong>: 使数据流更易于理解。</li>
<li><strong>可理解性</strong>: 共享数据的生命周期应从代码的句法结构中显而易见。</li>
<li><strong>健壮性</strong>: 调用者共享的数据只能由合法的被调用者检索。</li>
<li><strong>性能</strong>: 高效地在大量线程间共享数据，读取作用域值的成本通常与读取局部变量相当 [14]。</li>
<li><strong>不可变性和有界生命周期</strong>: 与可变的 ThreadLocal 不同，作用域值一次写入后，仅在线程执行的特定有界时段内可用，避免了与 ThreadLocal 相关的内存泄漏风险 [14]。</li>
</ul>
<p>主要变更及代码示例: <code>ScopedValue</code> 实例通常声明为 <code>static final</code>。通过 <code>ScopedValue.where(scopedValue, value).run(() -&gt; &#123;... &#125;)</code> 或 <code>.call(() -&gt; &#123;... &#125;)</code> 来绑定值并在特定作用域内执行代码。</p>
<ul>
<li>
<p><strong>基本用法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.ScopedValue.where; <span class="comment">// 可以静态导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopedValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; USER_CONTEXT = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 绑定 USER_CONTEXT 的值并执行操作</span></span><br><span class="line">        where(USER_CONTEXT, <span class="string">&quot;UserA&quot;</span>)</span><br><span class="line">           .run(() -&gt; processRequest());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在此作用域之外，USER_CONTEXT.get() 会抛出异常</span></span><br><span class="line">        <span class="comment">// System.out.println(USER_CONTEXT.get()); //会抛出 NoSuchElementException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Processing request for: &quot;</span> + USER_CONTEXT.get()); <span class="comment">// &quot;UserA&quot;</span></span><br><span class="line">        logActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">logActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 即使在深层调用栈中，也能访问到绑定的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Logging activity for: &quot;</span> + USER_CONTEXT.get()); <span class="comment">// &quot;UserA&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[14]</p>
</li>
<li>
<p>嵌套作用域和重新绑定: 被调用者可以为同一个 <code>ScopedValue</code> 建立新的嵌套绑定，以向其自身的被调用者传递不同的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NestedScopedValueExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScopedValue&lt;String&gt; TRANSACTION_ID = ScopedValue.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        where(TRANSACTION_ID, <span class="string">&quot;TXN-MAIN-001&quot;</span>).run(() -&gt; handleOuterTask());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleOuterTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer task, TXN ID: &quot;</span> + TRANSACTION_ID.get()); <span class="comment">// TXN-MAIN-001</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为内部任务重新绑定 TRANSACTION_ID</span></span><br><span class="line">        where(TRANSACTION_ID, <span class="string">&quot;TXN-INNER-123&quot;</span>).run(() -&gt; handleInnerTask());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部任务结束后，TRANSACTION_ID 恢复为外部任务的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Back to outer task, TXN ID: &quot;</span> + TRANSACTION_ID.get()); <span class="comment">// TXN-MAIN-001</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleInnerTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inner task, TXN ID: &quot;</span> + TRANSACTION_ID.get()); <span class="comment">// TXN-INNER-123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[14]</p>
</li>
<li>
<p>与结构化并发的集成: 通过 <code>StructuredTaskScope</code> 创建的子线程会自动继承父线程中的作用域值，开销极小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 USER_CONTEXT 已在父线程中通过 where().run() 绑定</span></span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">handle</span><span class="params">(Request request, Response response)</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">       Supplier&lt;UserInfo&gt; user = scope.fork(() -&gt; &#123;</span><br><span class="line">           此处可以访问 USER_CONTEXT.get()</span><br><span class="line">           <span class="keyword">return</span> readUserInfo();</span><br><span class="line">       &#125;);</span><br><span class="line">       Supplier&lt;List&lt;Offer&gt;&gt; offers = scope.fork(() -&gt; &#123;</span><br><span class="line">           此处也可以访问 USER_CONTEXT.get()</span><br><span class="line">           <span class="keyword">return</span> fetchOffers();</span><br><span class="line">       &#125;);</span><br><span class="line">       scope.join().throwIfFailed();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(user.get(), offers.get());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="comment">/*... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[14]</p>
</li>
</ul>
<p>JEP 487 的第四次预览主要移除了 <code>ScopedValue</code> 类中的 <code>callWhere</code> 和 <code>runWhere</code> 方法，使得 API 完全流畅，所有绑定操作都通过 <code>ScopedValue.Carrier.call</code> 和 <code>ScopedValue.Carrier.run</code> (或静态导入的 <code>where(...).call/run</code>) 进行 [14]。这表明该特性正趋于稳定。</p>
<hr />
<h2 id="四-正式特性-finalized-features"><a class="markdownIt-Anchor" href="#四-正式特性-finalized-features"></a> 四、正式特性 (Finalized Features)</h2>
<p>JDK 24 将一些先前预览或孵化的特性最终确定为正式特性。</p>
<h3 id="1-jep-485-stream-gatherers"><a class="markdownIt-Anchor" href="#1-jep-485-stream-gatherers"></a> 1. JEP 485: Stream Gatherers</h3>
<p>JEP 485 在经过 JDK 22 (JEP 461) 和 JDK 23 (JEP 473) 的两轮预览后，正式引入了 Stream Gatherers [16]。它通过支持自定义中间操作来增强 Stream API，使得流管道能够以现有内置中间操作难以实现的方式转换数据 [5]。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>使流管道更加灵活和富有表现力。</li>
<li>允许自定义中间操作处理无限大小的流 [17]。</li>
<li>解决现有 Stream API 在表达某些复杂转换（如按自定义条件去重 distinctBy，或创建固定/滑动窗口 windowFixed/windowSliding）时的局限性 [17]。</li>
</ul>
<p>核心概念与代码示例: <code>Stream::gather(Gatherer)</code> 是一个新的中间流操作，它应用一个用户定义的 <code>Gatherer</code> 实例来处理流元素。<code>Gatherer</code> 接口类似于 <code>Collector</code> 接口，但用于中间操作 [17]。 一个 <code>Gatherer</code> 由四个函数定义：</p>
<ul>
<li><strong>initializer (可选)</strong>: 提供一个在处理流元素时维护私有状态的对象。</li>
<li><strong>integrator</strong>: 集成输入流中的新元素，可能会检查私有状态对象，并可能向输出流发出元素。它可以提前终止处理。</li>
<li><strong>combiner (可选)</strong>: 用于在输入流标记为并行时并行评估收集器。</li>
<li><strong>finisher (可选)</strong>: 在没有更多输入元素时调用，可以检查私有状态并可能发出额外的输出元素。</li>
</ul>
<p>[17]</p>
<ul>
<li>
<p><strong>内置 Gatherers</strong>: <code>java.util.stream.Gatherers</code> 类提供了一些有用的预定义 gatherers，例如：</p>
<ul>
<li>
<p><strong>windowFixed(int windowSize)</strong>: 将流元素分组为固定大小的不重叠列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherers;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; fixedWindows = IntStream.range(<span class="number">0</span>, <span class="number">10</span>).boxed()</span><br><span class="line">   .gather(Gatherers.windowFixed(<span class="number">3</span>))</span><br><span class="line">   .toList();</span><br><span class="line"><span class="comment">// 输出: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]</span></span><br><span class="line">System.out.println(<span class="string">&quot;Fixed windows: &quot;</span> + fixedWindows);</span><br></pre></td></tr></table></figure>
<p>[18]</p>
</li>
<li>
<p><strong>windowSliding(int windowSize)</strong>: 创建流元素的滑动窗口列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherers;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; slidingWindows = IntStream.range(<span class="number">0</span>, <span class="number">5</span>).boxed()</span><br><span class="line">   .gather(Gatherers.windowSliding(<span class="number">3</span>))</span><br><span class="line">   .toList();</span><br><span class="line"><span class="comment">// 输出: [[0, 1, 2], [1, 2, 3], [2, 3, 4]]</span></span><br><span class="line">System.out.println(<span class="string">&quot;Sliding windows: &quot;</span> + slidingWindows);</span><br></pre></td></tr></table></figure>
<p>[18]</p>
</li>
<li>
<p><strong>fold(Supplier<R> initialValue, BiFunction&lt;R,? super T, R&gt; folder)</strong>: 执行左折叠操作，但只发出最终结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherers;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算数字流的总和</span></span><br><span class="line">Optional&lt;Integer&gt; sum = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">   .gather(Gatherers.fold(() -&gt; <span class="number">0</span>, (acc, val) -&gt; acc + val))</span><br><span class="line">   .findFirst();</span><br><span class="line"><span class="comment">// 输出: Optional[15]</span></span><br><span class="line">sum.ifPresent(s -&gt; System.out.println(<span class="string">&quot;Fold sum: &quot;</span> + s));</span><br></pre></td></tr></table></figure>
<p>[18]</p>
</li>
<li>
<p><strong>scan(Supplier<R> initialValue, BiFunction&lt;R,? super T, R&gt; scanner)</strong>: 类似于 fold，但发出所有中间累积结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherers;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算累积和</span></span><br><span class="line">List&lt;Integer&gt; scannedSums = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">       .gather(Gatherers.scan(() -&gt; <span class="number">0</span>, (acc, val) -&gt; acc + val)) <span class="comment">// 假设初始值参与到第一个结果中</span></span><br><span class="line">       .toList();</span><br><span class="line">System.out.println(<span class="string">&quot;Scanned sums: &quot;</span> + scannedSums); <span class="comment">// 预期: [1, 3, 6, 10, 15]</span></span><br></pre></td></tr></table></figure>
<p>说明：根据 JEP 485 和 javaalmanac 的例子 [18]，<code>scan</code> 通常包含初始值在结果中，或者行为略有不同。上面的代码是根据描述模拟的常见 scan 行为，即发出每个累积结果。</p>
</li>
</ul>
</li>
<li>
<p><strong>自定义 Gatherer 示例 (去重相邻元素)</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherer;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Gatherers;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistinctAdjacent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Gatherer&lt;T,?, T&gt; distinctAdjacent() &#123;</span><br><span class="line">        <span class="comment">// 状态对象，用于存储前一个元素</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">previous</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Gatherer.&lt;T, State, T&gt;ofSequential(</span><br><span class="line">            State::<span class="keyword">new</span>, <span class="comment">// Initializer</span></span><br><span class="line">            (state, element, downstream) -&gt; &#123; <span class="comment">// Integrator</span></span><br><span class="line">                <span class="keyword">if</span> (state.first || !Objects.equals(state.previous, element)) &#123;</span><br><span class="line">                    state.previous = element;</span><br><span class="line">                    state.first = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> downstream.push(element); <span class="comment">// 推送非重复元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 继续处理，但不推送重复元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; result = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">           .gather(distinctAdjacent())</span><br><span class="line">           .toList();</span><br><span class="line">        System.out.println(result); <span class="comment">// 输出: [a, b, c, a, d]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例创建了一个 <code>Gatherer</code>，它只传递与前一个元素不同的元素 [18]。</p>
</li>
</ul>
<p>Stream Gatherers 为开发者提供了强大的工具来定制流处理逻辑，使得 Stream API 更加灵活和富有表现力。</p>
<h3 id="2-jep-484-class-file-api"><a class="markdownIt-Anchor" href="#2-jep-484-class-file-api"></a> 2. JEP 484: Class-File API</h3>
<p>JEP 484 提供了一个用于解析、生成和转换 Java 类文件的标准 API [5]。此 API 位于 <code>java.lang.classfile</code> 包及其子包中，经过 JDK 22 (JEP 457) 和 JDK 23 (JEP 466) 的预览后，在 JDK 24 中最终确定 [21]。</p>
<p><strong>目标与动机</strong>:</p>
<ul>
<li>为需要以编程方式操作类文件的框架、库和工具（如字节码操作库 ASM、ByteBuddy，或编译器、分析器）提供一个官方支持的、现代的 API。</li>
<li>取代 JDK 内部的、非标准的类文件处理能力。</li>
<li>API 设计原则包括：不可变对象、树状结构表示、用户驱动导航、懒加载、统一的流式和物化视图、自动处理底层细节（如常量池、栈图）、并利用现代 Java 语言特性（如 lambda、record、sealed class、模式匹配）[21]。</li>
</ul>
<p>核心概念与代码示例: API 主要围绕三个核心抽象：元素 (Elements)、构建器 (Builders) 和转换 (Transforms)。</p>
<ul>
<li>
<p><strong>元素 (Elements)</strong>: 类文件各部分的不可变描述，如指令、属性、字段、方法。</p>
</li>
<li>
<p><strong>构建器 (Builders)</strong>: 用于创建复合元素，如 <code>ClassBuilder</code>、<code>MethodBuilder</code>、<code>CodeBuilder</code>。</p>
</li>
<li>
<p><strong>转换 (Transforms)</strong>: 表示将一个元素转换为其他元素的函数。</p>
</li>
<li>
<p>生成类文件示例 (HelloWorld): 以下示例展示了如何使用 Class-File API 生成一个简单的 HelloWorld 类，该类包含一个打印 “Hello, Class-File API!” 的 main 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.lang.classfile.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.classfile.attribute.SourceFileAttribute;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.classfile.ClassFile.*; <span class="comment">// 静态导入 Opcode, AccessFlags 等</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.constant.ConstantDescs.*; <span class="comment">// 静态导入 CD_System, CD_PrintStream 等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;HelloWorldGenerated&quot;</span>;</span><br><span class="line">        <span class="type">Path</span> <span class="variable">classFilePath</span> <span class="operator">=</span> Path.of(className + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] classBytes = ClassFile.of().build(ClassDesc.of(className), classBuilder -&gt; &#123;</span><br><span class="line">            classBuilder.withFlags(ACC_PUBLIC | ACC_SUPER); <span class="comment">// public class HelloWorldGenerated</span></span><br><span class="line">            classBuilder.with(SourceFileAttribute.of(className + <span class="string">&quot;.java&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加默认构造函数 public HelloWorldGenerated()</span></span><br><span class="line">            classBuilder.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, code -&gt; code</span><br><span class="line">                   .aload(<span class="number">0</span>) <span class="comment">// this</span></span><br><span class="line">                   .invokespecial(CD_Object, INIT_NAME, MTD_void) <span class="comment">// super()</span></span><br><span class="line">                   .return_()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加 public static void main(String args)</span></span><br><span class="line">            classBuilder.withMethodBody(<span class="string">&quot;main&quot;</span>, MethodTypeDesc.of(CD_void, CD_String.arrayType()),</span><br><span class="line">                    ACC_PUBLIC | ACC_STATIC, code -&gt; code</span><br><span class="line">                   .getstatic(CD_System, <span class="string">&quot;out&quot;</span>, CD_PrintStream) <span class="comment">// System.out</span></span><br><span class="line">                   .ldc(<span class="string">&quot;Hello, Class-File API!&quot;</span>) <span class="comment">// 加载字符串常量</span></span><br><span class="line">                   .invokevirtual(CD_PrintStream, <span class="string">&quot;println&quot;</span>, MethodTypeDesc.of(CD_void, CD_String)) <span class="comment">// out.println(...)</span></span><br><span class="line">                   .return_()</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Files.write(classFilePath, classBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;Generated class file: &quot;</span> + classFilePath.toAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行 <code>GenerateHelloWorld</code> 后，会生成 <code>HelloWorldGenerated.class</code> 文件。可以使用 <code>java HelloWorldGenerated</code> 来执行它，输出 “Hello, Class-File API!” [21]。</p>
</li>
<li>
<p>转换类文件示例 (重命名方法中的类引用): 假设我们想将一个类中所有对 <code>Foo</code> 类的调用重定向到 <code>Bar</code> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设我们有 classBytes (byte[] of a class to transform)</span></span><br><span class="line"><span class="type">ClassFile</span> <span class="variable">cf</span> <span class="operator">=</span> ClassFile.of();</span><br><span class="line"><span class="type">ClassModel</span> <span class="variable">classModel</span> <span class="operator">=</span> cf.parse(classBytes);</span><br><span class="line"></span><br><span class="line"><span class="type">CodeTransform</span> <span class="variable">codeTransform</span> <span class="operator">=</span> (codeBuilder, codeEntry) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (codeEntry <span class="keyword">instanceof</span> InvokeInstruction instr</span><br><span class="line">            &amp;&amp; instr.owner().asInternalName().equals(<span class="string">&quot;Foo&quot;</span>)) &#123;</span><br><span class="line">        codeBuilder.invoke(instr.opcode(), ClassDesc.of(<span class="string">&quot;Bar&quot;</span>),</span><br><span class="line">                           instr.name().stringValue(), instr.typeSymbol(), instr.isInterface());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        codeBuilder.accept(codeEntry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">MethodTransform</span> <span class="variable">methodTransform</span> <span class="operator">=</span> MethodTransform.transformingCode(codeTransform);</span><br><span class="line"><span class="type">ClassTransform</span> <span class="variable">classTransform</span> <span class="operator">=</span> ClassTransform.transformingMethods(methodTransform);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] newBytes = cf.transform(classModel, classTransform);</span><br><span class="line">Files.write(Path.of(<span class="string">&quot;TransformedClass.class&quot;</span>), newBytes);</span><br></pre></td></tr></table></figure>
<p>此示例（概念性，具体实现细节参考 JEP 文档）展示了如何定义转换逻辑，并将其应用于类模型以生成新的类文件字节 [21]。</p>
</li>
</ul>
<p>Class-File API 为 Java 生态系统中的工具开发者提供了一个强大且标准化的方式来处理字节码，有望促进相关工具的创新和发展。</p>
<hr />
<h2 id="五-性能-运行时和工具增强-performance-runtime-and-tooling-enhancements"><a class="markdownIt-Anchor" href="#五-性能-运行时和工具增强-performance-runtime-and-tooling-enhancements"></a> 五、性能、运行时和工具增强 (Performance, Runtime, and Tooling Enhancements)</h2>
<p>JDK 24 在 JVM 性能、垃圾收集、启动速度以及并发模型方面带来了多项重要改进。</p>
<h3 id="1-jep-450-紧凑对象头-实验性"><a class="markdownIt-Anchor" href="#1-jep-450-紧凑对象头-实验性"></a> 1. JEP 450: 紧凑对象头 (实验性)</h3>
<p>JEP 450 提议在 64 位架构的 HotSpot JVM 中将对象头的大小从 96-128 位减少到 64 位 [4]。这是一个实验性特性，默认禁用 [16]。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>减少堆大小</strong>: 对象头变小直接导致 Java 堆中对象占用的内存减少。</li>
<li><strong>提高部署密度</strong>: 内存占用降低有助于在相同硬件上部署更多应用实例。</li>
<li><strong>改善数据局部性</strong>: 更紧凑的对象可能带来更好的缓存利用率和数据局部性。</li>
</ul>
<p>此特性灵感来源于 Project Lilliput [16]。由于是实验性的，启用它可能会导致意外后果，需要谨慎测试 [16]。</p>
<h3 id="2-jep-475-g1-的晚期屏障扩展"><a class="markdownIt-Anchor" href="#2-jep-475-g1-的晚期屏障扩展"></a> 2. JEP 475: G1 的晚期屏障扩展</h3>
<p>JEP 475 旨在简化 G1 垃圾收集器屏障的实现 [4]。G1 的写屏障用于记录应用程序对内存的访问，以便进行并发标记。此 JEP 将屏障代码的扩展从 C2 JIT 编译管道的早期阶段移至后期。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>简化 G1 实现</strong>: 减少 G1 实现的复杂性。</li>
<li><strong>潜在的性能改进</strong>: 虽然主要目标是简化，但更晚的扩展可能为编译器优化提供更多机会，或减少编译时开销。</li>
</ul>
<h3 id="3-jep-483-ahead-of-time-类加载与链接"><a class="markdownIt-Anchor" href="#3-jep-483-ahead-of-time-类加载与链接"></a> 3. JEP 483: Ahead-of-Time 类加载与链接</h3>
<p>JEP 483 旨在通过在 HotSpot JVM 启动时使应用程序的类以已加载和链接的状态立即可用来改善启动时间 [2]。</p>
<p><strong>实现方式与影响</strong>:</p>
<ul>
<li>通过在一次运行期间监控应用程序，并将所有已加载和链接的类的形式存储在缓存中，供后续运行使用 [4]。</li>
<li>这避免了每次应用程序启动时重复加载、验证和链接类文件的开销，从而减少“预热”时间并提高启动性能 [2]。</li>
<li>此特性是更广泛的 Project Leyden 的一部分，该项目旨在全面解决 Java 应用程序启动时间问题 [2]。它建立在 JDK 11 中引入的应用程序类数据共享 (AppCDS) 的基础上 [2]。</li>
<li>为未来进一步改进启动时间和预热时间奠定基础 [4]。</li>
</ul>
<h3 id="4-jep-491-无需固定的虚拟线程同步"><a class="markdownIt-Anchor" href="#4-jep-491-无需固定的虚拟线程同步"></a> 4. JEP 491: 无需固定的虚拟线程同步</h3>
<p>JEP 491 旨在通过安排在 synchronized 方法和语句中阻塞的虚拟线程释放其底层平台线程，以供其他虚拟线程使用，从而提高使用这些构造的 Java 代码的可伸缩性 [2]。这将消除几乎所有虚拟线程被“固定”到平台线程的情况，这种固定会严重限制可用于处理应用程序工作负载的虚拟线程数量 [4]。</p>
<p>背景与动机: 虚拟线程（JEP 444, JDK 21 引入）旨在提高通常使用“每请求一线程”模型的应用程序的可伸缩性。然而，当虚拟线程在 <code>synchronized</code> 块或方法内阻塞时，它会“固定”其承载的平台线程，阻止该平台线程被其他虚拟线程使用 [2]。这是因为 <code>synchronized</code> 使用的监视器（monitor）与平台线程关联，而不是虚拟线程 [2]。</p>
<p><strong>主要变更与影响</strong>:</p>
<ul>
<li>JEP 491 修改了 JVM 对 <code>synchronized</code> 关键字的实现，将监视器与虚拟线程关联，而不是平台线程 [2]。</li>
<li>虚拟线程现在可以在 <code>synchronized</code> 方法或语句内部、或在等待监视器时，自由地挂载（mount）和卸载（unmount）其承载平台线程 [24]。</li>
<li>当虚拟线程因获取监视器或调用 <code>Object.wait()</code> 而阻塞时，它将卸载并释放其承载平台线程 [24]。</li>
<li>显著增强了虚拟线程的可伸缩性，使得大量现有使用 <code>synchronized</code> 的代码能够更好地利用虚拟线程带来的优势，而无需重构为使用 <code>java.util.concurrent.locks</code> [2]。</li>
<li>对于新代码，开发者可以根据便利性和功能需求在 <code>synchronized</code> 和 <code>java.util.concurrent.locks</code> 之间进行选择，而不再主要因为 pinning 问题而避免 <code>synchronized</code> [24]。</li>
</ul>
<p><strong>代码影响示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 之前可能导致 pinning 的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedResource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">accessResource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这里有一个长时间的 I/O 操作，例如 socket.read()</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot; accessing, data = &quot;</span> + data);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟阻塞操作</span></span><br><span class="line">            data++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用虚拟线程调用</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    <span class="type">SharedResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedResource</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        executor.submit(() -&gt; resource.accessResource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 JEP 491 之前，如果 accessResource 方法中的操作导致虚拟线程阻塞，承载的平台线程也会被阻塞。JEP 491 之后，虚拟线程在阻塞时可以释放平台线程，从而允许更多虚拟线程并发执行，即使它们都使用了 synchronized 方法 [24]。</p>
<h3 id="5-jep-493-无需-jmod-的运行时镜像链接"><a class="markdownIt-Anchor" href="#5-jep-493-无需-jmod-的运行时镜像链接"></a> <strong>5. JEP 493: 无需 JMOD 的运行时镜像链接</strong></h3>
<p>JEP 493 允许 jlink 工具创建自定义运行时镜像，而无需使用 JDK 的 JMOD 文件 [1]。这可以通过在构建 JDK 时启用一个特定选项来实现，并且可能使 JDK 的大小减少约 25% [3]。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>减小 JDK 大小</strong>: 对于希望分发更小 JDK 或自定义运行时的开发者和供应商来说，这是一个显著的改进。</li>
<li><strong>提高效率</strong>: 简化了创建自定义运行时的过程。</li>
<li>需要注意的是，此特性需要在构建 JDK 时启用，并非所有 JDK 供应商都可能选择启用它 [3]。</li>
</ul>
<h2 id="六-安全增强-security-enhancements"><a class="markdownIt-Anchor" href="#六-安全增强-security-enhancements"></a> 六、安全增强 (Security Enhancements)</h2>
<p>JDK 24 在安全性方面也做出了重要更新，包括移除过时的安全机制和为后量子密码时代做准备。</p>
<h3 id="1-jep-486-永久禁用安全管理器"><a class="markdownIt-Anchor" href="#1-jep-486-永久禁用安全管理器"></a> 1. JEP 486: 永久禁用安全管理器</h3>
<p>JEP 486 永久禁用了自 Java 1.0 以来就存在的安全管理器 (Security Manager) [1]。安全管理器最初设计用于在执行远程加载的代码（如 Applet）时提供沙箱环境，但早已不再是客户端 Java 的主要安全手段，也很少用于保护服务器端代码 [2]。它在 JDK 17 中已被弃用。</p>
<p><strong>影响</strong>:</p>
<ul>
<li><strong>移除过时组件</strong>: 减少了 JDK 的维护负担。</li>
<li><strong>迁移挑战</strong>: 依赖安全管理器的应用程序需要进行重大的架构更改和代码重写才能迁移到 JDK 24 及更高版本，因为没有提供直接的替代方案 [2]。</li>
<li>Applet 和浏览器插件已在 JDK 11 中移除，进一步降低了安全管理器的相关性 [2]。</li>
</ul>
<h3 id="2-jep-496-抗量子模块化格密码密钥封装机制"><a class="markdownIt-Anchor" href="#2-jep-496-抗量子模块化格密码密钥封装机制"></a> 2. JEP 496: 抗量子模块化格密码密钥封装机制</h3>
<p>JEP 496 通过提供抗量子模块化格密码密钥封装机制 (ML-KEM, Module-Lattice-based Key-Encapsulation Mechanism) 的实现来增强 Java 应用程序的安全性 [1]。ML-KEM 已由 NIST 标准化为 FIPS 203。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>后量子密码准备</strong>: 这是 Java 平台为应对未来量子计算机对现有公钥密码体系构成威胁而迈出的重要一步 [10]。</li>
<li><strong>安全密钥交换</strong>: KEM 用于通过公钥密码在不安全的通信渠道上安全地交换对称密钥 [3]。</li>
<li>将通过实现 Java <code>KeyPairGenerator</code>、<code>KEM</code> 和 <code>KeyFactory</code> 类来完成 [27]。</li>
</ul>
<h3 id="3-jep-497-抗量子模块化格密码数字签名算法"><a class="markdownIt-Anchor" href="#3-jep-497-抗量子模块化格密码数字签名算法"></a> 3. JEP 497: 抗量子模块化格密码数字签名算法</h3>
<p>JEP 497 实现了抗量子的模块化格密码数字签名算法 (ML-DSA, Module-Lattice-Based Digital Signature Algorithm)，该算法已由 NIST 标准化为 FIPS 204 [1]。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>增强数据完整性和身份验证</strong>: 数字签名用于检测数据是否被未经授权地修改，并验证签名者的身份 [3]。</li>
<li><strong>后量子密码支持</strong>: 与 JEP 496 一样，这是 Java 平台为支持后量子密码 (PQC) 所做的重要准备 [10]。</li>
<li>将通过实现 Java <code>KeyPairGenerator</code>、<code>Signature</code> 和 <code>KeyFactory</code> 类来完成 [16]。</li>
</ul>
<h3 id="4-jep-498-警告使用-sunmiscunsafe-中的内存访问方法"><a class="markdownIt-Anchor" href="#4-jep-498-警告使用-sunmiscunsafe-中的内存访问方法"></a> 4. JEP 498: 警告使用 sun.misc.Unsafe 中的内存访问方法</h3>
<p>JEP 498 规定，当使用 <code>sun.misc.Unsafe</code> 中已弃用的内存访问方法时，JVM 将发出警告 [1]。这些方法计划在未来版本中被完全移除。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>推动迁移</strong>: 鼓励开发者从不安全的、内部的 <code>sun.misc.Unsafe</code> API 迁移到标准的、受支持的 API，如 VarHandle API 和 Foreign Function &amp; Memory API (FFM API) [2]。</li>
<li><strong>提高安全性与稳定性</strong>: 减少对内部 API 的依赖有助于提高 Java 应用程序的长期稳定性和安全性。</li>
</ul>
<hr />
<h2 id="七-孵化器和实验性特性-incubator-and-other-experimental-features"><a class="markdownIt-Anchor" href="#七-孵化器和实验性特性-incubator-and-other-experimental-features"></a> 七、孵化器和实验性特性 (Incubator and Other Experimental Features)</h2>
<p>除了预览特性，JDK 24 还包含孵化阶段和进一步的实验性特性。</p>
<h3 id="1-jep-489-vector-api-第九次孵化"><a class="markdownIt-Anchor" href="#1-jep-489-vector-api-第九次孵化"></a> 1. JEP 489: Vector API (第九次孵化)</h3>
<p>Vector API 旨在提供一种表达向量计算的方式，这些计算能够在运行时可靠地编译为支持的 CPU 架构上的最佳向量指令，从而实现优于等效标量计算的性能 [16]。此 JEP 是该 API 的第九次孵化，整合了前八轮孵化的反馈。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>提升计算密集型应用性能</strong>: 特别适用于科学计算、机器学习、数据分析等领域。</li>
<li><strong>持续演进</strong>: Vector API 将继续孵化，直到 Project Valhalla 的必要特性作为预览特性可用。届时，Vector API 将适配这些特性并从孵化阶段提升到预览阶段 [16]。</li>
</ul>
<h3 id="2-jep-404-分代-shenandoah-实验性"><a class="markdownIt-Anchor" href="#2-jep-404-分代-shenandoah-实验性"></a> 2. JEP 404: 分代 Shenandoah (实验性)</h3>
<p>JEP 404 提议为 Shenandoah 垃圾收集器提供一个实验性的分代模式，目标是在未来的 JDK 版本中使其成为默认模式，同时不破坏非分代 Shenandoah GC [1]。该 JEP 最初计划用于 JDK 21，但由于审查过程中发现的风险和时间不足而推迟 [16]。</p>
<p><strong>目标与影响</strong>:</p>
<ul>
<li><strong>改进 GC 性能</strong>: 分代垃圾收集通常可以为具有特定分配模式的应用程序（例如，大量短暂对象）提供更好的吞吐量和更低的停顿时间。</li>
<li><strong>Shenandoah 的演进</strong>: 这是 Shenandoah GC 发展的一个重要方向，旨在结合其低停顿特性和分代收集的优势。</li>
</ul>
<hr />
<h2 id="八-核心库更新-core-library-updates"><a class="markdownIt-Anchor" href="#八-核心库更新-core-library-updates"></a> 八、核心库更新 (Core Library Updates)</h2>
<p>除了 JEPs 驱动的主要特性外，JDK 24 的核心库也进行了一些更新。</p>
<h3 id="1-unicode-支持更新-unicode-support-updates"><a class="markdownIt-Anchor" href="#1-unicode-支持更新-unicode-support-updates"></a> 1. Unicode 支持更新 (Unicode Support Updates)</h3>
<ul>
<li><code>java.lang.Character</code> 类支持 Unicode 字符数据库 16.0，新增 5,185 个字符，总计达到 154,998 个字符。新增内容包括七个新脚本，如 Garay（西非现代用脚本）、Gurung Khema、Kirat Rai、Ol Onal、Sunuwar（印度东北部和尼泊尔的现代用脚本）、Todhri（阿尔巴尼亚历史脚本）和 Tulu-Tigalari（印度西南部历史脚本）[3]。</li>
<li><code>java.text.Bidi</code> 和 <code>java.text.Normalizer</code> 类分别支持 Unicode 标准附件 #9 和 #15 [4]。</li>
<li><code>java.util.regex</code> 包支持基于 Unicode 标准附件 #29 的扩展字形集群 [4]。</li>
</ul>
<p><strong>影响</strong>: 这些更新增强了 Java 对全球各种语言和字符集的国际化支持，确保了与最新 Unicode 标准的兼容性。</p>
<h3 id="2-其他api新增增强-other-minor-api-additionsenhancements"><a class="markdownIt-Anchor" href="#2-其他api新增增强-other-minor-api-additionsenhancements"></a> 2. 其他API新增/增强 (Other Minor API Additions/Enhancements)</h3>
<p>JDK 24 还包含一些实用性的 API 新增和增强 [3]：</p>
<ul>
<li>
<p><strong>Reader.of(CharSequence)</strong>: 新增静态方法，用于创建一个从给定 CharSequence 读取字符的 Reader 实例。</p>
</li>
<li>
<p><strong>Process.waitFor(Duration)</strong>: Process 类新增了带有超时参数的 waitFor 方法，允许在等待进程终止时指定一个最长等待时间。</p>
</li>
<li>
<p><strong>jar 工具增强</strong>:</p>
<ul>
<li>新增 <code>-C &lt;dir&gt;</code> 选项，允许在提取 (<code>-x</code> 或 <code>--extract</code>) JAR 文件时指定目标目录。</li>
<li>新增 <code>--no-overwrite</code> 选项，用于在提取时防止覆盖现有文件。</li>
</ul>
</li>
<li>
<p><strong>TLS 密码套件禁用机制</strong>: 现在可以通过在 <code>java.security</code> 配置文件的 <code>jdk.tls.disabledAlgorithms</code> 安全属性中使用通配符（例如 “TLS_RSA_*”）来禁用匹配模式的 TLS 密码套件。</p>
</li>
<li>
<p><strong>虚拟线程监控与管理</strong>:</p>
<ul>
<li>新增 MXBean (<code>jdk.management.neuesten.VirtualThreadMXBean</code>) 用于监视和管理虚拟线程调度器。</li>
<li>新增 jcmd 命令 <code>Thread.vthread_scheduler</code> 和 <code>Thread.vthread_pollers</code>，提供对虚拟线程调度和轮询器状态的诊断。</li>
</ul>
</li>
<li>
<p><strong>安全属性文件包含</strong>: 支持在安全属性文件中包含其他属性文件。</p>
</li>
</ul>
<p><strong>影响</strong>: 这些更新虽然不像 JEP 那样引人注目，但它们为开发者提供了更多便利，增强了 JDK 的可管理性和可观察性，并改进了特定场景下的开发体验。</p>
<hr />
<h2 id="九-总结与展望-conclusion-and-outlook"><a class="markdownIt-Anchor" href="#九-总结与展望-conclusion-and-outlook"></a> 九、总结与展望 (Conclusion and Outlook)</h2>
<p>JDK 24 作为一个重要的版本，通过其包含的 24 个 JEPs，在多个方面推动了 Java 平台的进步。</p>
<p><strong>JDK 24 主要贡献回顾</strong></p>
<p>此版本显著提升了开发者生产力，特别是通过语言层面的简化（如简单源文件和实例主方法、灵活的构造函数体、模块导入声明的预览）和 Stream API 的增强（Stream Gatherers）。在性能方面，Ahead-of-Time 类加载与链接、无需固定的虚拟线程同步以及对 G1 和 Shenandoah GC 的改进，都旨在优化 Java 应用的启动速度、运行时效率和可伸缩性。安全性方面，永久禁用安全管理器标志着一个时代的结束，而抗量子密码算法的引入则为 Java 的未来安全奠定了基础。</p>
<p><strong>对开发者的关键益处</strong></p>
<ul>
<li><strong>更低的入门门槛和更简洁的编程体验</strong>: 对于初学者和编写小型实用程序而言，Java 变得更加友好。</li>
<li><strong>并发应用的可伸缩性提升</strong>: 依赖 <code>synchronized</code> 的现有并发应用程序在迁移到虚拟线程时，有望获得更好的性能和伸缩性。</li>
<li><strong>更强大的数据处理能力</strong>: Stream Gatherers 提供了前所未有的灵活性来定制流操作。</li>
<li><strong>标准化的字节码操作</strong>: Class-File API 为工具开发者提供了坚实的基础。</li>
<li><strong>面向未来的安全性</strong>: 为应对量子计算带来的挑战做好了初步准备。</li>
</ul>
<p><strong>展望未来</strong></p>
<p>JDK 24 中的许多预览特性，如模式匹配中的基本类型、灵活构造函数体、模块导入声明、简单源文件、作用域值以及 Vector API，都有望在未来的 JDK 版本中（如 JDK 25 [28]）得到进一步完善并最终确定。Project Loom（虚拟线程、结构化并发、作用域值）、Project Valhalla（值对象、基本类型泛型）、Project Leyden（静态镜像、优化启动）和 Project Lilliput（紧凑对象头）等长期项目将继续驱动 Java 平台的演进。Java 社区可以期待在语言特性、性能优化、并发模型和平台安全性等方面的持续创新和改进。JDK 24 的发布再次证明了 Java 平台致力于满足现代应用开发需求的承诺。</p>
<hr />
<h2 id="引用的著作"><a class="markdownIt-Anchor" href="#引用的著作"></a> 引用的著作</h2>
<ol>
<li>JDK 24 - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjQv">https://openjdk.org/projects/jdk/24/<i class="fa fa-external-link-alt"></i></span></li>
<li>Six JDK 24 Features You Should Know About - Azul Systems, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXp1bC5jb20vYmxvZy9zaXgtamRrLTI0LWZlYXR1cmVzLXlvdS1zaG91bGQta25vdy1hYm91dC8=">https://www.azul.com/blog/six-jdk-24-features-you-should-know-about/<i class="fa fa-external-link-alt"></i></span></li>
<li>The Arrival of Java 24 - Oracle Blogs, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5vcmFjbGUuY29tL2phdmEvcG9zdC90aGUtYXJyaXZhbC1vZi1qYXZhLTI0">https://blogs.oracle.com/java/post/the-arrival-of-java-24<i class="fa fa-external-link-alt"></i></span></li>
<li>JDK 24 Release Notes, Important Changes, and Information - Oracle, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvMjQtcmVsbm90ZS1pc3N1ZXMuaHRtbA==">https://www.oracle.com/java/technologies/javase/24-relnote-issues.html<i class="fa fa-external-link-alt"></i></span></li>
<li>Consolidated JDK 24 Release Notes - Oracle, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9qYXZhL3RlY2hub2xvZ2llcy9qYXZhc2UvMjRhbGwtcmVsbm90ZXMuaHRtbA==">https://www.oracle.com/java/technologies/javase/24all-relnotes.html<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 488: Primitive Types in Patterns, instanceof, and switch (Second …), 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ4OA==">https://openjdk.org/jeps/488<i class="fa fa-external-link-alt"></i></span></li>
<li>Java Language Changes Summary - Oracle Help Center, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMjQvbGFuZ3VhZ2UvamF2YS1sYW5ndWFnZS1jaGFuZ2VzLXN1bW1hcnkuaHRtbA==">https://docs.oracle.com/en/java/javase/24/language/java-language-changes-summary.html<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP: Flexible Constructor Bodies. Final for JDK 25 : r/java - Reddit, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2phdmEvY29tbWVudHMvMWs0Zm0zaS9qZXBfZmxleGlibGVfY29uc3RydWN0b3JfYm9kaWVzX2ZpbmFsX2Zvcl9qZGtfMjUv">https://www.reddit.com/r/java/comments/1k4fm3i/jep_flexible_constructor_bodies_final_for_jdk_25/<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 492: Flexible Constructor Bodies (Third Preview) - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ5Mg==">https://openjdk.org/jeps/492<i class="fa fa-external-link-alt"></i></span></li>
<li>Oracle Releases Java 24, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS9uZXdzL2Fubm91bmNlbWVudC9vcmFjbGUtcmVsZWFzZXMtamF2YS0yNC0yMDI1LTAzLTE4Lw==">https://www.oracle.com/news/announcement/oracle-releases-java-24-2025-03-18/<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 494: Module Import Declarations (Second Preview) - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ5NA==">https://openjdk.org/jeps/494<i class="fa fa-external-link-alt"></i></span></li>
<li>Module Import Declarations - Oracle Help Center, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMjQvbGFuZ3VhZ2UvbW9kdWxlLWltcG9ydC1kZWNsYXJhdGlvbnMuaHRtbA==">https://docs.oracle.com/en/java/javase/24/language/module-import-declarations.html<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 495: Simple Source Files and Instance Main Methods (Fourth …), 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ5NQ==">https://openjdk.org/jeps/495<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 487: Scoped Values (Fourth Preview) - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ4Nw==">https://openjdk.org/jeps/487<i class="fa fa-external-link-alt"></i></span></li>
<li>Scoped Values - Oracle Help Center, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vZW4vamF2YS9qYXZhc2UvMjQvY29yZS9zY29wZWQtdmFsdWVzLmh0bWw=">https://docs.oracle.com/en/java/javase/24/core/scoped-values.html<i class="fa fa-external-link-alt"></i></span></li>
<li>Java 24 Delivers New Experimental and Many Final Features - InfoQ, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL25ld3MvMjAyNS8wMy9qYXZhMjQtcmVsZWFzZWQv">https://www.infoq.com/news/2025/03/java24-released/<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 485: Stream Gatherers - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ4NQ==">https://openjdk.org/jeps/485<i class="fa fa-external-link-alt"></i></span></li>
<li>Stream Gatherers (JEP 485) - <span class="exturl" data-url="aHR0cDovL2phdmFhbG1hbmFjLmlv">javaalmanac.io<i class="fa fa-external-link-alt"></i></span>, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9qYXZhYWxtYW5hYy5pby9mZWF0dXJlcy9nYXRoZXJlcnMv">https://javaalmanac.io/features/gatherers/<i class="fa fa-external-link-alt"></i></span></li>
<li>Liberica JDK 24 builds are generally available - BellSoft, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9iZWxsLXN3LmNvbS9ibG9nL2xpYmVyaWNhLWpkay0yNC1pcy1yZWxlYXNlZC8=">https://bell-sw.com/blog/liberica-jdk-24-is-released/<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP proposed to target JDK 24: 484: Class-File API - OpenJDK mailing lists, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9tYWlsLm9wZW5qZGsub3JnL3BpcGVybWFpbC9qZGstZGV2LzIwMjQtT2N0b2Jlci8wMDk0MjcuaHRtbA==">https://mail.openjdk.org/pipermail/jdk-dev/2024-October/009427.html<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 484: Class-File API - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ4NA==">https://openjdk.org/jeps/484<i class="fa fa-external-link-alt"></i></span></li>
<li>A Basic Introduction to the Classfile API | Ife Sunmola, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9pZmVzdW5tb2xhLmNvbS9hLWJhc2ljLWludHJvZHVjdGlvbi10by10aGUtY2xhc3NmaWxlLWFwaS8=">https://ifesunmola.com/a-basic-introduction-to-the-classfile-api/<i class="fa fa-external-link-alt"></i></span></li>
<li>mrjameshamilton/java-class-file-api-hello-world - GitHub, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21yamFtZXNoYW1pbHRvbi9qZXA0NTctaGVsbG8td29ybGQ=">https://github.com/mrjameshamilton/jep457-hello-world<i class="fa fa-external-link-alt"></i></span></li>
<li>JEP 491: Synchronize Virtual Threads without Pinning - OpenJDK, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzQ5MQ==">https://openjdk.org/jeps/491<i class="fa fa-external-link-alt"></i></span></li>
<li>Java Evolves to Tackle Virtual Threads Pinning with JEP 491 - InfoQ, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL25ld3MvMjAyNC8xMS9qYXZhLWV2b2x2ZXMtdGFja2xlLXBpbm5pbmcv">https://www.infoq.com/news/2024/11/java-evolves-tackle-pinning/<i class="fa fa-external-link-alt"></i></span></li>
<li>Re: Apache Tomcat 12+, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly9saXN0cy5hcGFjaGUub3JnL3RocmVhZC85cHEzdDZnc3FoMjR0b2wyNG1uazZoeTFoejhtN21tNg==">https://lists.apache.org/thread/9pq3t6gsqh24tol24mnk6hy1hz8m7mm6<i class="fa fa-external-link-alt"></i></span></li>
<li>OpenJDK News Roundup: Instance Main Methods, Flexible Constructor Bodies, Module Import Declarations - InfoQ, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL25ld3MvMjAyNC8xMS9qZGstbmV3cy1yb3VuZHVwLW5vdjA0LTIwMjQv">https://www.infoq.com/news/2024/11/jdk-news-roundup-nov04-2024/<i class="fa fa-external-link-alt"></i></span></li>
<li>Java News Roundup: JDK 24, GraalVM for JDK 24, Payara Platform, Kafka 4.0, Spring CVEs, JavaOne 2025 - InfoQ, 访问时间为 五月 28, 2025， <span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3EuY29tL25ld3MvMjAyNS8wMy9qYXZhLW5ld3Mtcm91bmR1cC1tYXIxNy0yMDI1Lw==">https://www.infoq.com/news/2025/03/java-news-roundup-mar17-2025/<i class="fa fa-external-link-alt"></i></span># JDK 24 新特性深度解析与代码示例</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK24</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 25 新特性深度解析与代码示例</title>
    <url>/2025/jdk-25-%E6%96%B0%E7%89%B9%E6%80%A7%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="jdk-25-主要特性概览-overview-of-jdk-25-main-features"><a class="markdownIt-Anchor" href="#jdk-25-主要特性概览-overview-of-jdk-25-main-features"></a> JDK 25 主要特性概览 (Overview of JDK 25 Main Features)</h1>
<table>
<thead>
<tr>
<th>JEP 编号</th>
<th>标题</th>
<th>类型与状态</th>
<th>核心领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>JEP 470</td>
<td>PEM Encodings of Cryptographic Objects</td>
<td>预览（Preview）</td>
<td>安全 / 密钥 /库支持 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 502</td>
<td>Stable Values</td>
<td>预览（Preview）</td>
<td>核心库 / 并发 /状态管理 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 503</td>
<td>Remove the 32-bit x86 Port</td>
<td>正式（Removal / Platform）</td>
<td>平台支持 /兼容性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 505</td>
<td>Structured Concurrency (第五次预览)</td>
<td>预览（Preview）</td>
<td>并发 /结构化任务管理 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 506</td>
<td>Scoped Values</td>
<td>正式（Closed / Delivered）</td>
<td>并发 /状态共享 /替代 ThreadLocal (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 507</td>
<td>Primitive Types in Patterns, instanceof, and switch (第三次预览)</td>
<td>预览（Preview）</td>
<td>语言 /模式匹配 /语法表达力 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 508</td>
<td>Vector API (第十次孵化)</td>
<td>孵化（Incubator）</td>
<td>性能 /数值 /向量计算 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 509</td>
<td>JFR CPU-Time Profiling</td>
<td>实验性（Experimental）</td>
<td>可观察性 /性能剖析工具 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 510</td>
<td>Key Derivation Function API</td>
<td>正式（Feature）</td>
<td>安全 /密钥派生 /协议支持 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 511</td>
<td>Module Import Declarations</td>
<td>正式（Feature）</td>
<td>语言 /模块化 /源码导入便利性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 512</td>
<td>Compact Source Files and Instance Main Methods</td>
<td>正式（Feature / Delivered）</td>
<td>语言 /脚本 /样板简化 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzUxMj91dG1fc291cmNlPWNoYXRncHQuY29t" title="JEP 512: Compact Source Files and Instance Main Methods">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 513</td>
<td>Flexible Constructor Bodies</td>
<td>正式（Feature / Delivered）</td>
<td>语言 /构造器特性 /可读性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 514</td>
<td>Ahead-of-Time Command-Line Ergonomics</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /启动 /AOT 性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 515</td>
<td>Ahead-of-Time Method Profiling</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /AOT /热路径 /预热性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 518</td>
<td>JFR Cooperative Sampling</td>
<td>正式（Feature / Delivered）</td>
<td>可观察性 /剖面采样稳定性 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 519</td>
<td>Compact Object Headers</td>
<td>正式（Feature / Delivered）</td>
<td>JVM /内存布局 /GC /性能 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9qZXBzLzUxOT91dG1fc291cmNlPWNoYXRncHQuY29t" title="JEP 519: Compact Object Headers">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 520</td>
<td>JFR Method Timing &amp; Tracing</td>
<td>正式（Feature / Delivered）</td>
<td>可观察性 /方法级 trace /性能诊断 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
<tr>
<td>JEP 521</td>
<td>Generational Shenandoah</td>
<td>正式（Feature / Delivered）</td>
<td>GC /性能 /低停顿 /大对象堆 (<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUvP3V0bV9zb3VyY2U9Y2hhdGdwdC5jb20=" title="JDK 25">openjdk.org<i class="fa fa-external-link-alt"></i></span>)</td>
</tr>
</tbody>
</table>
<p>数据来源：<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLm9yZy9wcm9qZWN0cy9qZGsvMjUv">openjdk.org<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="核心亮点"><a class="markdownIt-Anchor" href="#核心亮点"></a> 核心亮点</h2>
<ol>
<li><strong>性能与启动时间的质变</strong> —— AOT 命令行流程（JEP 514）、方法剖面写入 AOT（JEP 515）与 Compact Object Headers（JEP 519）的成熟，使冷启动/预热 &amp; 内存密集场景中的性能提升成为可度量的改进。</li>
<li><strong>并发与状态共享模型的现代化</strong> —— Structured Concurrency（JEP 505）、Scoped Values（JEP 506）与 Stable Values（JEP 502）引入更安全、更可推理、低样板的线程上下文与状态管理方式，减少传统 ThreadLocal + try/finally + cancel/timeout 模式的风险与复杂性。</li>
<li><strong>安全性与生态库支持的提升</strong> —— Key Derivation Function API（JEP 510）、PEM 编码/解码 API（JEP 470）等特性使密码学库更加标准化，也让安全工具集成与第三方协议支持更加平滑；同时 Vector API 的进步表明数值/AI/ML 场景下 Java 在本地硬件能力利用上的野心。</li>
</ol>
<h1 id="一-语言层面代码表达力的再度飞跃"><a class="markdownIt-Anchor" href="#一-语言层面代码表达力的再度飞跃"></a> 一、语言层面：代码表达力的再度飞跃</h1>
<p>接下来从几个修改语法与类型模型的新特性入手，分析它们如何影响架构设计与代码质量。</p>
<h2 id="深入解读primitive-types-in-patterns-instanceof-and-switch-jep-507"><a class="markdownIt-Anchor" href="#深入解读primitive-types-in-patterns-instanceof-and-switch-jep-507"></a> 深入解读：Primitive Types in Patterns, instanceof, and switch (JEP 507)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
在以往版本中，pattern matching / <code>instanceof</code> / <code>switch</code> 针对引用类型已经越来越强，但原始类型依然不能被直接模式匹配或用做 <code>instanceof</code> 检查的一部分。通常的做法是用 wrapper 类型或手动转换/拆箱，这带来：装箱/拆箱的性能开销、代码样板冗余、可空性带来的空指针风险，以及类型检查与转换杂乱无章，尤其在解析层、DSL 层、配置/反序列化过程中尤为明显。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 507 在第三次预览中允许原始类型（如 <code>int</code>, <code>long</code> 等）在所有模式匹配语境中使用，包括 <code>instanceof</code> 和 <code>switch</code> 分支。这意味着：</p>
<ul>
<li><code>if (obj instanceof int i) &#123; ... &#125;</code> 成为合法语法，减少显式 cast 与拆箱。</li>
<li>在 <code>switch (expr)</code> 中可以有 <code>case int i -&gt; ...</code> 或匹配原始类型模式，与引用类型模式共存。</li>
<li>编译期会检查类型主导性（dominance），防止原始类型分支被更一般的类型分支屏蔽。</li>
</ul>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimitivePatternOld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ((Integer) v).intValue();  <span class="comment">// 显式拆箱</span></span><br><span class="line">            System.out.println(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> Integer ii -&gt; System.out.println(<span class="string">&quot;int: &quot;</span> + ii);</span><br><span class="line">            <span class="keyword">case</span> Long ll    -&gt; System.out.println(<span class="string">&quot;long: &quot;</span> + ll);</span><br><span class="line">            <span class="keyword">default</span>         -&gt; System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimitivePatternNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> Integer.valueOf(<span class="number">42</span>);</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="type">int</span> i) &#123;  <span class="comment">// 原始类型模式</span></span><br><span class="line">            System.out.println(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span> i -&gt; System.out.println(<span class="string">&quot;primitive int: &quot;</span> + i);</span><br><span class="line">            <span class="keyword">case</span> <span class="type">long</span> l -&gt; System.out.println(<span class="string">&quot;primitive long: &quot;</span> + l);</span><br><span class="line">            <span class="keyword">case</span> Integer ii -&gt; System.out.println(<span class="string">&quot;boxed Integer: &quot;</span> + ii);</span><br><span class="line">            <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
这种变革使得那些基于反射 /模式匹配 /消息调度 /命令处理的框架可以简化 matcher/visitor 的实现，不再为了处理原始类型与引用类型分别写不同路径。可能削弱以前&quot;包装类型 + 工具辅助&quot;的设计，鼓励更加统一的模式表达。对于 DSL 或者混合类型系统（如 JSON + 强类型对象 +原始类型）项目尤为有利。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
装箱/拆箱减少、对象产生减少，对 GC 压力有积极意义；但编译器 /字节码生成中引入 pattern 匹配的复杂性与判断分支可能带来微小的开销。特别在高度性能敏感的 inner-loop 或者需要极端优化（如数百万次匹配）场景，需要做基准测试。还有：分支预测可能因为多种类型混合而变差。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
在大型项目中，可先将此特性限定在边缘层（解析器、配置加载、API boundary等），让团队熟悉其语义与行为。CI 中启用 preview 特性 (<code>--enable-preview</code>) 进行静态分析与编译检查，确保代码风格一致。注意回退兼容性：旧版本 JDK 的构建/部署环境若不支持，会导致编译错误。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读flexible-constructor-bodies-jep-513"><a class="markdownIt-Anchor" href="#深入解读flexible-constructor-bodies-jep-513"></a> 深入解读：Flexible Constructor Bodies (JEP 513)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
构造器语义中，&quot;super(…) 或 this(…) 必须是首语句&quot;这一传统规则在直观可读性与错误处理方面造成很多样板：在参数校验、辅助计算或格式规范化之前，必须写静态 helper 或先调用 super 然后再做校验，这在继承链复杂或类层次深的架构中易导致错误抛出的时机不直观，也会使得对象字段在父构造器调用中可见但未被期望初始化。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 513 允许在调用父构造器或本类其他构造器之前执行一些&quot;安全语句&quot;（不能使用未初始化状态的 <code>this</code>），例如校验参数、准备计算值、校正、甚至日志。这样可以让构造逻辑更自然、错误报错更早、更精确；同时让对象的字段在调用父构造器时更有保障。该特性在 JDK 25 中成为正式特性。</p>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent ctor called with x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sanitize</span><span class="params">(<span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;y must be &gt;= 0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Child(<span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">super</span>(sanitize(y));  <span class="comment">// 校验必须在静态 helper 中做</span></span><br><span class="line">        <span class="comment">// 字段初始化或其他逻辑只能在 super 后</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    Parent(<span class="type">int</span> x) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent ctor called with x=&quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    Child(<span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;y must be &gt;= 0&quot;</span>);  <span class="comment">// 校验提前</span></span><br><span class="line">        <span class="built_in">this</span>.y = y;  <span class="comment">// 可以初始化字段</span></span><br><span class="line">        <span class="built_in">super</span>(y);    <span class="comment">// 调用父构造器</span></span><br><span class="line">        <span class="comment">// 更多逻辑……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
在工厂模式 /继承 /子类与超类强耦合的设计中，以往为了在父构造器中调用某些方法或记录日志，很多设计都会用静态辅助类或构造器链，这些会被重新审视。现在能把校验、状态标准化逻辑移回构造器开头，使构造流程语义更清晰。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
本质上对运行期几乎无影响；仅是微调语法顺序；但可能影响字节码生成顺序与初始化顺序，某些框架（例如序列化库、反射代理、依赖注入框架）假设父类构造器中某些字段未设定或某些行为可能会因子类字段在调用 super 前完成赋值而改变行为。在这种情况下，需要审查是否依赖旧语义。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
在重大变更部件（父类/子类关系复杂的库）中做代码审查与行为测试（尤其父构造器调用期间调用 overridden 方法或调用子类方法的情境）。构造器逻辑建议保持轻量，避免提前做 I/O /网络 /长耗时操作。制定规范：只允许做&quot;校验 / 框架友好准备 /字段赋值&quot;，不允许做重工作。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读compact-source-files-and-instance-main-methods-jep-512"><a class="markdownIt-Anchor" href="#深入解读compact-source-files-and-instance-main-methods-jep-512"></a> 深入解读：Compact Source Files and Instance Main Methods (JEP 512)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
快速脚本、工具类、示例、教学代码等场景中，一套繁重的包 + 类 + <code>public static void main(String[])</code> boilerplate 降低了开发速度与可读性。尤其团队中常见的小工具、命令行启动脚本需要快速编辑、测试、部署，这些样板成为&quot;摩擦点&quot;。</p>
</li>
<li>
<p><strong>它带来了哪些改变？</strong><br />
JEP 512 在 JDK 25 中成为正式特性，允许：</p>
<ul>
<li>单文件程序可以省略顶层 <code>class</code> 声明；</li>
<li>用非静态实例 <code>main</code> 方法作为入口；</li>
<li>代码直接包含顶层语句与表达式，支持 <code>java Hello.java</code> 直接运行；</li>
<li>向后兼容性保留原有模式。</li>
</ul>
</li>
<li>
<p><strong>代码对比：</strong></p>
<ul>
<li>
<p><strong>Before (JDK 25 之前)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloOld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, verbose Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>After (使用 JDK 25)：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, compact source Java 25.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
此特性不会影响核心架构，但在工具库、CLI 工具、脚本式任务 &amp;开发者体验上大有裨益；能促进内部工具 /开发脚手架统一而减少样板，使微工具更易于维护。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
与语法样板本身无关性能；但开发效率提升可减少代码出错率，也可能缩短迭代周期。工具链（IDE,构建系统,静态分析器）可能需要更新以正确支持这些语法并处理 source-level 分析。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
推荐将此特性用于 <code>tools/</code>, <code>scripts/</code>, <code>examples/</code> 目录；生产核心业务模块可保持传统（class + public static main）以保持一致性。确保代码审查 /格式化工具支持；文档与团队共享规范。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读module-import-declarations-jep-511-delivered"><a class="markdownIt-Anchor" href="#深入解读module-import-declarations-jep-511-delivered"></a> 深入解读：Module Import Declarations (JEP 511, Delivered)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
随着模块化，使用某个模块时往往需要手动写很多包级 <code>import</code> 语句或维护 <code>module-info.java</code>。这对原型、教学或小工具带来样板负担。JEP 511 旨在在源文件层面引入 <code>import module M;</code> 声明 —— 类似顶层的包 import，但按模块一次性导入该模块导出的所有 public 顶层类/接口（以及模块所读模块导出的类型，按规则递归/传递）。</p>
</li>
<li>
<p><strong>核心解决方案与机制</strong><br />
<code>import module M;</code> 出现在文件顶部，相当于按模块内导出包对每个包做 on-demand import（如 <code>java.base</code> 的所有导出包会像 <code>import java.io.*; import java.util.*; ...</code> 那样可见）。该特性降低了学习/原型/脚本的摩擦，同时仍可与现有模块系统共存（它并不替代 <code>module-info.java</code> 的 <code>requires</code>）。</p>
</li>
<li>
<p><strong>代码示例</strong></p>
</li>
</ul>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> <span class="keyword">module</span> java.logging;  <span class="comment">// 将 java.logging 模块导出的 public 顶级类型按需导入</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModuleImportDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处可以直接使用 Logger（来自 java.util.logging）而无需显式 package import</span></span><br><span class="line">            java.util.logging.<span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> java.util.logging.Logger.getLogger(<span class="string">&quot;demo&quot;</span>); <span class="comment">// 也可直接 Logger，如果无冲突</span></span><br><span class="line">            logger.info(<span class="string">&quot;Module import demo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：模块导入会带来命名冲突风险（若多个导入模块中存在同名顶级类型），此时仍可使用显式包名或普通 <code>import</code> 来消歧。对大型代码库，建议谨慎在核心业务代码中使用模块导入，更多用于脚本、示例与快速原型。</p>
<ul>
<li><strong>架构师的思考：</strong>
<ul>
<li>
<p><strong>对设计模式的影响：</strong><br />
此特性主要简化开发体验，不会对核心架构设计产生重大影响。但在快速原型开发、脚本编写、教学示例中能显著减少样板代码，提升开发效率。</p>
</li>
<li>
<p><strong>性能与权衡：</strong><br />
编译时解析，运行时无额外开销。主要权衡是可能带来的命名空间污染和潜在的命名冲突风险，需要团队建立清晰的使用规范。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
建议先在工具脚本、示例代码中试用；制定团队规范明确何时使用模块导入；在大型项目中谨慎使用，避免在核心业务代码中引入不必要的复杂性。</p>
</li>
</ul>
</li>
</ul>
<h1 id="二-jvm-增强性能优化的无声革命"><a class="markdownIt-Anchor" href="#二-jvm-增强性能优化的无声革命"></a> 二、JVM 增强：性能优化的无声革命</h1>
<p>探讨那些在启动 /内存布局 /GC /可观察性上带来实质性、可能被忽略但重要的改进。</p>
<h2 id="深入解读compact-object-headers-jep-519"><a class="markdownIt-Anchor" href="#深入解读compact-object-headers-jep-519"></a> 深入解读：Compact Object Headers (JEP 519)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
在大对象数的系统（每秒大量 POJO、消息对象、JSON/Protobuf 解码器输出等），对象头部（mark word + class pointer +对齐填充等）在 64 位 JVM 上一直是一个不可忽视的开销。对象头过大不仅浪费内存，也降低缓存局部性和 GC 期间的扫描效率。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong><br />
JEP 519 把对象头从实验状态提升为产品特性，将其压缩到 64 位（8 bytes），去掉冗余 bits，同时保留所有 GC 状态、类指针及必要标记。HotSpot 在对象创建、对齐以及标记阶段会考虑这种压缩头的布局与填充方式。该特性在 JDK 25 中默认可用（不再依赖实验标志），但需通过 <code>-XX:+UseCompactObjectHeaders</code> 显式启用。(<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcw==">JDK 25 Features &amp; Release Notes<i class="fa fa-external-link-alt"></i></span>) (<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcz91dG1fc291cmNlPWNoYXRncHQuY29t" title="JDK 25 Release Notes - Java Net">jdk.java.net<i class="fa fa-external-link-alt"></i></span>)</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:+UseCompactObjectHeaders -jar yourapp.jar</span><br></pre></td></tr></table></figure>
<p>使用 JFR / VisualVM / JMX 查看堆的对象 histogram，对比对象大小与 total heap 使用；在 Linux 环境用 <code>smaps</code> 或 OS 工具查看 RSS；观察 GC pause 时间是否减少。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
大量短生命周期对象的小服务；流处理 /JSON/XML/Protobuf解析密集；容器化部署中内存成为限制因素的应用。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
内存使用下降，缓存miss 率下降，有助于 GC 压力减轻。可能在某些 native 工具或本机代码中，假设对象头布局固定的代码或工具会失效，需验证兼容性。对象头压缩可能对调试工具 / heap dump 分析器等影响其假设。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
在 Stage 环境中开启 A/B 测试；监控 p50/p95 延迟，GC pause 分布；用于 small object allocation rate、promotion rate、serialization/deserialization 性能；确保识别出因 header 压缩导致的工具链故障。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读ahead-of-time-command-line-ergonomics-method-profiling-jep-514-jep-515"><a class="markdownIt-Anchor" href="#深入解读ahead-of-time-command-line-ergonomics-method-profiling-jep-514-jep-515"></a> 深入解读：Ahead-of-Time Command-Line Ergonomics &amp; Method Profiling (JEP 514 &amp; JEP 515)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
冷启动延迟、预热期的性能过渡不平滑是微服务 /serverless /短寿命容器的常见瓶颈。以往工程会采用缓存类加载、预热 JIT，或手工 profile 并加载类。流程繁琐、不一致；AOT cache 虽然在 JDK 24 已初具形态，但生成与应用流程仍显得笨重。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong></p>
<ul>
<li>JEP 514 简化命令行接口：合并 record 与 create 步骤，让开发者更便捷地生成 AOT 缓存。</li>
<li>JEP 515 在训练 run（训练过程）中收集方法执行的 profile 信息（哪些方法被调用、频率等），将这些信息存入 AOT cache；下次启动时，JIT / AOT 可立即利用这些 profile 来决定哪些方法应提前编译／优化。减少热路径的启动 /预热成本。</li>
</ul>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练并生成 AOT cache</span></span><br><span class="line">java -XX:AOTCacheOutput=app.aot -jar myapp.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用并使用 AOT cache</span></span><br><span class="line">java -XX:AOTCache=app.aot -jar myapp.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 JFR 或 hotspot 的 compilation log 观察编译事件；监控应用启动 latency（first request / first API 响应），以及预热期间的 CPU 使用率与 JIT 编译次数。</li>
</ul>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
短生命周期服务（如 Lambda /微函数 /container startup），CLI 程序，web 前端组件启动；也适合部署到边缘环境 /启动成本高 /资源受限的环境。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
AOT cache 训练需要一段代表性负载；若训练与生产不一致，反而可能产生误导性 profile，导致非最优的热路径；AOT cache 文件大小与平台兼容性问题（CPU arch /OS版本）需考虑。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
制定&quot;训练任务&quot;模板，这些任务应覆盖典型流量与边缘情况；将 AOT cache 与应用版本联合 version-control；在多个环境 /节点上对比启动 &amp;预热指标；为回滚设定阈值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读generational-shenandoah-jep-521"><a class="markdownIt-Anchor" href="#深入解读generational-shenandoah-jep-521"></a> 深入解读：Generational Shenandoah (JEP 521)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
原先的 Shenandoah GC 优秀在低暂停延迟环境，但在处理短生命周期对象（年轻代）时与传统 generational GC（如 G1）相比有一定缺陷：即便对象寿命短，也被频繁促升或被长时间扫描。对于高 throughput +低延迟 +大量临时对象的系统，这成为瓶颈。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong><br />
JEP 521 把 generational 模式引入 Shenandoah: 设置 young / old regions，使得短生命周期对象更快被回收；保留了 Shenandoah 的并发标记与整理特性，减少全堆停顿；改进 young-gen 回收、promotion策略，以及与 compaction / evacuation 的交互。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -jar yourapp.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>监控 GC 日志（-Xlog:gc*, -Xlog:gc+pause=info）</li>
<li>用 JFR /GC采样工具观察 young-gen 回收时间、promotion rate、allocation rate、小对象分配及淘汰比例。</li>
</ul>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
高并发 web 服务、大数据管道 /流处理节点 /在线事务系统，这些系统既要低延迟又有高吞吐；尤其那些短生命周期对象很多、内存分配 &amp;回收频繁。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong><br />
在某些极端场景，generational Shenandoah 的复杂度高于简单 GC; young-gen 对象 promotion 逻辑带来的同步或内存碎片问题可能出现；长期运行的大堆 /大对象情况仍需对比 G1 或 ZGC 的表现。</p>
</li>
<li>
<p><strong>调优策略：</strong><br />
优化 young-gen 大小、promotion Age；监控 survivor 区间的填满速率；定位大对象分配；观察 GC pause latency 的分布；在服务级别设置可接受延迟范围并设定 fallback GC 策略。</p>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读vector-api-jep-508-tenth-incubator"><a class="markdownIt-Anchor" href="#深入解读vector-api-jep-508-tenth-incubator"></a> 深入解读：Vector API (JEP 508, Tenth Incubator)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
数值/媒体/ML/信号处理类代码需要利用 SIMD 指令（CPU 向量化能力）以提高吞吐。手写 JNI 或依赖 C/C++ 库增加维护成本。Vector API 提供一个平台独立、可移植的向量编程接口，让 JVM 在运行时将向量化操作映射到底层 SIMD 指令。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
<code>jdk.incubator.vector</code> 提供 <code>Vector</code>、<code>IntVector</code>、<code>FloatVector</code>、<code>VectorSpecies</code> 等类，允许以数组/向量批量方式进行算术、混洗（shuffle）、加载/存储。JEP 508 在 JDK 25 中再次以 incubator 的形式出现（第十轮），包含 API 与实现改进。使用时需显式启用 incubator 模块。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li><strong>代码示例（整型向量批量加法，可直接编译/运行）</strong></li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile: javac --release 25 --add-modules jdk.incubator.vector VectorAdd.java</span></span><br><span class="line"><span class="comment">// Run:     java --add-modules jdk.incubator.vector VectorAdd</span></span><br><span class="line"><span class="keyword">import</span> jdk.incubator.vector.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorAdd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] b = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[a.length];</span><br><span class="line">        VectorSpecies&lt;Integer&gt; SPECIES = IntVector.SPECIES_PREFERRED;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> SPECIES.loopBound(a.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; upper; i += SPECIES.length()) &#123;</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">va</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, a, i);</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">vb</span> <span class="operator">=</span> IntVector.fromArray(SPECIES, b, i);</span><br><span class="line">            <span class="type">IntVector</span> <span class="variable">vc</span> <span class="operator">=</span> va.add(vb);</span><br><span class="line">            vc.intoArray(c, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tail</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = a[i] + b[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : c) System.out.print(v + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>最佳应用场景：</strong>  <br />
数值计算密集型应用；图像/音频处理；机器学习推理；大数据批处理；科学计算等需要大量并行数值运算的场景。</p>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
</li>
<li>
<p><strong>性能与权衡：</strong>  <br />
在支持 SIMD 的平台上可带来显著加速；但对于短数组/高分支逻辑，向量化开销可能抵消收益。还需关注对不同 CPU ISA 的映射差异（ARM NEON vs x86 AVX）。</p>
</li>
<li>
<p><strong>调优策略：</strong>  <br />
基准驱动的优化：先在热点（内核循环）引入 Vector API，并做 A/B 测试；把实现封装在低层 util/adapter 中，避免分散到业务代码；注意在 CI 测试矩阵覆盖主要 CPU 架构。因为是 incubator，API 可能继续演进，封装能降低未来迁移成本。</p>
</li>
</ul>
<h1 id="三-核心库-api-更新编程体验的持续进化"><a class="markdownIt-Anchor" href="#三-核心库-api-更新编程体验的持续进化"></a> 三、核心库 API 更新：编程体验的持续进化</h1>
<p>这部分讲几个库层面的更新，着重安全 /状态管理 /工具支持上对现有架构影响的地方。</p>
<h2 id="深入解读stable-values-jep-502"><a class="markdownIt-Anchor" href="#深入解读stable-values-jep-502"></a> 深入解读：Stable Values (JEP 502)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
Java 的 <code>final</code> 字段虽能在编译期提供不变性承诺，但在初始化时（尤其在依赖注入容器、模块启动或大型系统初始化）它必须在构造完成或 static 初始化块中被设定；而某些延迟初始化 /按需加载场景中，想要不牺牲性能 /语义安全地“像 final 那样”的不变状态，需要复杂同步或锁。状态初始化早晚与并发安全性成为常见痛点。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong><br />
<code>StableValue&lt;T&gt;</code> 提供一个 holder，可以被设定一次（atomically），在设定之前处于 unset 状态；通过 <code>orElseSet(...)</code> 初始化；一旦设定，不可变；支持查询 <code>isSet()</code>；Treatable by JVM 的编译器优化潜力因为其语义接近 final。处于预览状态。 (<span class="exturl" data-url="aHR0cHM6Ly9qZGsuamF2YS5uZXQvMjUvcmVsZWFzZS1ub3Rlcz91dG1fc291cmNlPWNoYXRncHQuY29t" title="JDK 25 Release Notes - Java Net">jdk.java.net<i class="fa fa-external-link-alt"></i></span>)</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.StableValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StableValueDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StableValue&lt;String&gt; config = StableValue.of();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config.orElseSet(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟某种昂贵的配置读取或外部依赖</span></span><br><span class="line">            <span class="keyword">return</span> loadConfigFromFileOrEnv();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">loadConfigFromFileOrEnv</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 假设这是昂贵或 I/O 的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Loading config...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CONFIG_VALUE&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StableValueDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StableValueDemo</span>();</span><br><span class="line">        System.out.println(demo.getConfig());</span><br><span class="line">        System.out.println(demo.getConfig());  <span class="comment">// 第二次调用不会重新加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong><br />
现有项目中通常用 <code>volatile</code> + <code>double‐check locking</code> 或者 <code>AtomicReference</code> + CAS 操作，或者 lazy holder +同步。这些方案虽然成熟，但常见的错误有锁粒度过大、初始化重复、异常安全性不佳。<code>StableValue</code> 提供一种更语义化、更清晰、不易出错的模式。</p>
</li>
<li>
<p><strong>集成与迁移：</strong><br />
在项目中引入时，建议先用于非关键路径（日志、缓存、工具类等），并且明确哪些部分需要“一次初始化即不可变”；与依赖注入框架结合时要小心 error handling；如果已有很多类似机制，需要决定是否重构。因为是预览特性，迁移成本含编译器支持、测试支持、与旧版本 JDK 的兼容性。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>将 <code>StableValue.of()</code> 放在对象字段里，而非静态变量，以避免类加载 /初始化阶段的复杂依赖。</li>
<li>在 <code>orElseSet</code> lambda 内不要做长时间 I/O 或阻塞操作——最好像 lazy initialization 那样尽早失败/快速返回。</li>
<li>在并发使用中关注异常传播与线程安全（如果两个线程同时调用 orElseSet，应确保只有一个初始化成功）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读key-derivation-function-api-jep-510"><a class="markdownIt-Anchor" href="#深入解读key-derivation-function-api-jep-510"></a> 深入解读：Key Derivation Function API (JEP 510)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong><br />
加密协议中衍生密钥的需求普遍（如 HKDF, Argon2, TLS /混合加密），但之前 Java 标准库对此支持不统一、各实现散落在不同 provider 或第三方库中。开发者经常会手写或引入 BouncyCastle /外部库，导致难以审计、兼容性问题、算法规范互异。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong><br />
JEP 510 在 JDK 25 中正式纳入标准 Key Derivation Function (KDF) API。支持标准算法名称（如 <code>HKDF-SHA256</code> 等），提供参数规范如 extract / expand 阶段、长度控制、provider 插拔性。使得协议实现 /安全库集成更为一致。</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.KDF;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.HKDFParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KDFDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] ikm  = <span class="string">&quot;input-key-material&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] salt = <span class="string">&quot;salt&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] info = <span class="string">&quot;info&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 HKDF-SHA256 实例</span></span><br><span class="line">        <span class="type">KDF</span> <span class="variable">hkdf</span> <span class="operator">=</span> KDF.getInstance(<span class="string">&quot;HKDF-SHA256&quot;</span>);</span><br><span class="line">        <span class="type">HKDFParameterSpec</span> <span class="variable">params</span> <span class="operator">=</span> HKDFParameterSpec.ofExtract()</span><br><span class="line">                                      .addIKM(ikm)</span><br><span class="line">                                      .addSalt(salt)</span><br><span class="line">                                      .thenExpand(info, <span class="number">32</span>);  <span class="comment">// 想要 32 bytes 的输出</span></span><br><span class="line"></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">derived</span> <span class="operator">=</span> hkdf.deriveKey(<span class="string">&quot;AES&quot;</span>, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;Derived key (Hex): &quot;</span> + HexFormat.of().formatHex(derived.getEncoded()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong><br />
在很多项目里 BouncyCastle /外部安全库已提供 HKDF / Argon2 等。多数团队可开始逐步切换到标准 API，以减少依赖、提升可维护性，并受益于平台安全基线与审计。</p>
</li>
<li>
<p><strong>集成与迁移：</strong><br />
在兼容性方面先进行算法行为的一致性测试（输出、边缘情况等）。如之前使用 BC 的某个具体版本，对 salt/ikm 长度或处理方式的差异要评估。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>明确说使用哪个算法名称；文档中列明参数格式 /边界处理；</li>
<li>对于敏感密钥材料，用完后及时清零 /垃圾回收；</li>
<li>在测试中包括安全性边界（如重复 derive，zero salt 等情况）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读pem-encodings-of-cryptographic-objects-jep-470-preview"><a class="markdownIt-Anchor" href="#深入解读pem-encodings-of-cryptographic-objects-jep-470-preview"></a> 深入解读：PEM Encodings of Cryptographic Objects (JEP 470, Preview)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
PEM（Privacy-Enhanced Mail，RFC 7468）是应用极广的文本格式，用于传输证书、公/私钥和 CRL。以前 Java 平台没有统一、易用的 API：解码/编码 PEM 需要手写解析或依赖 BouncyCastle/OpenSSL 等第三方库，导致审计、跨平台行为和加密参数一致性问题。JEP 470 目标是把 PEM 编解码标准化为平台 API，简化常见操作并降低外部依赖。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong>  <br />
在 <code>java.security</code> 包中新增接口与类（<code>DEREncodable</code>、<code>PEMEncoder</code>、<code>PEMDecoder</code>、<code>PEMRecord</code> 等），提供可重用、线程安全的编码/解码器。<code>PEMDecoder</code> 可以把 PEM 文本解码成受支持的 DER 可编码对象（例如 <code>X509Certificate</code>、<code>EncryptedPrivateKeyInfo</code> 等）；<code>PEMEncoder</code> 可以把证书、密钥等编码回 PEM 文本，并支持对私钥的默认 PBE 加密或通过 <code>EncryptedPrivateKeyInfo</code> 指定自定义参数。<strong>此 API 在 JDK 25 为 preview，需要 <code>--enable-preview</code> 来编译/运行示例。</strong></p>
</li>
<li>
<p><strong>用法示例：</strong><br />
把一个 PEM 编码的证书字符串解码为 <code>X509Certificate</code> 并打印主题信息。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile: javac --release 25 --enable-preview PemDecodeDemo.java</span></span><br><span class="line"><span class="comment">// Run:     java --enable-preview PemDecodeDemo</span></span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PemDecodeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个最小示例替代真实证书内容（实际使用请替换为真实 PEM）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CERT_PEM</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        -----BEGIN CERTIFICATE-----  </span></span><br><span class="line"><span class="string">        MIIBszCCAVigAwIBAgIJAO3q...REPLACE_WITH_REAL_BASE64...IDAQAB  </span></span><br><span class="line"><span class="string">        -----END CERTIFICATE-----  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用平台的 PEMDecoder（java.security.PEMDecoder）</span></span><br><span class="line">        <span class="type">X509Certificate</span> <span class="variable">cert</span> <span class="operator">=</span> java.security.PEMDecoder.of()</span><br><span class="line">                                    .decode(CERT_PEM, X509Certificate.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;Subject DN: &quot;</span> + cert.getSubjectDN());</span><br><span class="line">        System.out.println(<span class="string">&quot;Issuer DN : &quot;</span> + cert.getIssuerDN());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：该 API 会返回 <code>PEMRecord</code> 当遇到未知/自定义 PEM 类型；对于加密私钥，可以先 <code>decode</code> 到 <code>EncryptedPrivateKeyInfo</code>，再调用其 <code>getKey(password)</code> 解密成 <code>PrivateKey</code>。</p>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong>  <br />
把 PEM 转换纳入标准库，项目应优先使用平台 API，减少对 BC/OpenSSL 的直接依赖；但对于非常新或非标准格式，仍可能需要第三方支持。</p>
</li>
<li>
<p><strong>集成与迁移：</strong>  <br />
在安全敏感的代码里替换手写 PEM 解析；对现有使用第三方库的模块做回归测试（加密参数、默认 PBE 算法差异）；因为是 preview，逐步迁移并在 CI 中保留对旧 JDK（若需）构建的兼容分支。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>PEM 编解码本质为文本→Base64→DER 转换，CPU 开销低。主要收益是<strong>安全性审计、可维护性与一致行为</strong>，不是显著的运行时性能改进。</li>
<li>对于敏感密钥材料，用完后及时清零/垃圾回收；在测试中包括安全性边界处理。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读structured-concurrency-jep-505-fifth-preview"><a class="markdownIt-Anchor" href="#深入解读structured-concurrency-jep-505-fifth-preview"></a> 深入解读：Structured Concurrency (JEP 505, Fifth Preview)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
    传统使用 <code>ExecutorService</code>/<code>Future</code> 管理并发时，错误处理、取消、线程泄漏与可观察性变得复杂，尤其在使用虚拟线程的大规模并发下。结构化并发（structured concurrency）以&quot;任务-子任务&quot;的嵌套语法语义，把一组相关子任务视为单个逻辑单元，简化 error/cancel 管理并增强可观测性。</p>
</li>
<li>
<p><strong>核心功能与用法：</strong>  <br />
    引入 <code>StructuredTaskScope</code>（位于 <code>java.util.concurrent</code>）等 API：在一个<strong>词法作用域</strong>内 fork 子任务，调用 <code>join()</code> 后统一处理成功或失败（失败时自动取消其它子任务），并将子任务的生命周期限制在这个作用域。JDK 25 是第五次预览，API 有多次调整（factory open 方法、join/short-circuit 行为、Subtask/resultNow 细节等）。</p>
</li>
<li>
<p><strong>用法示例：</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Compile/Run with JDK25 (no special flags needed for preview here; JEP505 is a preview API in JDK25)</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.StructuredTaskScope;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StructuredConcurrencyDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">findUser</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="keyword">return</span> <span class="string">&quot;alice&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer <span class="title function_">fetchOrder</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span><br><span class="line">        Thread.sleep(<span class="number">150</span>); <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">record</span> <span class="title class_">Response</span><span class="params">(String user, <span class="type">int</span> order)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Response <span class="title function_">handle</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> StructuredTaskScope.open()) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">user</span> <span class="operator">=</span> scope.fork(() -&gt; findUser());</span><br><span class="line">            <span class="type">var</span> <span class="variable">order</span> <span class="operator">=</span> scope.fork(() -&gt; fetchOrder());</span><br><span class="line">            scope.join();        <span class="comment">// 等待所有子任务，若有失败，会触发短路与取消</span></span><br><span class="line">            scope.throwIfFailed(); <span class="comment">// 将第一个失败的异常抛出（可选）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(user.resultNow(), order.resultNow());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(handle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>落地思考：</strong></p>
<ul>
<li>
<p><strong>替代方案：</strong>  <br />
鼓励把&quot;请求处理/事务性工作&quot;建模为一个作用域，嫁接到微服务请求处理流程（例如：并行调用多个后端、并行校验、并行缓存填充）。这将显著减少 try/finally 风格的取消/清理样板。</p>
</li>
<li>
<p><strong>集成与迁移：</strong>  <br />
在服务端处理路径引入结构化并发的试点（例如：并行调用几个独立 I/O 服务）；把超时/取消策略集中化；在 APM/日志中记录 scope id 以便于 JFR 等工具可视化任务树。由于为 preview，先在非关键路径或 feature-flag 下试验。</p>
</li>
<li>
<p><strong>最佳实践：</strong></p>
<ul>
<li>与虚拟线程结合时非常高效；但对传统线程池/同步密集型任务并不总是最佳。作用域在 <code>join()</code> 时会等待所有子任务的完成或触发取消，需注意对延迟敏感路径的超时策略（可在 scope 层面施加 deadline）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="四-可观察性增强jfr-的全面进化"><a class="markdownIt-Anchor" href="#四-可观察性增强jfr-的全面进化"></a> 四、可观察性增强：JFR 的全面进化</h1>
<p>JDK 25 在 Java Flight Recorder (JFR) 方面带来了重大改进，包括更安全的采样机制、CPU 时间精确分析和方法级别的精确计时。这些改进使得生产环境的性能监控和问题诊断更加精确和稳定。</p>
<h2 id="深入解读jfr-cooperative-sampling-jep-518-与-cpu-time-profiling-jep-509-experimental"><a class="markdownIt-Anchor" href="#深入解读jfr-cooperative-sampling-jep-518-与-cpu-time-profiling-jep-509-experimental"></a> 深入解读：JFR Cooperative Sampling (JEP 518) 与 CPU-Time Profiling (JEP 509, Experimental)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
现有 JFR 的样本采集存在：采用异步 stack-walking heuristics 有安全/稳定问题，并且 JFR 的执行时间采样（ExecutionSample）无法准确反映<strong>CPU 时间</strong>（尤其当很多工作在 native code 中完成时）。这导致在短时间窗口或 native-heavy代码中，分析结果不精确或不安全。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong></p>
<ul>
<li>
<p><strong>JEP 518 (Cooperative Sampling)</strong>：重构 JFR 的方法采样机制，使得线程栈在 safepoints（安全点）进行 walking，从而避免不安全/ heuristics 的 stack parsing 并提高稳定性，为更高级采样功能打基础。</p>
</li>
<li>
<p><strong>JEP 509 (JFR CPU-Time Profiling, Experimental)</strong>：利用 Linux 内核的 CPU-timer（基于 CPU 时间而非wall-time触发）来收集 <code>jdk.CPUTimeSample</code> 事件，能正确归因在 native-code 中消耗的 CPU 时间（例如 JNI 调用、FFI 调用等）。该特性目前为 experimental，仅支持 Linux（内核支持）并通过新的 <code>jdk.CPUTimeSample</code> / <code>jdk.CPUTimeSamplesLost</code> 事件暴露。</p>
</li>
</ul>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用 CPU 时间采样</span></span><br><span class="line">java -XX:StartFlightRecording=jdk.CPUTimeSample#enabled=<span class="literal">true</span>,filename=profile.jfr -jar myapp.jar</span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">jfr view cpu-time-hot-methods profile.jfr</span><br><span class="line"><span class="comment"># 检查样本丢失情况</span></span><br><span class="line">jfr view Events --categories <span class="string">&#x27;Java Virtual Machine&#x27;</span> profile.jfr | grep CPUTimeSamplesLost</span><br></pre></td></tr></table></figure>
<p>JEP 509 依赖 JEP 518 的 cooperative sampling 机制来保证栈采样稳定与准确。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong>  <br />
        需要细粒度 CPU 归因（例如：CPU-bound 服务、混合 Java+native 性能瓶颈定位、持续性能回归检测）的团队将立刻受益。尤其在容器化/云环境下要找出真正的 CPU hotspot（非 IO 等）时，CPU-time profiler 更准确。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong>  <br />
启用较高采样率会增加监控开销（JEP 指出默认 throttle 及 profile.jfc 中的配置）。CPU-time profiling 目前为 Linux 专用并标注为 experimental：生产使用需先评估开销与稳定性。</p>
</li>
<li>
<p><strong>调优策略：</strong></p>
<ul>
<li>在测试环境做代表性负载的采样，验证 <code>jdk.CPUTimeSample</code> 输出与现有工具（async-profiler）的一致性。</li>
<li>对生产上的持续采样保持 conservative throttle（例如 500/s 或 10ms），并结合 <code>jdk.CPUTimeSamplesLost</code> 事件检查样本丢失。</li>
<li>将 JFR 录制文件与 FlameGraph 工具链配合使用，侧重短轮廓（minutes）分析与长期监控（low sampling）策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="深入解读jfr-method-timing-tracing-jep-520"><a class="markdownIt-Anchor" href="#深入解读jfr-method-timing-tracing-jep-520"></a> 深入解读：JFR Method Timing &amp; Tracing (JEP 520)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
    采样型分析难以统计每个方法的精确调用次数与精确耗时；要么要在源代码中插入计时逻辑（不方便且污染业务代码），要么使用外部代理。JEP 520 将「方法级别的计时与可选追踪（trace）」放到 JFR 内部，由 JVM 通过字节码插桩在运行时注入事件，允许按过滤器进行精确计时或记录栈信息。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
    引入 <code>jdk.MethodTiming</code>（聚合统计：调用次数/平均/最小/最大）和 <code>jdk.MethodTrace</code>（每次调用的事件记录，带可选栈跟踪）。支持通过命令行配置、JFR 配置文件、<code>jcmd</code>、JMX 或 <code>RemoteRecordingStream</code> 远程控制。过滤器语法类似方法引用（<code>com.foo.Bar::baz</code>）或注解过滤（<code>@jakarta.ws.rs.GET</code>）。</p>
</li>
<li>
<p><strong>实战指南：</strong></p>
<ul>
<li>
<p><strong>如何启用与监控：</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控静态初始化器</span></span><br><span class="line">java -XX:StartFlightRecording:method-timing=::&lt;clinit&gt;,filename=clinit.jfr -jar app.jar</span><br><span class="line">jfr view method-timing clinit.jfr</span><br><span class="line"><span class="comment"># 监控特定类的所有方法</span></span><br><span class="line">java -XX:StartFlightRecording:method-timing=com.example.CriticalService::*,filename=service.jfr -jar app.jar</span><br><span class="line"><span class="comment"># 通过 jcmd 动态启用（运行时控制）</span></span><br><span class="line">jcmd &lt;pid&gt; JFR.configure method-timing=<span class="string">&quot;com.example.OrderProcessor::processOrder&quot;</span></span><br></pre></td></tr></table></figure>
<p>JFR 会在运行时注入/移除字节码 instrumentation（可远程控制）。</p>
</li>
<li>
<p><strong>最佳应用场景：</strong><br />
启动延迟分析（static initializer）、第三方库耗时度量、生产中针对少量关键方法的低开销精确统计。不同于采样器，这能统计每次方法的调用次数与准确时间（若你只需要热点的近似排名仍用 sampling）。</p>
</li>
</ul>
</li>
<li>
<p><strong>运维与调优视角：</strong></p>
<ul>
<li>
<p><strong>性能与权衡：</strong>  <br />
方法逐个注入事件会带来明显开销，JEP 明确不建议对大量方法同时启用。最佳做法是<strong>精确过滤</strong>（类/方法/注解），并在必要时只启用短时间的录制或在测试环境使用。</p>
</li>
<li>
<p><strong>调优策略：</strong>  <br />
在 CI 或 Canary 环境里使用 <code>MethodTiming</code> 做回归检查（例如关键路径的平均耗时是否在阈值之内）；把过滤规则以配置文件形式存入版本库（便于复现）；远程配置能力允许在生产短暂开启但需设定安全/访问控制。</p>
</li>
</ul>
</li>
</ul>
<h1 id="五-平台支持与兼容性战略性调整"><a class="markdownIt-Anchor" href="#五-平台支持与兼容性战略性调整"></a> 五、平台支持与兼容性：战略性调整</h1>
<p>这一章节涵盖平台支持层面的重要变化，虽然看似不直接影响功能开发，但对架构决策和长期维护有重要意义。</p>
<h2 id="深入解读remove-the-32-bit-x86-port-jep-503-delivered"><a class="markdownIt-Anchor" href="#深入解读remove-the-32-bit-x86-port-jep-503-delivered"></a> 深入解读：Remove the 32-bit x86 Port (JEP 503, Delivered)</h2>
<ul>
<li>
<p><strong>它解决了什么痛点？</strong>  <br />
维护 32-bit x86（Linux/Windows）平台的源代码路径与测试开销越来越大，且阻碍某些新特性的实现（如 Loom、Vector API 的某些优化）。JEP 503 的目标是从 JDK 主线中移除 32-bit x86 的源码与构建支持，以简化开发与加速新功能交付。</p>
</li>
<li>
<p><strong>技术原理剖析：</strong>  <br />
JEP 503 删除源码和构建支持，清理 HotSpot 中针对 32-bit 的特殊分支和补丁，更新构建系统与文档以不再包含该构建目标。目标注意点是保持对其他 32-bit 架构（例如某些嵌入式平台）不受影响。</p>
</li>
<li>
<p><strong>架构师的思考：</strong></p>
<ul>
<li>
<p><strong>架构/运维影响：</strong><br />
如果组织仍在运行 32-bit x86 的生产/边缘实例（极少见，但存在于遗留工业控制或老旧嵌入式系统），将无法使用 JDK 25+ 的二进制分发。多数云/现代服务器均为 64-bit，影响有限。</p>
</li>
<li>
<p><strong>迁移与兼容性：</strong><br />
对仍在 32-bit 上的系统，要么维持在旧 JDK（例如长期支持的旧版本），要么计划尽快升级操作系统和硬件。构建管线中若有混合平台（CI runner 包含 32-bit），要移除相关构建目标。</p>
</li>
<li>
<p><strong>落地建议：</strong><br />
审核现有部署环境，确认无 32-bit x86 依赖；更新 CI/CD 构建矩阵；制定遗留系统的升级时间表或维护策略；在迁移到 JDK 25+ 前评估硬件升级成本与业务价值。</p>
</li>
</ul>
</li>
</ul>
<h1 id="总结与展望面向未来的-java-平台"><a class="markdownIt-Anchor" href="#总结与展望面向未来的-java-平台"></a> 总结与展望：面向未来的 Java 平台</h1>
<p>JDK 25 并不只是又一个半年版本，它是最新 LTS，也是一个“收割与固化”的版本：那些在 JDK 24 实验/预览中的不错特性在 25 中成熟或成为正式产品／预览；同时语言向减少样板与提高表达力靠拢，并发与 GC 模型在性能 &amp;资源利用上有实质性优化；安全与可观察性也进步显著。对资深工程师而言，这意味着现有架构中在启动、内存占用、并发状态管理、安全协议实现上的旧权衡正变得松动：可以选择更轻量、更统一且更可预测的方案。</p>
<h2 id="未来预测与讨论"><a class="markdownIt-Anchor" href="#未来预测与讨论"></a> 未来预测与讨论</h2>
<ol>
<li><strong>Project Valhalla 的继续推进</strong> —— primitive patterns 与 Vector API 的演进，以及 Stable Values 与 scoped values，预示着 value types /泛型 over primitives /更高性能的低级数据结构将是未来几年 Java 的核心方向。</li>
<li><strong>AOT + 映像 +预热优化成为主流运维策略</strong>，尤其在云原生 /serverless /边缘环境中。团队将需要把“预热 /训练 /缓存 /版本管理”流程纳入标准部署管线。</li>
<li><strong>并发 /状态共享模型规范化</strong> 会推动更多设计范式变化：向 structured concurrency + scoped / stable value 的结合，看起来将成为现代框架（web 框架 /微服务 /消息处理）的标准组件。</li>
<li><strong>安全与库标准化</strong>：随着 KDF API + PEM 支持等进入平台标准库，外部库依赖将减少，安全审计与跨库兼容性问题将减少；但也意味着平台 API 的行为规范和文档质量比以往更关键。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK25</tag>
      </tags>
  </entry>
  <entry>
    <title>MinIO 预签名 URL 报错 SignatureDoesNotMatch 的排查复盘</title>
    <url>/2025/minio-%E9%A2%84%E7%AD%BE%E5%90%8D-url-%E6%8A%A5%E9%94%99-signaturedoesnotmatch-%E7%9A%84%E6%8E%92%E6%9F%A5%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1>
<p>我们的文件服务基于 MinIO 搭建，文件访问走的是预签名 URL。<br />
后端使用 AWS S3 SDK 生成签名，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.2.101:9000/bucketname/68c1390a.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;...</span><br></pre></td></tr></table></figure>
<p>在内部环境访问一切正常。</p>
<p>但生产环境要求通过统一域名出口，因此我们在 Nginx 上加了一层代理，提供给外部系统的 URL 是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://oss.example.com/oss/68c1390a.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;...</span><br></pre></td></tr></table></figure>
<p>上线后，用户反馈文件全部访问失败，返回错误如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Error</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Code</span>&gt;</span>SignatureDoesNotMatch<span class="tag">&lt;/<span class="name">Code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Message</span>&gt;</span>The request signature we calculated does not match the signature you provided. Check your key and signing method.<span class="tag">&lt;/<span class="name">Message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Key</span>&gt;</span>68c1390a.jpg<span class="tag">&lt;/<span class="name">Key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BucketName</span>&gt;</span>bucketname<span class="tag">&lt;/<span class="name">BucketName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span>&gt;</span>/bucketname/68c1390a.jpg<span class="tag">&lt;/<span class="name">Resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Error</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="初步分析"><a class="markdownIt-Anchor" href="#初步分析"></a> 初步分析</h1>
<p>错误提示是 <strong>签名不匹配</strong>。考虑到签名 URL 是在后端用 AWS S3 客户端生成的，代码逻辑没有改动，因此怀疑是 <strong>代理转发时导致的请求变化</strong>。</p>
<h1 id="深入理解-s3-签名机制"><a class="markdownIt-Anchor" href="#深入理解-s3-签名机制"></a> 深入理解 S3 签名机制</h1>
<p>S3 V4 签名在计算时，会严格依赖以下请求信息：</p>
<ul>
<li><strong>Host</strong>：请求头里的 <code>Host</code> 必须与签名时一致</li>
<li><strong>URI Path</strong>：路径必须一致，不能多也不能少</li>
<li><strong>Scheme (协议)</strong>：http/https 不同也会导致签名差异</li>
<li><strong>Signed Headers</strong>：只要包含在 <code>X-Amz-SignedHeaders</code> 里的头部，值都必须完全匹配</li>
</ul>
<p>因此，哪怕 Nginx 在转发时稍微改动了路径、Host 或协议，MinIO 后端重新计算签名时就会发现不一致，从而报错。</p>
<h1 id="nginx-配置的问题"><a class="markdownIt-Anchor" href="#nginx-配置的问题"></a> Nginx 配置的问题</h1>
<p>最初的代理配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /oss/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.2.101:9000/bucketname/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题有两点：</p>
<ol>
<li>
<p><strong>Host 不一致</strong><br />
后端签名时的 URL 是 <code>192.168.2.101:9000</code>，但请求经过 Nginx 时 <code>Host</code> 变成了 <code>oss.example.com</code>。</p>
</li>
<li>
<p><strong>协议不一致</strong><br />
签名用的是 <code>http</code>，外部请求是 <code>https</code>，MinIO 在校验时自然会不一致。</p>
</li>
</ol>
<h1 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h1>
<p>最终的 Nginx 配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件服务代理</span></span><br><span class="line"><span class="section">location</span> /oss/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.2.101:9000/bucketname/;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重点：Host 必须与签名时一致</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="number">192.168.2.101:9000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重点：协议必须与签名时一致（这里签名用的是 http）</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Proto http;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">chunked_transfer_encoding</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_connect_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600</span>;</span><br><span class="line">    <span class="attribute">proxy_send_timeout</span> <span class="number">600</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置解析"><a class="markdownIt-Anchor" href="#配置解析"></a> 配置解析</h2>
<ul>
<li><strong>location + proxy_pass</strong>：直接将 <code>/oss/xxx.jpg</code> 映射到 <code>/bucketname/xxx.jpg</code>。</li>
<li><strong>proxy_set_header Host</strong>：强制使用内网地址 <code>192.168.2.101:9000</code>，和签名时完全一致。</li>
<li><strong>proxy_set_header X-Forwarded-Proto</strong>：告诉后端这是 <code>http</code> 请求，避免 https/http 差异。</li>
</ul>
<p>调整后，再次访问预签名 URL，成功返回文件。</p>
<h1 id="经验总结"><a class="markdownIt-Anchor" href="#经验总结"></a> 经验总结</h1>
<ol>
<li>
<p><strong>S3 签名严格性</strong><br />
预签名 URL 的校验非常敏感，任何请求细节变化都会导致签名不匹配。</p>
</li>
<li>
<p><strong>保持一致是关键</strong></p>
<ul>
<li>Host 要一致</li>
<li>协议要一致</li>
<li>路径要一致</li>
</ul>
</li>
<li>
<p><strong>代理层最好透明转发</strong><br />
如果有条件，尽量避免修改路径或域名映射，否则需要在代理层额外处理。</p>
</li>
</ol>
<h2 id="请求流向图"><a class="markdownIt-Anchor" href="#请求流向图"></a> 请求流向图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as Client (oss.example.com/oss/...)</span><br><span class="line">    participant N as Nginx (oss.example.com)</span><br><span class="line">    participant M as MinIO (192.168.2.101:9000)</span><br><span class="line"></span><br><span class="line">    C-&gt;&gt;N: 请求对象 (GET https://oss.example.com/bucketname/file.jpg)&lt;br/&gt;携带预签名URL</span><br><span class="line">    N-&gt;&gt;M: 转发请求&lt;br/&gt;(GET http://192.168.2.101:9000/bucketname/file.jpg)&lt;br/&gt;Host=192.168.2.101:9000</span><br><span class="line">    M--&gt;&gt;N: 返回对象 (200 OK, file.jpg)</span><br><span class="line">    N--&gt;&gt;C: 返回对象 (200 OK, file.jpg)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术故障复盘与 RCA</category>
      </categories>
      <tags>
        <tag>MinIO</tag>
        <tag>S3签名</tag>
        <tag>预签名URL</tag>
        <tag>SignatureDoesNotMatch</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis Lua 脚本异常：“NOSCRIPT No matching script” 故障分析与修复</title>
    <url>/2025/redis-lua-%E8%84%9A%E6%9C%AC%E5%BC%82%E5%B8%B8%EF%BC%9A%E2%80%9Cnoscript-no-matching-script%E2%80%9D-%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90%E4%B8%8E%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h1 id="一-事件背景"><a class="markdownIt-Anchor" href="#一-事件背景"></a> 一、事件背景</h1>
<p>项目使用 <strong>Spring Data Redis + Redisson</strong> 执行 Lua 脚本，实现分布式原子更新逻辑。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">redisScript.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;scripts/cas.lua&quot;</span>)</span><br><span class="line">));</span><br><span class="line">redisScript.setResultType(List.class);</span><br></pre></td></tr></table></figure>
<p>Redis 为<strong>单机模式</strong>部署。<br />
镜像重构后应用启动正常，但执行 Lua 脚本时报错。</p>
<h1 id="二-问题现象"><a class="markdownIt-Anchor" href="#二-问题现象"></a> 二、问题现象</h1>
<h2 id="报错堆栈"><a class="markdownIt-Anchor" href="#报错堆栈"></a> 报错堆栈</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: org.redisson.client.RedisException: NOSCRIPT No matching script. Please use EVAL..</span><br><span class="line">channel: [id: 0xad12ab10, L:/172.18.0.18:56912 - R:172.17.0.1:6379]</span><br><span class="line">command: (EVALSHA), params: [f21f6c8c24daabf..., ...]</span><br></pre></td></tr></table></figure>
<p>含义：Redis 未找到匹配的脚本 SHA1 缓存，因此 Redisson 无法执行 <code>EVALSHA</code>。</p>
<h1 id="三-初步分析"><a class="markdownIt-Anchor" href="#三-初步分析"></a> 三、初步分析</h1>
<p>Redis 的 Lua 执行过程：</p>
<ol>
<li>客户端首次使用 <code>EVAL</code> 发送脚本；</li>
<li>Redis 编译脚本，缓存其内容与 SHA1；</li>
<li>后续客户端使用 <code>EVALSHA</code> 直接执行；</li>
<li>若 SHA1 不存在，返回 <code>NOSCRIPT</code>。</li>
</ol>
<p>因此，本次报错说明：</p>
<blockquote>
<p>Redis 并未加载到客户端所认为的“同一份脚本内容”。</p>
</blockquote>
<h1 id="四-排查过程"><a class="markdownIt-Anchor" href="#四-排查过程"></a> 四、排查过程</h1>
<h2 id="1️⃣-验证-redis-是否缓存脚本"><a class="markdownIt-Anchor" href="#1️⃣-验证-redis-是否缓存脚本"></a> 1️⃣ 验证 Redis 是否缓存脚本</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli SCRIPT EXISTS f21f6c8c24daabf...</span><br></pre></td></tr></table></figure>
<p>返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) (integer) 0</span><br></pre></td></tr></table></figure>
<p>→ Redis 未缓存该 SHA1。</p>
<h2 id="2️⃣-检查-lua-脚本内容"><a class="markdownIt-Anchor" href="#2️⃣-检查-lua-脚本内容"></a> 2️⃣ 检查 Lua 脚本内容</h2>
<p><code>cas.lua</code> 文件中含中文注释：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 校验版本号</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>删除中文注释后再执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --<span class="built_in">eval</span> scripts/cas.lua</span><br></pre></td></tr></table></figure>
<p>✅ Redis 能正常执行。<br />
→ 表面上似乎“中文注释导致 Redis 编译失败”，但实际上：</p>
<blockquote>
<p>Redis 支持 UTF-8 中文脚本，真正问题是客户端加载时<strong>字符编码被破坏</strong>，发送给 Redis 的内容与原文件不一致。</p>
</blockquote>
<h2 id="3️⃣-检查容器环境编码"><a class="markdownIt-Anchor" href="#3️⃣-检查容器环境编码"></a> 3️⃣ 检查容器环境编码</h2>
<p>进入容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locale: Cannot set LC_CTYPE...</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LANGUAGE=zh_CN:zh</span><br><span class="line">LC_ALL=zh_CN.UTF-8</span><br></pre></td></tr></table></figure>
<p>虽然声明了 UTF-8，但系统未安装 locale 数据。<br />
结果：</p>
<ul>
<li>JVM 默认编码回退为 ASCII (<code>ANSI_X3.4-1968</code>)；</li>
<li><code>ResourceScriptSource</code> 按默认编码读取脚本；</li>
<li>中文注释被错误解析为乱码；</li>
<li>Redis 收到的字节序列与原文件不同；</li>
<li>→ SHA1 不匹配；</li>
<li>→ Redis 报 <code>NOSCRIPT</code>。</li>
</ul>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -XshowSettings:properties -version | grep file.encoding</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file.encoding = ANSI_X3.4-1968</span><br></pre></td></tr></table></figure>
<p>证实了 JVM 默认编码非 UTF-8。</p>
<h2 id="4️⃣-验证-redisson-脚本加载机制"><a class="markdownIt-Anchor" href="#4️⃣-验证-redisson-脚本加载机制"></a> 4️⃣ 验证 Redisson 脚本加载机制</h2>
<p>Spring 的 <code>ResourceScriptSource</code> 使用系统默认字符集读取脚本文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Charset.defaultCharset() <span class="comment">// =&gt; 取决于 JVM file.encoding</span></span><br></pre></td></tr></table></figure>
<p>若环境未启用 UTF-8，脚本在加载时被破坏。<br />
此时客户端计算的 SHA 与 Redis 实际接收内容的 SHA 不同。<br />
Redis 自然找不到该脚本 → 报 <code>NOSCRIPT</code>。</p>
<h1 id="五-根因分析-rca"><a class="markdownIt-Anchor" href="#五-根因分析-rca"></a> 五、根因分析 (RCA)</h1>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>问题类型</td>
<td>环境编码不一致</td>
</tr>
<tr>
<td>触发条件</td>
<td>Lua 脚本中包含中文字符</td>
</tr>
<tr>
<td>直接原因</td>
<td>JVM 读取脚本时使用非 UTF-8 编码导致内容损坏</td>
</tr>
<tr>
<td>最终结果</td>
<td>Redis 与客户端 SHA1 不一致，报 <code>NOSCRIPT</code></td>
</tr>
</tbody>
</table>
<h1 id="六-解决方案"><a class="markdownIt-Anchor" href="#六-解决方案"></a> 六、解决方案</h1>
<h2 id="快速修复方案环境级"><a class="markdownIt-Anchor" href="#快速修复方案环境级"></a> ✅ 快速修复方案（环境级）</h2>
<p>在 Dockerfile 中正确配置 UTF-8 locale：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y locales tzdata &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/* &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;LANG=zh_CN.UTF-8&quot;</span> &gt;&gt; /etc/environment &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;LC_ALL=zh_CN.UTF-8&quot;</span> &gt;&gt; /etc/environment</span></span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale</span><br><span class="line">java -XshowSettings:properties -version | grep file.encoding</span><br><span class="line"><span class="comment"># 应为 UTF-8</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="稳健方案代码级"><a class="markdownIt-Anchor" href="#稳健方案代码级"></a> 🧩 稳健方案（代码级）</h2>
<p>避免依赖系统编码，手动读取脚本并指定 UTF-8：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> Files.readString(</span><br><span class="line">    Paths.get(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;scripts/cas.lua&quot;</span>).getURI()),</span><br><span class="line">    StandardCharsets.UTF_8</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DefaultRedisScript&lt;List&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisScript.setResultType(List.class);</span><br></pre></td></tr></table></figure>
<p>此方法绕过 <code>ResourceScriptSource</code>，完全杜绝编码不一致问题。</p>
<h1 id="七-经验总结"><a class="markdownIt-Anchor" href="#七-经验总结"></a> 七、经验总结</h1>
<table>
<thead>
<tr>
<th>项目</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>故障类型</td>
<td>Redis Lua 脚本执行失败</td>
</tr>
<tr>
<td>报错</td>
<td><code>NOSCRIPT No matching script</code></td>
</tr>
<tr>
<td>根因</td>
<td>脚本加载编码错误，导致 SHA1 不匹配</td>
</tr>
<tr>
<td>快速修复</td>
<td>修正容器 locale 为 UTF-8</td>
</tr>
<tr>
<td>稳健方案</td>
<td>代码中显式使用 UTF-8</td>
</tr>
<tr>
<td>预防</td>
<td>构建时检测 <code>file.encoding</code>，避免中文脚本</td>
</tr>
</tbody>
</table>
<h1 id="八-附录排查命令"><a class="markdownIt-Anchor" href="#八-附录排查命令"></a> 八、附录：排查命令</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis 是否缓存脚本</span></span><br><span class="line">redis-cli SCRIPT EXISTS &lt;sha1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空缓存脚本</span></span><br><span class="line">redis-cli SCRIPT FLUSH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 Lua 编译</span></span><br><span class="line">redis-cli --<span class="built_in">eval</span> scripts/test.lua</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 JVM 编码</span></span><br><span class="line">java -XshowSettings:properties -version | grep file.encoding</span><br></pre></td></tr></table></figure>
<h1 id="九-结语"><a class="markdownIt-Anchor" href="#九-结语"></a> 九、结语</h1>
<blockquote>
<p>Redis 与 Redisson 本身没有问题，根因在于系统层的字符编码不一致。</p>
</blockquote>
<p><strong>经验教训：</strong></p>
<ul>
<li>容器 locale 是 JVM 编码的隐性依赖；</li>
<li>生产环境应强制统一 <code>file.encoding=UTF-8</code>；</li>
<li>加载脚本或配置文件时，应显式指定编码；</li>
<li>避免在 Lua 等脚本中使用中文注释，以降低环境依赖。</li>
</ul>
]]></content>
      <categories>
        <category>技术故障复盘与 RCA</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title>现代企业应用中的Spring Integration</title>
    <url>/2025/spring-integration/</url>
    <content><![CDATA[<h1 id="是什么"><a class="markdownIt-Anchor" href="#是什么"></a> 是什么</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctaW50ZWdyYXRpb24vcmVmZXJlbmNlL2luZGV4Lmh0bWw=">Spring Integration Reference Guide<i class="fa fa-external-link-alt"></i></span></p>
<p>Spring Integration 提供了 Spring 编程模型的扩展，<strong>它支持基于 Spring 的应用程序内的轻量级消息传递，并支持通过声明性适配器与外部系统集成</strong>。这些适配器提供了比 Spring 对远程处理、消息传递和调度的支持更高级别的抽象。</p>
<p>Spring Integration 的主要目标是<strong>提供一个简单的模型来构建企业集成解决方案，同时保持关注点分离</strong>，这对于生成可维护、可测试的代码至关重要。</p>
<p>Spring Integration 支持消息驱动的体系结构，其中控制反转适用于运行时问题，<strong>例如何时应运行某些业务逻辑以及应将响应发送到何处。它支持消息的路由和转换，以便可以集成不同的传输和不同的数据格式，而不会影响可测试性</strong>。换句话说，<strong>消息传递和集成问题由框架处理。业务组件与基础设施进一步隔离</strong>，开发人员可以减轻复杂的集成职责。</p>
<h1 id="什么促使了-spring-integration-的诞生"><a class="markdownIt-Anchor" href="#什么促使了-spring-integration-的诞生"></a> 什么促使了 Spring Integration 的诞生</h1>
<ol>
<li><strong>复杂的应用集成需求</strong> 在现代企业应用中，应用系统应用场景复杂，需要进行互相通信和数据交互。</li>
<li><strong>标准化的集成模型</strong> 基于 EIP (Enterprise Integration Patterns)，Spring Integration 带来了一系列标准化的构件，便于应用程序快速构建。</li>
<li><strong>便利的 Spring 介入支持</strong> Spring 充分利用了自带的配置管理和 AOP 功能，使得消息驱动算法和功能以一致方式进行配置和扩展。</li>
<li><strong>前端和后端集成需求</strong> Spring Integration 提供了多样化的连接器，轻松完成与实现 REST, WebSocket, MQTT, Kafka 等通信协议的集成。</li>
</ol>
<h1 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h1>
<h2 id="message"><a class="markdownIt-Anchor" href="#message"></a> Message</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctaW50ZWdyYXRpb24vcmVmZXJlbmNlL21lc3NhZ2UuaHRtbA==">Message :: Spring Integration<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="message-channels"><a class="markdownIt-Anchor" href="#message-channels"></a> Message Channels</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctaW50ZWdyYXRpb24vcmVmZXJlbmNlL2NoYW5uZWwuaHRtbA==">Message Channels :: Spring Integration<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="message-transformer"><a class="markdownIt-Anchor" href="#message-transformer"></a> Message Transformer</h2>
<p>用于转换消息的内容（Payload）或头信息（Headers）。它的主要作用是将消息从一种格式或结构转换为另一种，以满足下游组件或系统的需求。</p>
<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h3>
<p>Transformer 通常通过实现 <code>GenericTransformer</code> 接口或使用注解 <code>@Transformer</code> 来定义</p>
<p>通过 <code>@Transformer</code> 注解定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Transformer(inputChannel = &quot;inputChannel&quot;, outputChannel = &quot;outputChannel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> GenericTransformer&lt;String, String&gt; <span class="title function_">upperCaseTransformer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String::toUpperCase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Lambda 定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IntegrationFlow <span class="title function_">transformFlow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows.from(<span class="string">&quot;inputChannel&quot;</span>)</span><br><span class="line">            .transform((String payload) -&gt; payload + <span class="string">&quot; - Transformed&quot;</span>)</span><br><span class="line">            .channel(<span class="string">&quot;outputChannel&quot;</span>)</span><br><span class="line">            .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="message-filter"><a class="markdownIt-Anchor" href="#message-filter"></a> Message Filter</h2>
<p>用于过滤消息。它根据指定的条件（通过 <code>Expression</code> 或 <code>Predicate</code>）检查传入的消息，如果消息符合条件，则将其传递到下一个通道；否则，消息会被丢弃。消息过滤器通常与发布-订阅通道结合使用，其中多个消费者可能会收到相同的消息，可以使用过滤器来缩小要处理的消息集范围。</p>
<h3 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h3>
<p>基于表达式的过滤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IntegrationFlow <span class="title function_">filterFlow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">            .from(<span class="string">&quot;inputChannel&quot;</span>) <span class="comment">// 输入通道</span></span><br><span class="line">            .filter(<span class="string">&quot;headers[&#x27;type&#x27;] == &#x27;important&#x27;&quot;</span>, <span class="comment">// 仅通过头部为 &#x27;important&#x27; 的消息</span></span><br><span class="line">                    spec -&gt; spec.discardChannel(<span class="string">&quot;discardChannel&quot;</span>)) <span class="comment">// 丢弃的消息进入 discardChannel</span></span><br><span class="line">            .channel(<span class="string">&quot;outputChannel&quot;</span>) <span class="comment">// 输出通道</span></span><br><span class="line">            .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于自定义逻辑的过滤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IntegrationFlow <span class="title function_">customFilterFlow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows</span><br><span class="line">            .from(<span class="string">&quot;inputChannel&quot;</span>)</span><br><span class="line">            .filter((String payload) -&gt; payload.contains(<span class="string">&quot;valid&quot;</span>), <span class="comment">// 仅通过包含 &quot;valid&quot; 的消息</span></span><br><span class="line">                    spec -&gt; spec.throwExceptionOnRejection(<span class="literal">true</span>)) <span class="comment">// 如果消息被丢弃，则抛出异常</span></span><br><span class="line">            .channel(<span class="string">&quot;outputChannel&quot;</span>)</span><br><span class="line">            .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于注解定义过滤器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Filter(inputChannel = &quot;filterInputChannel&quot;, outputChannel = &quot;outputChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filterMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message.startsWith(<span class="string">&quot;valid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="message-router"><a class="markdownIt-Anchor" href="#message-router"></a> Message Router</h2>
<p>用于决定接下来应该接收消息的一个或多个通道。通常，该决定基于消息的内容或消息头中可用的元数据。它类似于一个决策点，可以动态地决定消息的流向。</p>
<h3 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h3>
<ul>
<li><strong>消息分发</strong>：根据消息类型、内容等条件，将消息分发到不同的处理流程。</li>
<li><strong>动态负载</strong>：根据业务逻辑动态选择通道，减少静态配置的复杂性。</li>
<li><strong>业务流程编排</strong>：在复杂的流程中，根据条件动态调整流程。</li>
</ul>
<h3 id="示例-3"><a class="markdownIt-Anchor" href="#示例-3"></a> 示例</h3>
<p>根据消息体内容进行路由：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IntegrationFlow <span class="title function_">payloadRouterFlow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IntegrationFlows.from(<span class="string">&quot;inputChannel&quot;</span>)</span><br><span class="line">            .route(String.class,</span><br><span class="line">                    payload -&gt; payload.contains(<span class="string">&quot;error&quot;</span>) ? <span class="string">&quot;errorChannel&quot;</span> : <span class="string">&quot;normalChannel&quot;</span>)</span><br><span class="line">            .get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解定义路由器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRouter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Router(inputChannel = &quot;inputChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">routeMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (message.contains(<span class="string">&quot;important&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;importantChannel&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;normalChannel&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="service-activator"><a class="markdownIt-Anchor" href="#service-activator"></a> Service Activator</h2>
<p>用于将消息从输入通道转发到具体的业务逻辑处理器，并将处理结果发送到输出通道。</p>
<h3 id="使用场景-2"><a class="markdownIt-Anchor" href="#使用场景-2"></a> 使用场景</h3>
<ul>
<li>处理从某个通道接收到的消息。</li>
<li>转发处理后的消息到其他通道。</li>
<li>实现简单的消息过滤、转换或处理。</li>
</ul>
<h3 id="示例-4"><a class="markdownIt-Anchor" href="#示例-4"></a> 示例</h3>
<p>以下示例展示如何使用 <code>@ServiceActivator</code> 处理 MQTT 消息。当 <code>mqttInputChannel</code> 收到消息时，Spring Integration 会调用 <code>mqttMessageHandler</code>，传递消息给业务逻辑进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean; <span class="keyword">import</span> org.springframework.context.annotation.Configuration; <span class="keyword">import</span> org.springframework.integration.annotation.ServiceActivator; <span class="keyword">import</span> org.springframework.integration.channel.DirectChannel; <span class="keyword">import</span> org.springframework.messaging.Message; <span class="keyword">import</span> org.springframework.messaging.MessageChannel; <span class="keyword">import</span> org.springframework.messaging.MessageHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqttIntegrationConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageChannel <span class="title function_">mqttInputChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectChannel</span>(); <span class="comment">// 定义一个输入通道</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;mqttInputChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MessageHandler <span class="title function_">mqttMessageHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> message.getHeaders().get(<span class="string">&quot;mqtt_receivedTopic&quot;</span>, String.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> (String) message.getPayload();</span><br><span class="line">            System.out.println(<span class="string">&quot;Received message: &quot;</span> + payload + <span class="string">&quot; from topic: &quot;</span> + topic);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要将处理后的消息发送到另一个通道，可以指定输出通道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServiceActivator(inputChannel = &quot;mqttInputChannel&quot;, outputChannel = &quot;processedOutputChannel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Processing message: &quot;</span> + message);</span><br><span class="line">    <span class="keyword">return</span> message.toUpperCase(); <span class="comment">// 返回处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="message-gateway"><a class="markdownIt-Anchor" href="#message-gateway"></a> Message Gateway</h2>
<p>用于创建消息网关（Messaging Gateway）。它将消息发送到 Spring Integration 的消息通道，同时允许我们以接口的形式调用消息流，从而在应用程序中实现解耦和更高的可读性。</p>
<ol>
<li><strong>提供接口调用的入口</strong><br />
使用 <code>@MessagingGateway</code> 定义的接口是消息流的入口点，调用接口方法即可向消息通道发送消息。接口的具体由 <code>GatewayProxyFactoryBean</code> 创建动态代理对象实现。</li>
<li><strong>实现业务逻辑与消息流的解耦</strong><br />
应用程序调用接口的方法，不需要直接处理消息通道的具体细节。</li>
<li><strong>简化配置</strong><br />
自动将接口与消息通道绑定，无需手动配置复杂的 Spring Integration 流程。</li>
<li><strong>支持请求-回复模式</strong><br />
可以轻松实现异步或同步的请求-回复消息交互。</li>
</ol>
<h3 id="示例-5"><a class="markdownIt-Anchor" href="#示例-5"></a> 示例</h3>
<p>以下是一个使用 <code>@MessagingGateway</code> 发送消息到 MQTT 的完整示例。</p>
<ol>
<li>
<p>配置消息网关和出站适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.integration.annotation.MessagingGateway;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.channel.DirectChannel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.outbound.MqttPahoMessageHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.integration.mqtt.support.DefaultPahoMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqttConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageChannel <span class="title function_">mqttOutboundChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectChannel</span>(); <span class="comment">// 定义输出通道</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MqttPahoMessageHandler <span class="title function_">mqttOutboundHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MqttPahoMessageHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttPahoMessageHandler</span>(<span class="string">&quot;clientId&quot;</span>, mqttClientFactory());</span><br><span class="line">        handler.setAsync(<span class="literal">true</span>);</span><br><span class="line">        handler.setDefaultQos(<span class="number">1</span>);</span><br><span class="line">        handler.setDefaultTopic(<span class="string">&quot;default/topic&quot;</span>);</span><br><span class="line">        handler.setOutputChannel(mqttOutboundChannel());</span><br><span class="line">        handler.setConverter(<span class="keyword">new</span> <span class="title class_">DefaultPahoMessageConverter</span>());</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MqttClientFactory <span class="title function_">mqttClientFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultMqttPahoClientFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMqttPahoClientFactory</span>();</span><br><span class="line">        <span class="type">MqttConnectOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttConnectOptions</span>();</span><br><span class="line">        options.setServerURIs(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;tcp://broker.hivemq.com:1883&quot;</span>&#125;);</span><br><span class="line">        options.setCleanSession(<span class="literal">true</span>);</span><br><span class="line">        factory.setConnectionOptions(options);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义消息网关接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessagingGateway(defaultRequestChannel = &quot;mqttOutboundChannel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MqttGateway</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendToMqtt</span><span class="params">(String data)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendToMqtt</span><span class="params">(<span class="meta">@Header(&quot;mqtt_topic&quot;)</span> String topic, String data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用网关发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqttService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MqttGateway mqttGateway;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 发送到默认主题</span></span><br><span class="line">        mqttGateway.sendToMqtt(<span class="string">&quot;Hello MQTT!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到指定主题</span></span><br><span class="line">        mqttGateway.sendToMqtt(<span class="string">&quot;custom/topic&quot;</span>, <span class="string">&quot;Message to custom topic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="请求-回复支持"><a class="markdownIt-Anchor" href="#请求-回复支持"></a> 请求-回复支持</h3>
<p>如果接口方法有返回值，可以实现请求-回复模式。<code>replyChannel</code> 允许调用方通过指定的通道接收对应的响应消息。当需要从 <code>replyChannel</code> 找出与请求相关的回复时，通常依赖于消息的 <code>correlationId</code> 或者通过 <code>MessageHeaders</code> 来确保请求和回复的关联。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessagingGateway(defaultRequestChannel = &quot;requestChannel&quot;, defaultReplyChannel = &quot;replyChannel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestReplyGateway</span> &#123;</span><br><span class="line">    String <span class="title function_">sendAndReceive</span><span class="params">(String data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="同步处理请求-回复"><a class="markdownIt-Anchor" href="#同步处理请求-回复"></a> 同步处理请求-回复</h4>
<ol>
<li>
<p>配置请求-回复通道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestReplyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageChannel <span class="title function_">requestChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectChannel</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageChannel <span class="title function_">replyChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectChannel</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;requestChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> MessageHandler <span class="title function_">requestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟处理逻辑并发送响应</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;Response to: &quot;</span> + message.getPayload();</span><br><span class="line">            Message&lt;String&gt; replyMessage = MessageBuilder.withPayload(payload)</span><br><span class="line">                    .setHeader(MessageHeaders.REPLY_CHANNEL, message.getHeaders().getReplyChannel())</span><br><span class="line">                    .setCorrelationId(message.getHeaders().getId())</span><br><span class="line">                    .build();</span><br><span class="line">            ((MessageChannel) message.getHeaders().getReplyChannel()).send(replyMessage);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>MessagingTemplate</code> 同步请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.integration.core.MessagingTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestReplyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessagingTemplate messagingTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageChannel requestChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageChannel replyChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RequestReplyService</span><span class="params">(MessageChannel requestChannel, MessageChannel replyChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.messagingTemplate = <span class="keyword">new</span> <span class="title class_">MessagingTemplate</span>();</span><br><span class="line">        <span class="built_in">this</span>.requestChannel = requestChannel;</span><br><span class="line">        <span class="built_in">this</span>.replyChannel = replyChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendAndReceive</span><span class="params">(String requestPayload)</span> &#123;</span><br><span class="line">        Message&lt;String&gt; requestMessage = MessageBuilder.withPayload(requestPayload)</span><br><span class="line">                .setReplyChannel(replyChannel)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 使用 MessagingTemplate 发送请求并同步接收响应</span></span><br><span class="line">        Message&lt;?&gt; replyMessage = messagingTemplate.sendAndReceive(requestChannel, requestMessage);</span><br><span class="line">        <span class="keyword">return</span> replyMessage != <span class="literal">null</span> ? replyMessage.getPayload().toString() : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>sendAndReceive</code> 方法时，<code>MessagingTemplate</code> 会自动等待 <code>replyChannel</code> 的响应。</p>
</li>
</ol>
<h4 id="异步处理请求-回复"><a class="markdownIt-Anchor" href="#异步处理请求-回复"></a> 异步处理请求-回复</h4>
<ol>
<li>
<p>配置异步处理机制</p>
<p>如果需要异步处理请求和回复，可以通过 <code>ExecutorChannel</code> 或其他机制，将回复存储到一个映射中（例如 <code>Map</code> 或 <code>CompletableFuture</code>）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageChannel <span class="title function_">asyncReplyChannel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">    executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">    executor.setQueueCapacity(<span class="number">50</span>);</span><br><span class="line">    executor.initialize();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecutorChannel</span>(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>CompletableFuture</code> 管理异步请求-回复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncRequestReplyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, CompletableFuture&lt;String&gt;&gt; futureMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageChannel requestChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageChannel asyncReplyChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AsyncRequestReplyService</span><span class="params">(MessageChannel requestChannel, MessageChannel asyncReplyChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requestChannel = requestChannel;</span><br><span class="line">        <span class="built_in">this</span>.asyncReplyChannel = asyncReplyChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">sendRequest</span><span class="params">(String requestPayload)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">correlationId</span> <span class="operator">=</span> java.util.UUID.randomUUID().toString();</span><br><span class="line">        CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        futureMap.put(correlationId, future);</span><br><span class="line"></span><br><span class="line">        Message&lt;String&gt; requestMessage = MessageBuilder.withPayload(requestPayload)</span><br><span class="line">                .setReplyChannel(asyncReplyChannel)</span><br><span class="line">                .setCorrelationId(correlationId)</span><br><span class="line">                .build();</span><br><span class="line">        requestChannel.send(requestMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ServiceActivator(inputChannel = &quot;asyncReplyChannel&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReply</span><span class="params">(Message&lt;String&gt; replyMessage)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">correlationId</span> <span class="operator">=</span> (String) replyMessage.getHeaders().getCorrelationId();</span><br><span class="line">        <span class="keyword">if</span> (correlationId != <span class="literal">null</span> &amp;&amp; futureMap.containsKey(correlationId)) &#123;</span><br><span class="line">            CompletableFuture&lt;String&gt; future = futureMap.remove(correlationId);</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="literal">null</span>) &#123;</span><br><span class="line">                future.complete(replyMessage.getPayload());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>sendRequest</code> 方法发送请求时，返回一个 <code>CompletableFuture</code>，当回复到达时，<code>handleReply</code> 方法会完成该 <code>CompletableFuture</code>。</p>
</li>
</ol>
<h1 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h1>
<ol>
<li><strong>消息创建</strong> 消息通常通过 <code>MessageBuilder</code> 或直接通过其实现类（如 <code>GenericMessage</code>）进行创建。消息包含一个 <code>payload</code> （消息主体）和可选的 <code>headers</code> （消息头）。</li>
<li><strong>消息发送</strong> 消息被发送到一个 <code>MessageChannel</code>。Spring Integration 提供了多种消息通道实现，如 <code>DirectChannel</code>、<code>QueueChannel</code> 等。</li>
<li><strong>路由消息</strong> 消息通过 <code>MessageChannel</code> 被路由到一个或多个消息处理器（Message Handler）。路由器（Router）可以根据消息头或消息体的内容将消息路由到不同的通道。</li>
<li><strong>处理消息</strong> 消息处理器（Message Handler）接收消息并执行相应的处理逻辑。处理器可以是一个 <code>@ServiceActivator</code> 注解的方法，也可以是其他类型的处理器。</li>
<li><strong>转换消息</strong> 消息转换器（Transformer）可以在消息处理过程中更改消息的格式或内容。</li>
<li><strong>答复消息</strong> 某些消息处理器可能会生成一个新的消息作为响应，并将其发送到一个 <code>replyChannel</code>。</li>
<li><strong>结束</strong> 消息的生命周期在其被处理完成并且不再需要进一步处理时结束。这通常意味着消息已经被处理器消费，或者已经被成功路由到外部系统。</li>
</ol>
<p><img src="https://img.picgo.net/2025/02/26/Pasted-image-20250113090819d745aac6a44ed78a.png" alt="" /></p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83Mjc2Njc4MDk4NDA5OTc5OTM5">关于 Spring Integration 你知道多少，包含集成MQTT案例讲述及源码适合的读者，略微了解SpringB - 掘金<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Integration</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Integration</tag>
      </tags>
  </entry>
  <entry>
    <title>一次由Jenkins流水线中不当Docker清理引发的服务器超时事件复盘</title>
    <url>/2025/%E4%B8%80%E6%AC%A1%E7%94%B1jenkins%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E4%B8%8D%E5%BD%93docker%E6%B8%85%E7%90%86%E5%BC%95%E5%8F%91%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B6%85%E6%97%B6%E4%BA%8B%E4%BB%B6%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h2 id="1-事件背景"><a class="markdownIt-Anchor" href="#1-事件背景"></a> 1. 事件背景</h2>
<p><code>jenkins-worker-01</code> 是我司核心的CI/CD构建节点，负责执行多个项目的Jenkins Pipeline任务。为了保持节点环境整洁，多数流水线在构建结束后都包含一个标准的“清理工作区”阶段，该阶段会自动删除本次构建产生的悬空Docker镜像（dangling images）。</p>
<p>某日下午，开发团队在一个长期未成功构建的项目 <code>project-zeus</code> 上触发了一次新的构建。流水线在执行到最后的清理阶段时，Jenkins的Web界面显示该阶段长时间处于“运行中”状态，无任何日志输出。</p>
<p>该清理阶段的核心逻辑如下 (摘自 <code>Jenkinsfile</code>):</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Cleanup Workspace&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            <span class="comment">// 查找悬空镜像ID并拼接成一个字符串</span></span><br><span class="line">            <span class="keyword">def</span> danglingImages = sh(</span><br><span class="line">                <span class="symbol">script:</span> <span class="string">&#x27;docker images -f &quot;dangling=true&quot; -q&#x27;</span>,</span><br><span class="line">                <span class="symbol">returnStdout:</span> <span class="literal">true</span></span><br><span class="line">            ).replaceAll(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在，则一次性全部删除</span></span><br><span class="line">            <span class="keyword">if</span> (danglingImages) &#123;</span><br><span class="line">                echo <span class="string">&quot;Cleaning up dangling images...&quot;</span></span><br><span class="line">                sh <span class="string">&quot;docker rmi $&#123;danglingImages&#125;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于该项目及其他项目在 <code>jenkins-worker-01</code> 节点上累积了数月的构建失败产物，本次清理任务需要处理的悬空镜像数量预估超过了500个。</p>
<h2 id="2-故障现象"><a class="markdownIt-Anchor" href="#2-故障现象"></a> 2. 故障现象</h2>
<ol>
<li>
<p><strong>Jenkins任务卡死</strong>：<code>project-zeus</code> 流水线的清理阶段长时间运行不结束。</p>
</li>
<li>
<p><strong>节点响应迟钝</strong>：尝试通过SSH登录 <code>jenkins-worker-01</code> 节点排查问题，发现终端响应极其缓慢。</p>
</li>
<li>
<p><strong>核心服务无响应</strong>：在节点上执行任何 <code>systemctl</code> 命令（如 <code>systemctl status jenkins-agent</code>），均返回超时错误：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Failed to activate service &#x27;org.freedesktop.systemd1&#x27;: timed out</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>监控系统告警</strong>：监控平台显示该节点的 <strong>磁盘I/O Wait 指标（%wa）一度超过90%</strong>，多个关键进程处于 <code>D</code> 状态（不可中断睡眠）。</p>
</li>
</ol>
<h2 id="3-排查与处理过程"><a class="markdownIt-Anchor" href="#3-排查与处理过程"></a> 3. 排查与处理过程</h2>
<h3 id="31-初步诊断"><a class="markdownIt-Anchor" href="#31-初步诊断"></a> 3.1 初步诊断</h3>
<p>通过 <code>top</code> 和 <code>iotop</code> 命令艰难地观察到，<code>dockerd</code> 进程正在进行疯狂的磁盘读写，I/O负载极高。确认问题是由于Docker的大规模删除操作引发了I/O性能瓶颈。</p>
<h3 id="32-尝试优雅重启"><a class="markdownIt-Anchor" href="#32-尝试优雅重启"></a> 3.2 尝试优雅重启</h3>
<p>判断系统已无法通过常规手段恢复，首先尝试了标准的 <code>reboot</code> 命令。</p>
<ul>
<li><strong>现象</strong>：终端返回了关机广播信息后，SSH连接挂起，服务器无任何后续响应。</li>
<li><strong>结果</strong>：10分钟后，节点依然存活（可ping通），但Jenkins Agent已断开，所有服务均不可用。<code>reboot</code> 的优雅关机流程被阻塞。</li>
</ul>
<h3 id="33-实施强制重启"><a class="markdownIt-Anchor" href="#33-实施强制重启"></a> 3.3 实施强制重启</h3>
<p>确定 <code>systemd</code> 自身已被I/O问题“冻结”，无法完成关机任务。作为最终手段：</p>
<ol>
<li>通过云服务商的VNC控制台登录服务器。</li>
<li>执行强制重启命令 <code>reboot -f</code>。</li>
<li>系统立即重启，并在启动后执行了文件系统检查（<code>fsck</code>）。随后，节点恢复正常，并重新与Jenkins主节点建立连接。</li>
</ol>
<h2 id="4-根本原因分析-rca"><a class="markdownIt-Anchor" href="#4-根本原因分析-rca"></a> 4. 根本原因分析 (RCA)</h2>
<p>本次故障的根源在于自动化脚本中一个看似无害却极其危险的设计。</p>
<h4 id="41-直接原因"><a class="markdownIt-Anchor" href="#41-直接原因"></a> 4.1 直接原因</h4>
<p><code>systemctl</code> 命令超时是因为它无法与 <code>systemd</code> (PID 1) 进程正常通信。<code>systemd</code> 因等待磁盘I/O完成而被内核挂起，无法响应任何D-Bus请求。</p>
<h4 id="42-根本原因"><a class="markdownIt-Anchor" href="#42-根本原因"></a> 4.2 根本原因</h4>
<p>Jenkins流水线中的 <code>replaceAll('\n', ' ')</code> 代码，将所有悬空镜像的ID拼接成一个巨大的、由空格分隔的字符串。最终执行的 <code>docker rmi $&#123;danglingImages&#125;</code> 命令等同于在shell中执行 <code>docker rmi ID1 ID2 ID3 ... ID500+</code>。这个<strong>单次命令</strong>要求Docker守护进程在短时间内完成数百个镜像的删除操作，瞬间产生的海量I/O请求压垮了服务器的磁盘子系统。</p>
<h4 id="43-连锁反应详解"><a class="markdownIt-Anchor" href="#43-连锁反应详解"></a> 4.3 连锁反应详解</h4>
<ol>
<li><strong>批量指令</strong>：Jenkins脚本构造并执行了一个超长的 <code>docker rmi</code> 命令。</li>
<li><strong>I/O风暴</strong>：<code>dockerd</code> 接收指令后，开始并行或快速串行地删除大量镜像层，引发I/O风暴。</li>
<li><strong><code>systemd</code> 阻塞</strong>：<code>systemd</code> 自身的常规I/O操作（如写日志）被阻塞在拥堵的队列中，导致进程进入 <code>D</code> 状态。</li>
<li><strong>优雅重启失败</strong>：<code>reboot</code> 命令依赖 <code>systemd</code> 来协调关机，而已被阻塞的 <code>systemd</code> 无法执行此任务，导致关机流程死锁。</li>
<li><strong>强制重启成功</strong>：<code>reboot -f</code> 命令绕过了 <code>systemd</code>，直接向内核发送重启指令，因此能够成功执行。</li>
</ol>
<h2 id="5-解决方案与改进措施"><a class="markdownIt-Anchor" href="#5-解决方案与改进措施"></a> 5. 解决方案与改进措施</h2>
<p>为了根除此类隐患，必须从优化自动化脚本和规范流程入手。</p>
<h3 id="51-短期措施修正存在问题的pipeline脚本"><a class="markdownIt-Anchor" href="#51-短期措施修正存在问题的pipeline脚本"></a> 5.1 短期措施：修正存在问题的Pipeline脚本</h3>
<p>立即审计所有 <code>Jenkinsfile</code>，将上述危险的清理逻辑替换为安全、可控的迭代式清理。</p>
<p><strong>【修正后的安全清理阶段 (Groovy)】</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">stage(<span class="string">&#x27;Safe Cleanup Workspace&#x27;</span>) &#123;</span><br><span class="line">    steps &#123;</span><br><span class="line">        script &#123;</span><br><span class="line">            echo <span class="string">&quot;正在查找悬空镜像...&quot;</span></span><br><span class="line">            <span class="comment">// 获取ID列表并分割成数组，为逐个处理做准备</span></span><br><span class="line">            <span class="keyword">def</span> danglingImagesList = sh(</span><br><span class="line">                <span class="symbol">script:</span> <span class="string">&#x27;docker images -f &quot;dangling=true&quot; -q&#x27;</span>,</span><br><span class="line">                <span class="symbol">returnStdout:</span> <span class="literal">true</span></span><br><span class="line">            ).trim().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (danglingImagesList &amp;&amp; danglingImagesList[<span class="number">0</span>]) &#123;</span><br><span class="line">                echo <span class="string">&quot;发现 $&#123;danglingImagesList.size()&#125; 个悬空镜像，将逐个安全清理...&quot;</span></span><br><span class="line">                <span class="comment">// 循环删除，避免单次命令造成I/O风暴</span></span><br><span class="line">                <span class="keyword">for</span> (imageID <span class="keyword">in</span> danglingImagesList) &#123;</span><br><span class="line">                    echo <span class="string">&quot;--&gt; 正在删除镜像: $&#123;imageID&#125;&quot;</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sh <span class="string">&quot;docker rmi $&#123;imageID&#125;&quot;</span></span><br><span class="line">                        <span class="comment">// 关键：每次删除后暂停2秒，平滑I/O负载</span></span><br><span class="line">                        sh <span class="string">&quot;sleep 2&quot;</span> </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        echo <span class="string">&quot;删除镜像 $&#123;imageID&#125; 失败: $&#123;e.getMessage()&#125;&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                echo <span class="string">&quot;没有发现悬空镜像。&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>核心改进</strong>：通过将ID列表分割成数组，并使用 <code>for</code> 循环和 <code>sleep</code>，将集中的I/O压力有效分散，从根本上避免了I/O风暴。</p>
<h3 id="52-长期建议架构与流程优化"><a class="markdownIt-Anchor" href="#52-长期建议架构与流程优化"></a> 5.2 长期建议：架构与流程优化</h3>
<ol>
<li><strong>代码审查流程</strong>：将 CI/CD 流水线脚本 (<code>Jenkinsfile</code> 等) 纳入代码审查 (Code Review) 范围，重点关注其中与系统资源交互（如文件、网络、进程操作）相关的部分。</li>
<li><strong>节点存储升级</strong>：评估并推动将核心构建节点的Docker工作目录迁移至SSD，以大幅提升I/O承载能力。</li>
<li><strong>专用清理任务</strong>：创建一个独立的、专用的Jenkins维护任务，使用上述安全脚本，在所有节点的业务低峰期（如每日凌晨）统一执行清理，而不是在每个业务流水线后执行。</li>
</ol>
<h2 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6. 总结</h2>
<p>本次事件是一次深刻的教训，它表明<strong>自动化脚本中的“效率陷阱”</strong> 同样致命。一个为了便捷而设计的“一句话命令”，在特定条件下会成为导致系统崩溃的元凶。所有运维和开发人员必须认识到，自动化工具在放大效率的同时，也在放大错误的破坏力。对底层系统（尤其是I/O）的敬畏之心，是构建稳定可靠自动化体系的基石。</p>
]]></content>
      <categories>
        <category>技术故障复盘与 RCA</category>
        <category>系统运维与SRE</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Jenkins</tag>
        <tag>systemd</tag>
        <tag>I/O风暴</tag>
        <tag>系统运维</tag>
        <tag>事件复盘</tag>
        <tag>CI/CD</tag>
        <tag>reboot -f</tag>
        <tag>脚本安全</tag>
        <tag>iowait</tag>
      </tags>
  </entry>
  <entry>
    <title>从时间复杂度到P vs NP：算法复杂度的核心概念</title>
    <url>/2025/%E4%BB%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%B0p-vs-np%EF%BC%9A%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="时间复杂度简介"><a class="markdownIt-Anchor" href="#时间复杂度简介"></a> <strong>时间复杂度简介</strong></h1>
<p>时间复杂度描述的是<strong>程序运行时间随输入规模增长的变化趋势</strong>，而不是具体运行时间。可以理解为程序的“增长率”。例如：</p>
<ul>
<li><strong>O(n)</strong>：输入数据增加 1000 倍，运行时间也增加 1000 倍。</li>
<li><strong>O(1)</strong>：无论数据大小，运行时间基本不变（常数级复杂度）。</li>
<li><strong>O(2ⁿ)</strong>：数据增加 n 倍，运行时间指数级增长，通常计算量极大。</li>
</ul>
<p>时间复杂度通常分为：</p>
<ol>
<li><strong>多项式级复杂度</strong>（如 O(n), O(n²), O(n³)），规模 n 作为底数或真数，计算相对可控。</li>
<li><strong>非多项式级复杂度</strong>（如 O(2ⁿ), O(n!)），增长极快，几乎无法处理大规模数据。</li>
</ol>
<h1 id="p-与-np-问题"><a class="markdownIt-Anchor" href="#p-与-np-问题"></a> <strong>P 与 NP 问题</strong></h1>
<ul>
<li>
<p><strong>P 问题</strong>：存在<strong>多项式时间</strong>求解算法的问题，计算机可以高效解决。例如：</p>
<ul>
<li><strong>最短路径问题</strong>（Dijkstra 算法，O(nlogn)）</li>
<li><strong>矩阵乘法</strong>（O(n³)）</li>
</ul>
</li>
<li>
<p><strong>NP 问题</strong>：无法保证有多项式时间求解算法，但<strong>可以在多项式时间内验证解是否正确</strong>的问题。例如：</p>
<ul>
<li><strong>旅行商问题（TSP）</strong>：给定一组城市，找到一条最短路径经过所有城市一次并返回起点。验证某条路径的长度是否符合要求可以在多项式时间内完成，但找出最优解极难。</li>
<li><strong>整数因子分解</strong>：如 143 = 11 × 13，验证 143 是否是 11 和 13 的乘积很快，但找出 143 的质因子很难（特别是大数）。</li>
</ul>
</li>
</ul>
<h1 id="规约reduction"><a class="markdownIt-Anchor" href="#规约reduction"></a> <strong>规约（Reduction）</strong></h1>
<p>规约是<strong>将一个问题 A 转化为另一个问题 B</strong>，使得<strong>如果能快速求解 B，就能快速求解 A</strong>。这说明 B 至少和 A 一样难，甚至更难。例如：</p>
<ul>
<li><strong>3-SAT 规约到 CLIQUE 问题</strong>（如果能快速求解 CLIQUE，就能快速求解 3-SAT）。</li>
<li><strong>旅行商问题（TSP）规约到哈密顿回路问题（Hamiltonian Cycle）</strong>，即如果能解决哈密顿回路问题，就能解决 TSP。</li>
</ul>
<h1 id="np-完全npc问题"><a class="markdownIt-Anchor" href="#np-完全npc问题"></a> <strong>NP-完全（NPC）问题</strong></h1>
<p>满足以下两个条件：</p>
<ol>
<li>它是 <strong>NP 问题</strong>（可以在多项式时间内验证解）。</li>
<li><strong>所有 NP 问题都能规约到它</strong>，即它至少和所有 NP 问题一样难。</li>
</ol>
<p>所有已知的 NPC 问题目前都没有多项式时间的求解算法，只能用指数级或更慢的方法求解。例如：</p>
<ul>
<li><strong>3-SAT（布尔可满足性问题）</strong>：给定一个由 AND、OR、NOT 组成的逻辑公式，判断是否存在一个变量赋值使其为真。</li>
<li><strong>旅行商问题（TSP）</strong>：寻找经过所有城市的最短路径。</li>
<li><strong>顶点覆盖问题（Vertex Cover）</strong>：在图中找到最少的点，使得所有边至少有一个端点被选中。</li>
</ul>
<p>如果某天有人找到某个 NPC 问题的多项式解法，那么所有 NP 问题都能在多项式时间内求解（即 P = NP），但目前尚无证据证明或反驳这个猜想。</p>
<h1 id="np-hardnp难问题"><a class="markdownIt-Anchor" href="#np-hardnp难问题"></a> <strong>NP-hard（NP难）问题</strong></h1>
<p>NP-hard 问题满足 NPC 的<strong>第二个条件</strong>（所有 NP 问题都能规约到它），但不一定是 NP 问题，即<strong>它不一定能在多项式时间内验证解的正确性</strong>。这些问题通常比 NP 还难。例如：</p>
<ul>
<li><strong>TSP（求最短路径）</strong> 是 NPC 问题，但 <strong>通用 TSP（找出所有可能的路径）</strong> 是 NP-hard。</li>
<li><strong>哈密顿回路问题</strong> 是 NPC，但 <strong>分数规划问题（Fractional Programming）</strong> 是 NP-hard，因为它无法在多项式时间内验证解的正确性。</li>
</ul>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结</strong></h1>
<ul>
<li><strong>P</strong>：能在多项式时间内求解的问题（如最短路径）。</li>
<li><strong>NP</strong>：能在多项式时间内验证解的问题（如 TSP）。</li>
<li><strong>NPC</strong>：NP 且所有 NP 问题都能规约到它（如 3-SAT、TSP）。</li>
<li><strong>NP-hard</strong>：比 NPC 更难，可能无法在多项式时间内验证解（如通用 TSP）。</li>
</ul>
<p>目前，P vs NP 是计算机科学最大的未解问题之一，如果 P = NP，很多密码学系统都会失效！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>无人机直播延迟“黑洞”探秘：从RTMP的累积延迟到WHIP的实时新生</title>
    <url>/2025/%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%9B%B4%E6%92%AD%E5%BB%B6%E8%BF%9F%E2%80%9C%E9%BB%91%E6%B4%9E%E2%80%9D%E6%8E%A2%E7%A7%98%EF%BC%9A%E4%BB%8Ertmp%E7%9A%84%E7%B4%AF%E7%A7%AF%E5%BB%B6%E8%BF%9F%E5%88%B0whip%E7%9A%84%E5%AE%9E%E6%97%B6%E6%96%B0%E7%94%9F/</url>
    <content><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1>
<p>在当今的无人机应用中，高清视频的实时图传是核心能力。无论是电力巡检、应急消防还是安防监控，我们都期望在后方指挥中心的大屏幕上，看到无人机“指哪打哪”的实时画面。我们团队近期在使用大疆无人机（DJI Drone）对接自建的WVP视频平台（基于强大的开源流媒体服务ZLMediaKit）时，就遇到了一个棘手的问题：直播延迟。</p>
<p>我们的架构很简单：大疆无人机通过机载的4G/5G模块，使用标准的RTMP协议将视频流推送到WVP平台。然而，一个“延迟黑洞”悄然出现，几乎让整个实时监控系统瘫痪。</p>
<p><img src="https://origin.picgo.net/2025/08/11/04da3b63b2364e49178d6969e90caf103616d74f93ef9031.png" alt="直播推流架构" title="直播推流架构" /></p>
<p><em>(示意图：大疆无人机 -&gt; 4G/5G网络 -&gt; ZLMediaKit/WVP平台 -&gt; 指挥中心)</em></p>
<p>本文将复盘这次从问题发生到最终解决的全过程，深入剖析RTMP在不稳定网络下的“原罪”，并阐述为何拥抱新的WHIP协议才是走向真·实时的未来。</p>
<h1 id="一-问题的发生延迟的滚雪球效应"><a class="markdownIt-Anchor" href="#一-问题的发生延迟的滚雪球效应"></a> 一、问题的发生：延迟的“滚雪球”效应</h1>
<p>测试初期，在信号良好的办公区，无人机推流的RTMP画面清晰流畅，延迟也尚可接受。但当我们将场景切换到真实的作业环境——郊野山区时，问题暴露无遗。</p>
<p><strong>具体现象是：</strong></p>
<ol>
<li>无人机飞入一个4G信号稍弱的区域，直播画面开始出现短暂卡顿。</li>
<li>当无人机飞出该区域，网络信号恢复后，我们预期的画面恢复流畅并没有出现。</li>
<li>取而代之的，是画面开始以一种“快进”的方式播放之前卡顿和积压的内容。<strong>延迟从最初的几秒，迅速累积到几十秒，甚至一两分钟。</strong></li>
</ol>
<p>指挥中心看到的画面，已经是几分钟前无人机飞过的位置。这种“累积延迟”让实时指挥变成了“看历史录像”，对于需要即时决策的业务场景是致命的。我们仿佛掉进了一个延迟不断增加、永不恢复的“黑洞”。</p>
<h1 id="二-深度分析为何rtmp会陷入延迟黑洞"><a class="markdownIt-Anchor" href="#二-深度分析为何rtmp会陷入延迟黑洞"></a> 二、深度分析：为何RTMP会陷入延迟“黑洞”？</h1>
<p>“累积延迟”的罪魁祸首，并非无人机，也非ZLMediaKit，而是RTMP协议所依赖的——<strong>TCP传输协议</strong>。</p>
<p>TCP的设计哲学是 <strong>“可靠性至上”</strong>。它就像一位一丝不苟、甚至有些偏执的快递员，立下军令状：必须保证每一个包裹（数据包），都按原始顺序、完好无损地送到收件人手中。</p>
<p>为了实现这一目标，TCP设计了两个关键机制：</p>
<ol>
<li><strong>丢包重传：</strong> 快递员在路上丢了个包裹（网络丢包），他不会继续派送下一个，而是会停下来，打电话回仓库（发送端），要求重新发一个一模一样的包裹。这个“沟通-重发”的过程本身就需要时间。</li>
<li><strong>队头阻塞 (Head-of-line Blocking)：</strong> 在等待丢失的包裹被重新送达期间，后面所有的包裹，即使已经到达了本地的派送点（接收端缓冲区），也必须排队等着，直到那个丢失的包裹被找到。</li>
</ol>
<p>现在，让我们把这个模型套用到无人机直播上：</p>
<p>无人机在空中通过4G/5G网络推流，这种无线移动网络环境天生就不稳定，信号波动和瞬时丢包是家常便饭。</p>
<ul>
<li>一旦发生丢包，TCP的重传机制启动，开始等待。</li>
<li>等待期间，无人机的摄像头和编码器可没闲着，它们还在源源不断地生成新的视频数据。</li>
<li>这些新数据被TCP接收后，因为要等待前面的“旧债”还清，只能在ZLMediaKit服务器的接收缓冲区里不断堆积。</li>
</ul>
<p>网络越差，丢包越多，等待和堆积就越严重。这就形成了延迟“滚雪球”的恶性循环。即使后来网络恢复了，服务器也必须先把缓冲区里堆积如山的“旧数据”按顺序处理完，才能播放最新的画面。</p>
<h1 id="三优化的误区调整buffer为何治标不治本"><a class="markdownIt-Anchor" href="#三优化的误区调整buffer为何治标不治本"></a> 三：“优化”的误区：调整Buffer为何治标不治本？</h1>
<p>在遇到“累积延迟”后，我们的第一反应几乎是教科书式的：<strong>调整缓冲区（Buffer）</strong>。直觉告诉我们，既然数据堆积了，那就把缓冲区改小，不让它堆积不就行了吗？于是我们分别在播放端和推流端进行了尝试。</p>
<p><strong>1. 清空播放端缓存</strong></p>
<p>让播放端不等了，来一个包就播一个，是不是就行了？我们先尝试将播放器的Jitter Buffer（抖动缓冲）设置得几乎为零。</p>
<ul>
<li>
<p><strong>我们的设想：</strong> 播放器不再“积攒”视频数据，从而消除因为缓存带来的延迟。</p>
</li>
<li>
<p><strong>实际结果：一场灾难。</strong></p>
<ul>
<li><strong>Jitter Buffer的核心作用：</strong> 播放端缓存的真正使命，不是为了累积延迟，恰恰相反，是为了“对抗网络抖动”，保证画面的流畅播放。它会预先缓存几秒钟的数据，像一个小蓄水池。当网络发生短暂波动，某个数据包迟到了，播放器可以先从这个“蓄水池”里取水播放，从而让观众感觉不到网络的抖动。</li>
<li><strong>零缓存的后果：</strong> 把这个“蓄水池”抽干后，任何微小的网络抖动、一个数据包哪怕零点几秒的延迟，都会让播放器瞬间“断水”。它没有数据可播，只能停下来等下一个数据包的到来。</li>
<li><strong>观众看到的现象：</strong> 频繁的画面卡顿、冻结、转圈加载。原本“高延迟但还算流畅”的体验，瞬间变成了“高延迟且卡顿无比”的“PPT式播放”。</li>
<li><strong>效果总结：</strong> 这个操作，就像是嫌一个病人走路慢（高延迟），干脆打断了他的腿（去掉缓存），让他一瘸一拐地跳着走（频繁卡顿）。这不仅没有解决根本问题，反而极大地破坏了最基本的观看体验。</li>
</ul>
</li>
</ul>
<p><strong>2. 极限压缩推流端缓存</strong></p>
<p>我们又试图将无人机内置推流服务的发送缓冲区设置到尽可能小。</p>
<ul>
<li>
<p><strong>我们的设想：</strong> 当网络变差，TCP协议栈反馈说“发不出去”时，由于推流端的缓冲区很小，新生成的视频帧就会因为无处存放而被丢弃。这样一来，就不会有新的数据进入拥堵的“队列”，从而阻止延迟的进一步累积。</p>
</li>
<li>
<p><strong>实际结果：</strong> 这一招确实在一定程度上<strong>缓解了延迟的无限累积</strong>。当网络恢复时，延迟不会像之前那样夸张到分钟级。但是，它带来了新的问题，并且远未达到我们想要的实时效果：</p>
<ul>
<li><strong>无法清偿“历史旧债”：</strong> 丢弃新数据帧，只是阻止了“债务”继续增加。但那些<strong>已经被TCP接管、正在网络中苦苦等待重传</strong>的数据包，它们的延迟是无法被消除的。我们看到的画面依然是滞后的，只是滞后的时间被控制在了一个相对固定的范围内。</li>
<li><strong>推流端性能风险：</strong> 这种强制的丢帧行为，本质上是在应用层“对抗”TCP的可靠性机制。如果处理不当，可能会反过来阻塞编码器，导致推流源头本身就出现画面采集卡顿，甚至推流中断。</li>
<li><strong>效果总结：</strong> 这相当于给一个不断漏水的管道打上了一个“减压阀”。水流（延迟）不再无限增大，但管道本身漏水（根本性的TCP重传问题）的事实没有改变。这是一种<strong>有效的“妥协”</strong>，但绝不是<strong>优雅的“解决”</strong>。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong></p>
<p>经过这两轮尝试，我们深刻地认识到，想在RTMP（TCP）的框架内，通过简单地调整Buffer来“根治”累积延迟，是一种技术上的“幻想”。延迟的根源深植于TCP协议“可靠性优先”的设计基因中。任何试图在应用层挑战这一点的“小聪明”，最终都只能是收效甚微的“补丁”，甚至可能带来更糟的副作用。这也促使我们下定决心，必须从协议层面进行彻底的革新。</p>
<p><strong>结论很明确：只要还在TCP这条路上跑，RTMP的累积延迟问题就无法从根本上解决。我们需要换一条路。</strong></p>
<h1 id="四-柳暗花明拥抱whip迎接真实时"><a class="markdownIt-Anchor" href="#四-柳暗花明拥抱whip迎接真实时"></a> 四、柳暗花明：拥抱WHIP，迎接真·实时</h1>
<p>幸运的是，大疆在其新的SDK中，除了RTMP，也提供了对 <strong>WHIP协议</strong> 的支持。而我们使用的ZLMediaKit，同样对WHIP有着优秀的支持。这正是我们的破局之道。</p>
<p><strong>那什么是WHIP？它和WebRTC又是什么关系？</strong></p>
<ul>
<li><strong>WebRTC</strong> 是一种专为实时通信（Real-Time Communication）设计的技术，它的设计哲学与TCP截然相反，是 <strong>“实时性至上”</strong>。它主要基于<strong>UDP协议</strong>。</li>
<li><strong>UDP</strong> 就像一个只管投递、不问结果的快递员。它速度飞快，但包裹可能会丢，也可能不按顺序到达。</li>
<li>WebRTC的聪明之处在于，它在UDP之上建立了一套智能的控制逻辑（RTP/RTCP协议）。这套逻辑能实时监控网络质量（丢包率、延迟），然后动态地通知发送端：“喂，路况不好，你少发点货（降低码率），或者把不那么重要的货扔掉（主动跳帧）！”</li>
<li><strong>WHIP (WebRTC-HTTP Ingestion Protocol)</strong> 则可以理解为一座标准化的桥梁。它让像大疆无人机这样的推流设备，能通过一个简单的HTTP请求，就与ZLMediaKit这样的媒体服务器“握手成功”，然后建立起一条高效的WebRTC传输通道。</li>
</ul>
<p>我们立刻切换了方案：在无人机推流设置中，将协议由RTMP改为WHIP，地址指向ZLMediaKit的WHIP接收地址。</p>
<p><strong>效果立竿见影：</strong></p>
<p>延迟被稳定地控制在了<strong>亚秒级（通常在500ms以内）</strong>。更关键的是，当无人机再次飞入信号不佳的区域时：</p>
<ul>
<li><strong>不再有延迟累积</strong>。</li>
<li>画面表现为短暂的<strong>跳帧</strong>或一过性的<strong>模糊</strong>（码率自适应降低）。</li>
<li>一旦信号恢复，画面会<strong>瞬间恢复清晰和流畅</strong>，始终与无人机的实时视角保持同步。</li>
</ul>
<p>这种“宁可丢弃部分画面，也要保证实时”的策略，完美地满足了我们对无人机直播的核心诉求。</p>
<h1 id="五-总结与思考"><a class="markdownIt-Anchor" href="#五-总结与思考"></a> 五、总结与思考</h1>
<p>这次从RTMP到WHIP的切换，不仅仅是一次简单的技术升级，更让我们深刻体会到了“选择比努力更重要”的道理。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>RTMP (基于TCP)</th>
<th>WHIP (基于WebRTC/UDP)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计哲学</strong></td>
<td>可靠性优先</td>
<td>实时性优先</td>
</tr>
<tr>
<td><strong>网络波动表现</strong></td>
<td><strong>延迟累积</strong>，画面越来越不同步</td>
<td><strong>跳帧/降码率</strong>，始终保持实时</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>电视台等稳定网络环境下的内容分发</td>
<td>无人机、户外直播等不稳定网络下的实时互动</td>
</tr>
</tbody>
</table>
<p><strong>我们的思考：</strong></p>
<ol>
<li><strong>技术没有绝对的好坏，只有场景的适配。</strong> RTMP作为一个“老将”，在网络稳定的场景（如室内演播厅）依然能胜任。但对于无人机这种典型的移动、弱网应用，它的TCP根基决定了它必然会水土不服。</li>
<li><strong>拥抱标准化是趋势。</strong> WHIP协议的出现，为WebRTC的推流（Ingest）提供了一个优雅的、统一的解决方案，打通了设备端和服务端的生态。大疆、ZLMediaKit这样的行业领先者对它的支持，预示着超低延迟直播正在走向标准化和普及化。</li>
<li><strong>对直播延迟的认知需要升级。</strong> 在过去，我们谈论延迟，可能关心的是3-5秒。但在万物互联、强调实时交互的今天，亚秒级的延迟正在从“加分项”变为“必需品”。</li>
</ol>
<p>对于所有从事无人机或户外移动直播的同行，如果你们还在被RTMP的累积延迟所困扰，那么，是时候检查一下你的设备和平台，勇敢地拥抱WHIP和WebRTC了。这不仅是一条新的技术路径，更是通往“真·实时”未来的高速公路。</p>
]]></content>
      <categories>
        <category>技术实践</category>
        <category>流媒体技术</category>
      </categories>
      <tags>
        <tag>RTMP</tag>
        <tag>WebRTC</tag>
        <tag>WHIP</tag>
        <tag>低延迟直播</tag>
        <tag>大疆无人机</tag>
        <tag>ZLMediaKit</tag>
        <tag>WVP</tag>
        <tag>实时图传</tag>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析：Spring Boot 中 ForkJoinPool 导致 ClassPathResource 找不到资源的排查与解决</title>
    <url>/2025/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%9Aspring-boot-%E4%B8%AD-forkjoinpool-%E5%AF%BC%E8%87%B4-classpathresource-%E6%89%BE%E4%B8%8D%E5%88%B0%E8%B5%84%E6%BA%90%E7%9A%84%E6%8E%92%E6%9F%A5%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="1-问题现象"><a class="markdownIt-Anchor" href="#1-问题现象"></a> 1. 问题现象</h1>
<p>在开发一个基于 Spring Boot 的复杂业务系统时，我们通常会利用 <code>CompletableFuture</code> 来执行异步任务，以提升应用的吞吐量和响应速度。在一个需要异步调用 Redis Lua 脚本的场景中，我们遇到了一个只在测试和生产环境（通过 <code>java -jar</code> 启动）才会出现的 <code>FileNotFoundException</code>。</p>
<p><strong>业务场景</strong>：一个自动化工作流需要异步执行一个存储在类路径下的 Lua 脚本（<code>scripts/update_device_shadow.lua</code>）来原子性地更新 Redis 中的数据。</p>
<p><strong>核心代码逻辑</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 DefaultRedisScript 来封装 Lua 脚本</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">redisScript.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;scripts/update_device_shadow.lua&quot;</span>)));</span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 CompletableFuture.runAsync() 异步执行</span></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    redisTemplate.execute(redisScript, keys, args);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>错误日志</strong>： 在通过 <code>java -jar</code> 命令启动应用后，上述代码会抛出以下异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2025-08-06 17:59:07.831 [ForkJoinPool.commonPool-worker-1] ERROR c.d.b.e.s.i.EventProcessFlowServiceImpl - 流程步骤执行失败...</span><br><span class="line">org.springframework.data.redis.core.script.ScriptingException: Error reading script text; nested exception is java.io.FileNotFoundException: class path resource [scripts/update_device_shadow.lua] cannot be opened because it does not exist</span><br><span class="line">        at org.springframework.data.redis.core.script.DefaultRedisScript.getScriptAsString(DefaultRedisScript.java:113)</span><br><span class="line">        // ... 中间业务调用链</span><br><span class="line">        at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)</span><br><span class="line">        at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinWorkerThread.java:165)</span><br><span class="line">Caused by: java.io.FileNotFoundException: class path resource [scripts/update_device_shadow.lua] cannot be opened because it does not exist</span><br><span class="line">        at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:203)</span><br><span class="line">        at org.springframework.data.redis.core.script.DefaultRedisScript.getScriptAsString(DefaultRedisScript.java:111)</span><br><span class="line">        ... 39 common frames omitted</span><br></pre></td></tr></table></figure>
<p>日志清晰地指出了三个关键点：</p>
<ol>
<li><strong>异常</strong>: <code>FileNotFoundException</code>，类路径资源 <code>scripts/update_device_shadow.lua</code> 不存在。</li>
<li><strong>执行环境</strong>: 错误发生在名为 <code>ForkJoinPool.commonPool-worker-1</code> 的线程中。</li>
<li><strong>触发原因</strong>: 异步任务由 <code>CompletableFuture$AsyncRun</code> 执行。</li>
</ol>
<h1 id="2-核心原因分析"><a class="markdownIt-Anchor" href="#2-核心原因分析"></a> 2. 核心原因分析</h1>
<p>此问题的根源在于 <strong>Java 类加载器（ClassLoader）机制</strong>与 <strong>Spring Boot Fat JAR 运行模式</strong>之间的冲突。</p>
<h2 id="21-spring-boot-fat-jar-的类加载机制"><a class="markdownIt-Anchor" href="#21-spring-boot-fat-jar-的类加载机制"></a> 2.1 Spring Boot Fat JAR 的类加载机制</h2>
<p>当使用 <code>spring-boot-maven-plugin</code> 将应用打包成一个可执行的 Fat JAR 时，应用的类和资源文件被打包进 <code>BOOT-INF/classes/</code>，依赖库被打包进 <code>BOOT-INF/lib/</code>。标准的 JVM 类加载器无法直接读取这种嵌套结构。</p>
<p>为此，Spring Boot 提供了一个特殊的类加载器——<code>org.springframework.boot.loader.LaunchedURLClassLoader</code>。当应用通过 <code>java -jar</code> 启动时，<code>LaunchedURLClassLoader</code> 会被设置为主线程的<strong>线程上下文类加载器 (Thread Context ClassLoader)</strong>。它知道如何从 <code>BOOT-INF/</code> 目录中正确地加载类和资源。</p>
<h2 id="22-forkjoinpoolcommonpool-的类加载器"><a class="markdownIt-Anchor" href="#22-forkjoinpoolcommonpool-的类加载器"></a> 2.2 ForkJoinPool.commonPool 的类加载器</h2>
<p><code>CompletableFuture.runAsync(Runnable runnable)</code> 在不指定 <code>Executor</code> 的情况下，默认使用 <code>ForkJoinPool.commonPool()</code>。这是一个 JVM 级别的、全局共享的静态线程池。它的创建和管理独立于 Spring 应用上下文。</p>
<p>因此，<code>commonPool</code> 中的工作线程<strong>不会</strong>继承 Spring Boot 主线程的 <code>LaunchedURLClassLoader</code>。这些线程的上下文类加载器是 JVM 默认的 <strong><code>AppClassLoader</code></strong>（或称 <code>SystemClassLoader</code>）。</p>
<h2 id="23-根源类加载器的冲突"><a class="markdownIt-Anchor" href="#23-根源类加载器的冲突"></a> 2.3 根源：类加载器的冲突</h2>
<p>当我们的业务逻辑在 <code>ForkJoinPool.commonPool-worker-1</code> 线程中执行时：</p>
<ol>
<li><code>new ClassPathResource(&quot;...&quot;)</code> 被调用。</li>
<li>它内部会通过 <code>Thread.currentThread().getContextClassLoader()</code> 获取当前线程的类加载器，即 <code>AppClassLoader</code>。</li>
<li><code>AppClassLoader</code> 尝试在类路径下寻找 <code>scripts/update_device_shadow.lua</code>。</li>
<li>由于 <code>AppClassLoader</code> 不理解 Fat JAR 的 <code>BOOT-INF/classes/</code> 结构，它无法找到该文件，最终导致 <code>FileNotFoundException</code>。</li>
</ol>
<p><strong>简而言之：我们试图用一个不认识 Fat JAR 结构的类加载器（<code>AppClassLoader</code>），去加载一个只有 <code>LaunchedURLClassLoader</code> 才认识的嵌套资源。</strong></p>
<h1 id="3-解决方案"><a class="markdownIt-Anchor" href="#3-解决方案"></a> 3. 解决方案</h1>
<p>解决此问题的核心思想是：<strong>确保异步任务在执行时，能够使用正确的、了解应用上下文的类加载器。</strong></p>
<h2 id="方案一推荐使用-spring-管理的自定义线程池"><a class="markdownIt-Anchor" href="#方案一推荐使用-spring-管理的自定义线程池"></a> 方案一（推荐）：使用 Spring 管理的自定义线程池</h2>
<p>这是最规范、最彻底的解决方案。在 Spring 中定义一个线程池 Bean，由 Spring 容器创建的线程会自动继承主应用的上下文，包括正确的类加载器。</p>
<p><strong>1. 创建线程池配置类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ASYNC_EXECUTOR_NAME</span> <span class="operator">=</span> <span class="string">&quot;appAsyncExecutor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(ASYNC_EXECUTOR_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">appAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        <span class="comment">// 根据实际需求配置核心线程数、最大线程数、队列容量等</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">100</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;AppAsync-&quot;</span>);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 初始化，使其被 Spring 完全管理</span></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在业务代码中指定执行器：</strong> 将自定义的 <code>Executor</code> Bean 注入，并作为 <code>CompletableFuture</code> 的第二个参数传入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(ThreadPoolConfig.ASYNC_EXECUTOR_NAME)</span></span><br><span class="line">    <span class="keyword">private</span> Executor appAsyncExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeMyAsyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 在此线程中执行的代码，可以正确加载类路径资源</span></span><br><span class="line">            DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">            redisScript.setScriptSource(<span class="keyword">new</span> <span class="title class_">ResourceScriptSource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;scripts/update_device_shadow.lua&quot;</span>)));</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;, appAsyncExecutor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方案二不推荐手动传递-classloader"><a class="markdownIt-Anchor" href="#方案二不推荐手动传递-classloader"></a> 方案二（不推荐）：手动传递 ClassLoader</h2>
<p>如果无法使用自定义线程池，可以作为一种临时变通方案，手动在任务开始前设置正确的上下文类加载器。这种方式会使代码变得冗长且容易出错，不建议在生产代码中大规模使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程中捕获正确的 ClassLoader</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">contextClassLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 在子线程中手动设置</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(contextClassLoader);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ... 执行资源加载代码 ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最好在任务结束后清理，避免潜在的内存泄漏</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="4-总结与最佳实践"><a class="markdownIt-Anchor" href="#4-总结与最佳实践"></a> 4. 总结与最佳实践</h1>
<ol>
<li><strong>明确指定执行器</strong>：当使用 <code>CompletableFuture</code> 执行需要访问 Spring 应用上下文（如资源、AOP、事务等）的异步任务时，<strong>必须</strong>为其指定一个由 Spring 管理的 <code>Executor</code>，<strong>严禁</strong>使用无参的 <code>runAsync()</code> 或 <code>supplyAsync()</code> 方法。</li>
<li><strong>统一线程池管理</strong>：在应用中，所有业务相关的线程池都应作为 Bean 交给 Spring 容器管理，便于统一配置、监控和维护。</li>
<li><strong>环境一致性测试</strong>：在持续集成流程中，应增加使用 <code>java -jar</code> 命令启动并运行核心流程的自动化测试，以尽早发现此类由于运行环境差异导致的问题。</li>
</ol>
]]></content>
      <categories>
        <category>技术故障复盘与 RCA</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Lua</tag>
        <tag>Spring Boot</tag>
        <tag>ClassLoader</tag>
        <tag>ForkJoinPool</tag>
        <tag>CompletableFuture</tag>
        <tag>多线程</tag>
        <tag>Fat JAR</tag>
        <tag>FileNotFoundException</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 SSH 连接到 GitHub</title>
    <url>/2025/%E9%80%9A%E8%BF%87%20SSH%20%E8%BF%9E%E6%8E%A5%E5%88%B0%20GitHub/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vemgvYXV0aGVudGljYXRpb24vY29ubmVjdGluZy10by1naXRodWItd2l0aC1zc2g=">通过 SSH 连接到 GitHub - GitHub 文档<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>
<p>生成SSH密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -f my_github_ed25519 -C <span class="string">&quot;your_email&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>-o</code> : 使用新的OpenSSH格式来存储私钥，当使用ed25519格式时，默认会启用此选项</p>
<p><code>-t</code> : 创建的key的类型，我们使用ed25519</p>
<p><code>-f</code> : 生成的文件路径，默认在当前目录下</p>
<p><code>-C</code> : 可选注释，通常写自己的邮箱</p>
<p>之后一直回车就行</p>
</li>
<li>
<p>打开<code>my_github_ed25519.pub</code>，复制内容，到<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2tleXM=">SSH and GPG keys (github.com)<i class="fa fa-external-link-alt"></i></span>中新建SSH key，粘贴复制的公钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/my_github_ed25519.pub</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>添加ssh证书</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/my_github_ed25519</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>测试连接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="comment"># 如果超时，可以使用</span></span><br><span class="line">ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
